<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux基础-14-加密和安全 | Kinmfer's Blogs</title><meta name="keywords" content="Linux基础,系统"><meta name="author" content="Kinmfer,kinmfer@foxmail.com"><meta name="copyright" content="Kinmfer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="墨菲定律：一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的， 原话：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导 致灾难，则必定有人会做出这种选择 主要内容：  任何事都没有表面看起来那么简单 所有的事都会比你预计的时间长 会出错的事总会出错 如果你担心某种情况发生，那么它就更有可能发生   安全安全机制 信息安全防护的目标  保密性 Confiden">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础-14-加密和安全">
<meta property="og:url" content="https://kinmfer.github.io/2020/05/05/Linux%E5%9F%BA%E7%A1%80-14-%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="Kinmfer&#39;s Blogs">
<meta property="og:description" content="墨菲定律：一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的， 原话：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导 致灾难，则必定有人会做出这种选择 主要内容：  任何事都没有表面看起来那么简单 所有的事都会比你预计的时间长 会出错的事总会出错 如果你担心某种情况发生，那么它就更有可能发生   安全安全机制 信息安全防护的目标  保密性 Confiden">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg">
<meta property="article:published_time" content="2020-05-05T06:45:37.000Z">
<meta property="article:modified_time" content="2020-09-24T06:46:32.483Z">
<meta property="article:author" content="Kinmfer">
<meta property="article:tag" content="Linux基础">
<meta property="article:tag" content="系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kinmfer.github.io/2020/05/05/Linux%E5%9F%BA%E7%A1%80-14-%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c46ed77365f502de73543fbf10399875";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C2N62A47W9","apiKey":"0c62f17095ec2a20c19657511a42c0b1","indexName":"Blogs","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章更新于","messageNext":"天前,内容可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kinmfer","link":"链接: ","source":"来源: Kinmfer's Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-09-24 14:46:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = '1  Following System Settings, if the system doesn't support dark mode, it will switch dark mode between 6 pm to 6 am'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kinmfer's Blogs</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Linux基础-14-加密和安全</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-05T06:45:37.000Z" title="发表于 2020-05-05 14:45:37">2020-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-24T06:46:32.483Z" title="更新于 2020-09-24 14:46:32">2020-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>墨菲定律：一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的， 原话：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导 致灾难，则必定有人会做出这种选择</p>
<p>主要内容：</p>
<ol>
<li>任何事都没有表面看起来那么简单</li>
<li>所有的事都会比你预计的时间长</li>
<li>会出错的事总会出错</li>
<li>如果你担心某种情况发生，那么它就更有可能发生</li>
</ol>
</blockquote>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h2><ul>
<li><p>信息安全防护的目标</p>
<ul>
<li>保密性 Confidentiality</li>
<li>完整性 Integrity</li>
<li>可用性 Usability</li>
<li>可控制性 Controlability</li>
<li>不可否认性 Non-repudiation</li>
</ul>
</li>
<li><p>安全防护环节</p>
<ul>
<li>物理安全：各种设备/主机、机房环境</li>
<li>系统安全：主机或设备的操作系统</li>
<li>应用安全：各种网络服务、应用程序</li>
<li>网络安全：对网络访问的控制、防火墙规则</li>
<li>数据安全：信息的备份与恢复、加密解密</li>
<li>管理安全：各种保障性的规范、流程、方法</li>
</ul>
</li>
<li><p>安全攻击： STRIDE</p>
<ul>
<li>Spoofing 假冒</li>
<li>Tampering 篡改</li>
<li>Repudiation 否认</li>
<li>Information Disclosure 信息泄漏</li>
<li>Denial of Service 拒绝服务</li>
<li>Elevation of Privilege 提升权限</li>
</ul>
</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>使用成熟的安全系统</li>
<li>以小人之心度输入数据</li>
<li>外部系统是不安全的</li>
<li>最小授权</li>
<li>减少外部接口</li>
<li>缺省使用安全模式</li>
<li>安全不是似是而非</li>
<li>从STRIDE思考</li>
<li>在入口处检查</li>
<li>从管理上保护好你的系统</li>
</ul>
<h2 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h2><ul>
<li>常用安全技术<ul>
<li>认证</li>
<li>授权</li>
<li>审计</li>
<li>安全通信</li>
</ul>
</li>
<li>加密算法和协议<ul>
<li>对称加密</li>
<li>公钥加密</li>
<li>单向加密</li>
<li>认证协议</li>
</ul>
</li>
</ul>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><ul>
<li>对称加密：加密和解密使用同一个密钥<ul>
<li>DES：Data Encryption Standard，64bits</li>
<li>3DES：Triple DES</li>
<li>AES：Advanced (128, 192, 256, 384bits)</li>
<li>Blowfish</li>
<li>Twofish</li>
<li>IDEA</li>
<li>RC6</li>
<li>CAST5</li>
</ul>
</li>
<li>特性：<ol>
<li>加密、解密使用同一个密钥，效率高</li>
<li>将原始数据分割成固定大小的块，逐个进行加密</li>
</ol>
</li>
<li>缺陷：<ol>
<li>密钥过多</li>
<li>密钥分发</li>
<li>数据来源无法确认</li>
</ol>
</li>
</ul>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><ul>
<li>基于一对公钥/密钥对<ul>
<li>用密钥对中的一个加密，另一个解密</li>
</ul>
</li>
<li>实现加密：<ul>
<li>接收者<ul>
<li>生成公钥/密钥对：P和S</li>
<li>公开公钥P，保密密钥S</li>
</ul>
</li>
<li>发送者<ul>
<li>使用接收者的公钥来加密消息M</li>
<li>将P(M)发送给接收者</li>
</ul>
</li>
<li>接收者<ul>
<li>使用密钥S来解密：M=S(P(M))</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>实现数字签名：<ul>
<li>发送者<ul>
<li>生成公钥/密钥对：P和S</li>
<li>公开公钥P，保密密钥S</li>
<li>使用密钥S来加密消息M</li>
<li>发送给接收者S(M)</li>
</ul>
</li>
<li>接收者<ul>
<li>使用发送者的公钥来解密M=P(S(M))</li>
</ul>
</li>
</ul>
</li>
<li>结合签名和加密</li>
<li>分离签名</li>
</ul>
<h3 id="RSA和DSA"><a href="#RSA和DSA" class="headerlink" title="RSA和DSA"></a>RSA和DSA</h3><ul>
<li><p>RSA：公钥加密算法是1977年由Ron Rivest、Adi Shamirh和LenAdleman在（美国麻省理工学院）开发的，RSA取名来自开发他们三者的名字，后成立RSA 数据安全有限公司。RSA是目前最有影响力的公钥加密算法，它能够抵抗到目 前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA算法基于 一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积 进行因式分解却极其困难，因此可以将乘积公开作为加密密钥</p>
</li>
<li><p>DSA (Digital Signature Algorithm)：1991年7月26日提交，并归属于DavidW. Kravitz前NSA员工，DSA是Schnorr和ElGamal签名算法的变种，被美国 NIST作为SS(DigitalSignature Standard)， DSA是基于整数有限域离散对数难 题的，其安全性与RSA相比差不多。DSA只是一种算法，和RSA不同之处在于<strong>它不能用作加密和解密，也不能进行密钥交换，只用于签名</strong>,它比RSA要快很多</p>
</li>
</ul>
<h3 id="单向散列"><a href="#单向散列" class="headerlink" title="单向散列"></a>单向散列</h3><ul>
<li><p>将任意数据缩小成固定大小的“指纹”</p>
<ul>
<li>任意长度输入</li>
<li>固定长度输出</li>
<li>有雪崩效应</li>
<li>若修改数据，指纹也会改变（“不会产生冲突”）</li>
</ul>
</li>
<li><p>无法从指纹中重新生成数据（“单向”）</p>
</li>
<li><p>功能：校验数据完整性</p>
</li>
<li><p>常见算法</p>
<ul>
<li>md5: 128bits</li>
<li>sha1: 160bits</li>
<li>sha224 </li>
<li>sha256</li>
<li>sha384</li>
<li>512</li>
</ul>
</li>
<li><p>常用工具</p>
<ul>
<li>md5sum | sha1sum [ –check ] file</li>
<li>openssl、gpg</li>
<li>rpm -V</li>
</ul>
</li>
</ul>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507082258192.png" alt="image-20200507082258192"></p>
<h3 id="应用程序：RPM"><a href="#应用程序：RPM" class="headerlink" title="应用程序：RPM"></a>应用程序：RPM</h3><ul>
<li><p>文件完整性的两种实施方式</p>
</li>
<li><p>被安装的文件</p>
<ul>
<li><p>MD5单向散列</p>
</li>
<li><p><code>rpm --verify package_name</code> (or -V)</p>
</li>
</ul>
</li>
<li><p>发行的软件包文件</p>
<ul>
<li>GPG公钥签名</li>
<li>rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat*</li>
<li>rpm –checksig pakage_file_name (or -K)</li>
</ul>
</li>
</ul>
<h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><ul>
<li><p>密钥交换：IKE（ Internet Key Exchange ） </p>
<p>公钥加密：DH (Deffie-Hellman)：生成会话密钥，由惠特菲尔德·迪菲（Bailey Whitfield Diffie）和马丁·赫尔曼（Martin Edward Hellman）在1976年发表，参看：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a></p>
</li>
<li><p>DH：</p>
<ul>
<li><p>A: g,p 协商生成公开的整数g, 大素数p </p>
<p>B: g,p</p>
</li>
<li><p>A:生成隐私数据 :a (a&lt;p )，计算得出 g^a%p，发送给B</p>
<p>B:生成隐私数据 :b,计算得出 g^b%p，发送给A</p>
</li>
<li><p>A:计算得出 [(g^b%p)^a] %p = g^ab%p，生成为密钥</p>
<p>B:计算得出 [(g^a%p)^b] %p = g^ab%p，生成为密钥</p>
</li>
</ul>
</li>
</ul>
<h3 id="gpg加密"><a href="#gpg加密" class="headerlink" title="gpg加密"></a>gpg加密</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ul>
<li><p>对称加密file文件</p>
<p><code>gpg -c file</code></p>
<p><code>ls file.gpg</code></p>
</li>
<li><p>在另一台主机上解密file </p>
<p><code>gpg -o file -d file.gpg</code></p>
</li>
</ul>
<h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><ul>
<li><p>在hostB主机上用公钥加密，在hostA主机上解密</p>
</li>
<li><p>在hostA主机上生成公钥/私钥对</p>
<p><code>gpg --gen-key</code></p>
</li>
<li><p>在hostA主机上查看公钥 </p>
<p><code>gpg --list-keys</code></p>
</li>
<li><p>在hostA主机上导出公钥到xxx.pubkey</p>
<p><code>gpg -a --export -o xxx.pubkey</code></p>
</li>
<li><p>从hostA主机上复制公钥文件到需加密的B主机上</p>
<p><code>scp xxx.pubkey hostB:</code></p>
</li>
<li><p>在需加密数据的hostB主机上生成公钥/私钥对 </p>
<p><code>gpg --list-keys</code></p>
<p><code>gpg --gen-key</code></p>
</li>
<li><p>在hostB主机上导入公钥</p>
<p><code>gpg --import xxx.pubkey</code></p>
<p><code>gpg --list-keys</code></p>
</li>
<li><p>用从hostA主机导入的公钥，加密hostB主机的文件file,生成file.gpg </p>
<p><code>gpg -e -r wangxiaochun file</code></p>
<p><code>file file.gpg</code></p>
</li>
<li><p>复制加密文件到hostA主机 </p>
<p><code>scp fstab.gpg hostA:</code></p>
</li>
<li><p>在hostA主机解密文件 </p>
<p><code>gpg -d file.gpg</code></p>
<p><code>gpg -o file -d file.gpg</code></p>
</li>
<li><p>删除公钥和私钥</p>
<p><code>gpg --delete-keys xxx</code></p>
<p><code>gpg --delete-secret-keys xxx</code></p>
</li>
</ul>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507083125751.png" alt="image-20200507083125751"></p>
<h2 id="CA和证书"><a href="#CA和证书" class="headerlink" title="CA和证书"></a>CA和证书</h2><ul>
<li>PKI：Public Key Infrastructure<ul>
<li>签证机构：CA（Certificate Authority)</li>
<li>注册机构：RA</li>
<li>证书吊销列表：CRL</li>
<li>证书存取库：</li>
</ul>
</li>
<li>X.509：定义了证书的结构以及认证协议标准<ul>
<li>版本</li>
<li>序列</li>
<li>签名算法</li>
<li>颁发者</li>
<li>有效期限</li>
<li>主体名称</li>
<li>主体公钥</li>
<li>CRL分发点</li>
<li>扩展信息</li>
<li>发行者签名</li>
</ul>
</li>
</ul>
<h3 id="证书获取"><a href="#证书获取" class="headerlink" title="证书获取"></a>证书获取</h3><ul>
<li>证书类型：<ul>
<li>证书授权机构的证书</li>
<li>服务器</li>
<li>用户证书</li>
</ul>
</li>
<li>获取证书两种方法：<ul>
<li>使用证书授权机构<ul>
<li>生成证书请求（csr）</li>
<li>将证书请求csr发送给CA</li>
<li>CA签名颁发证书</li>
</ul>
</li>
<li>自签名的证书<ul>
<li>自已签发自己的公钥</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h2><ul>
<li><p>SSL：Secure Socket Layer，TLS: Transport Layer Security</p>
<ul>
<li>1995：SSL 2.0 Netscape</li>
<li>1996：SSL 3.0</li>
<li>1999：TLS 1.0</li>
<li>2006：TLS 1.1 IETF(Internet工程任务组) RFC 4346</li>
<li>2008：TLS 1.2 当前使用</li>
<li>2015：TLS 1.3</li>
</ul>
<p>功能：机密性，认证，完整性，重放保护</p>
</li>
<li><p>两阶段协议，分为握手阶段和应用阶段</p>
<ul>
<li><p>握手阶段(协商阶段):客户端和服务器端认证对方身份（依赖于PKI体系，利用数字证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。后续通信使 用的所有密钥都是通过MasterSecret生成</p>
</li>
<li><p>应用阶段:在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密 钥进行安全通信</p>
</li>
</ul>
</li>
</ul>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507083702027.png" alt="image-20200507083702027"></p>
<ul>
<li>Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身 份认证可选）、密钥交换</li>
<li>ChangeCipherSpec 协议：一条消息表明握手协议已经完成</li>
<li>Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别， fatal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续， 只是会给出错误警告</li>
<li>Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等</li>
<li>HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合。HTTP over SSL”或“HTTP over TLS”，对http协议的文本数据进行加密处理后，成为二 进制形式传输</li>
</ul>
<h3 id="HTTPS结构"><a href="#HTTPS结构" class="headerlink" title="HTTPS结构"></a>HTTPS结构</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507083805300.png" alt="image-20200507083805300"></p>
<h3 id="HTTPS工作过程"><a href="#HTTPS工作过程" class="headerlink" title="HTTPS工作过程"></a>HTTPS工作过程</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507083826548.png" alt="image-20200507083826548"></p>
<h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h2><ul>
<li><p>OpenSSL：开源项目 </p>
<p>三个组件：</p>
<ul>
<li>openssl：多用途的命令行工具，包openssl </li>
<li>libcrypto：加密算法库，包openssl-libs，主要由开发者使用</li>
<li>libssl：加密模块应用库，实现了ssl及tls，包nss，主要由开发者使用</li>
</ul>
</li>
</ul>
<h3 id="openssl命令"><a href="#openssl命令" class="headerlink" title="openssl命令"></a>openssl命令</h3><ul>
<li><p>两种运行模式：交互模式和批处理模式 </p>
</li>
<li><p>openssl version：程序版本号</p>
</li>
<li><p>标准命令、消息摘要命令(dgst子命令)、加密命令(enc子命令)</p>
<p>标准命令：enc, ca, req, …</p>
</li>
<li><p>对称加密：</p>
<ul>
<li><p>工具：openssl enc, gpg</p>
</li>
<li><p>算法：3des, aes, blowfish, twofish</p>
</li>
</ul>
</li>
<li><p>enc命令：</p>
<ul>
<li>帮助：<code>man enc</code><ul>
<li>-e 加密 后+算法</li>
<li>-d 解密 后+算法</li>
</ul>
</li>
<li>-a 以base64文本格式编码<ul>
<li>-salt 加盐</li>
<li>-in 要加密的文件</li>
<li>-out 加密后生成的文件</li>
</ul>
</li>
<li>加密：<code>openssl enc -e -des3 -a -salt -in testfile -out testfile.cipher </code></li>
<li>解密：<code>openssl enc -d -des3 -a -salt –in testfile.cipher -out testfile</code></li>
</ul>
</li>
<li><p>单向加密：</p>
<p>工具：md5sum, sha1sum, sha224sum,sha256sum…openssl dgst</p>
</li>
<li><p>dgst命令：</p>
<ul>
<li><p>帮助：<code>man dgst</code></p>
</li>
<li><p><code>openssl dgst -md5 [-hex默认] /PATH/SOMEFILE </code></p>
</li>
<li><p><code>openssl dgst -md5 testfile</code></p>
</li>
<li><p><code>md5sum /PATH/TO/SOMEFILE</code></p>
</li>
</ul>
</li>
<li><p>MAC: Message Authentication Code，单向加密的一种延伸应用，用于实现 网络通信中保证所传输数据的完整性机制</p>
<ul>
<li>CBC-MAC</li>
<li>HMAC：使用md5或sha1算法</li>
</ul>
</li>
<li><p>生成用户密码：</p>
<p>passwd命令:</p>
<ul>
<li>帮助：<code>man sslpasswd</code></li>
<li><code>openssl passwd -1 -salt SALT</code>(最多8位)  -1表示使用md5算法</li>
<li>例：<code>openssl passwd -1 –salt centos</code></li>
</ul>
</li>
<li><p>生成随机数：</p>
<ul>
<li><p>帮助：<code>man sslrand</code></p>
</li>
<li><p><code>openssl rand -base64|-hex NUM</code></p>
<p>NUM: 表示字节数，使用-hex，每个字符为十六进制，相当于4位二进制， 出现的字符数为NUM*2</p>
</li>
</ul>
</li>
<li><p>公钥加密：</p>
<ul>
<li>算法：RSA, ELGamal</li>
<li>工具：gpg, openssl rsautl（man rsautl）</li>
</ul>
</li>
<li><p>数字签名：</p>
<ul>
<li>算法：RSA, DSA, ELGamal</li>
<li>工具：gpg, openssl rsautl（man rsautl）</li>
</ul>
</li>
<li><p>密钥交换：</p>
<ul>
<li><p>算法：dh</p>
</li>
<li><p>DSA：Digital Signature Algorithm </p>
</li>
<li><p>DSS：Digital Signature Standard </p>
</li>
<li><p>RSA：</p>
</li>
</ul>
</li>
<li><p>生成密钥对：<code>man genrsa</code></p>
<p><strong>生成私钥</strong></p>
<p><code>openssl genrsa -out /PATH/TO/PRIVATEKEY.FILE NUM_BITS </code></p>
<p><code>(umask 077; openssl genrsa –out test.key –des 2048) </code></p>
<ul>
<li>umask用来设定/PATH/TO/PRIVATE_KEY文件的权限</li>
<li>NUMBER_BITS 用来声明字节数，为2的整数倍</li>
<li>( )用来表示在子shell中运行，设定的内容对当前shell不产生影响</li>
</ul>
<p><code>openssl rsa -in test.key –out test2.key</code> 将加密key解密</p>
<p><strong>从私钥中提取出公钥</strong></p>
<p><code>openssl rsa -in PRIVATEKEYFILE –pubout –out PUBLICKEYFILE</code></p>
<p><code>openssl rsa –in test.key –pubout –out test.key.pub</code></p>
</li>
<li><p>随机数生成器：伪随机数字 </p>
<ul>
<li>键盘和鼠标，块设备中断</li>
<li>/dev/random：仅从熵池返回随机数；随机数用尽，阻塞</li>
<li>/dev/urandom：从熵池返回随机数；随机数用尽，会利用软件生成伪随机数,非阻塞</li>
</ul>
</li>
</ul>
<h3 id="CA和申请证书"><a href="#CA和申请证书" class="headerlink" title="CA和申请证书"></a>CA和申请证书</h3><ul>
<li><p>PKI：Public Key Infrastructure </p>
<ul>
<li>CA</li>
<li>RA </li>
<li>CRL</li>
<li>证书存取库</li>
</ul>
</li>
<li><p>建立私有CA:</p>
<ul>
<li>OpenCA </li>
<li>openssl</li>
</ul>
</li>
<li><p>证书申请及签署步骤： </p>
<ol>
<li>生成申请请求</li>
<li>RA核验</li>
<li>CA签署</li>
<li>获取证书</li>
</ol>
</li>
<li><p>创建私有CA：</p>
<ul>
<li><p>openssl的配置文件：/etc/pki/tls/openssl.cnf</p>
</li>
<li><p>三种策略：match匹配、optional可选、supplied提供 match：要求申请填写的信息跟CA设置信息必须一致 optional：可有可无，跟CA设置信息可不一致 supplied：必须填写这项申请信息，</p>
<ol>
<li><p>创建所需要的文件</p>
<p><code>touch /etc/pki/CA/index.txt</code> 生成证书索引数据库文件 </p>
<p><code>echo 01 &gt; /etc/pki/CA/serial</code> 指定第一个颁发证书的序列号</p>
</li>
<li><p>CA自签证书</p>
<ul>
<li><p>生成私钥</p>
<p><code>cd /etc/pki/CA/</code></p>
<p><code>(umask 077; openssl genrsa -des3 -out private/cakey.pem 2048)</code></p>
</li>
<li><p>生opem成自签名证书</p>
<p><code>openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650</code><br>选项说明：</p>
<ul>
<li>-new：生成新证书签署请求</li>
<li>-x509：生成自签格式证书，<strong>专用于创建私有CA时</strong><ul>
<li>-key：生成请求时用到的<strong>私钥文件</strong></li>
<li>-days n：证书的有效期限</li>
<li>-out /PATH/TO/SOMECERTFILE: 证书的保存路径</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>以上两步可以合成一步：</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>   `openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 3650 -out ca.crt`</code></pre>
<ul>
<li>为CA提供所需的目录及文件<ul>
<li><code>mkdir -pv /etc/pkl/CA/&#123;certs,crl,newcerts&#125;</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>颁发证书</p>
<ul>
<li><p>在需要使用证书的主机生成证书请求</p>
</li>
<li><p>给web服务器生成私钥</p>
<pre><code>`(umask 077; openssl genrsa –out /data/test.key 2048)`</code></pre>
<p><strong>注意：在CentOS8.1中，密钥的长度不能指定1024，否则会报错！！！</strong></p>
</li>
<li><p>生成证书申请文件</p>
<pre><code>`openssl req -new -key /data/test.key -out /data/test.csr -days 365`</code></pre>
</li>
<li><p>以上两步可合成一步<br>   <code>openssl req - newkey rsa:4096 -nodes sha256 -keyout client.key -out client.csr</code><br>   将证书请求文件传输给CA</p>
</li>
<li><p>CA签署证书</p>
<pre><code>`openssl ca -in /tmp/test.csr –out /etc/pki/CA/certs/test.crt -days 365`</code></pre>
<p>  或者使用以下命令</p>
<p><code>openssl x509 -req -days 3650 -in client.csr -CA ca.crt -CAkey ca.key - CAcreateserial out client.crt</code></p>
<ul>
<li>注意：默认要求国家，省，公司名称三项必须和CA一致</li>
</ul>
</li>
<li><p>将证书颁发给请求者</p>
</li>
<li><p>查看证书中的信息：</p>
<pre><code>`openssl x509 -in /PATH/FROM/CERT_FILE -noout -text|issuer|subject|serial|dates`
`openssl ca -status SERIAL`  查看指定编号的证书状态</code></pre>
</li>
</ul>
<ol start="4">
<li><p>吊销证书</p>
<ul>
<li><p>在客户端获取要吊销的证书的serial<br><code>openssl x509 -in /PATH/FROM/CERT_FILE -noout -serial -subject</code></p>
</li>
<li><p>在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，<br>吊销证书：<br><code>openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem</code></p>
<p>SERIAL要换成证书真正的序列号</p>
</li>
<li><p>指定第一个吊销证书的编号,注意：第一次更新证书吊销列表前，才需要执行<br><code>echo 01 &gt; /etc/pki/CA/crlnumber</code></p>
</li>
<li><p>更新证书吊销列表<br><code>openssl ca -gencrl -out /etc/pki/CA/crl.pem</code></p>
</li>
<li><p>查看crl文件：<br><code>openssl crl -in /etc/pki/CA/crl.pem -noout -text</code></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><ul>
<li><p>ssh: secure shell, protocol, 22/tcp, 安全的远程登录</p>
</li>
<li><p>具体的软件实现：</p>
<ul>
<li>OpenSSH: ssh协议的开源实现，CentOS默认安装 </li>
<li>dropbear：另一个开源实现</li>
</ul>
</li>
<li><p>SSH协议版本</p>
<ul>
<li>v1: 基于CRC-32做MAC，不安全；man-in-middle </li>
<li>v2：双方主机协议选择安全的MAC方式</li>
<li>基于DH算法做密钥交换，基于RSA或DSA实现身份认证</li>
</ul>
</li>
</ul>
<h2 id="Openssh软件组成"><a href="#Openssh软件组成" class="headerlink" title="Openssh软件组成"></a>Openssh软件组成</h2><ul>
<li><p>OpenSSH介绍</p>
<p>相关包：</p>
<ul>
<li>openssh </li>
<li>openssh-clients</li>
<li>openssh-server</li>
</ul>
</li>
<li><p>工具：</p>
<ul>
<li>基于C/S结构</li>
<li>Linux Client: ssh, scp, sftp，slogin</li>
<li>Windows Client：xshell, putty, securecrt, sshsecureshellclient</li>
<li>Server: sshd</li>
</ul>
</li>
</ul>
<h2 id="公钥交换"><a href="#公钥交换" class="headerlink" title="公钥交换"></a>公钥交换</h2><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507091133009.png" alt="image-20200507091133009"></p>
<ol>
<li>客户端发起链接请求</li>
<li>服务端返回自己的公钥，以及一个会话ID（这一步客户端得到服务端公钥）</li>
<li>客户端生成密钥对</li>
<li>客户端用自己的公钥异或会话ID，计算出一个值Res，并用服务端的公钥加密</li>
<li>客户端发送加密后的值到服务端，服务端用私钥解密,得到Res</li>
<li>服务端用解密后的值Res异或会话ID，计算出客户端的公钥（这一步服务端得到客户端公钥）</li>
<li>最终：双方各自持有三个秘钥，分别为自己的一对公、私钥，以及对方的公钥，之后的所有通讯都会被加密</li>
</ol>
<h2 id="ssh加密通讯"><a href="#ssh加密通讯" class="headerlink" title="ssh加密通讯"></a>ssh加密通讯</h2><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507091336347.png" alt="image-20200507091336347"></p>
<h2 id="ssh客户端"><a href="#ssh客户端" class="headerlink" title="ssh客户端"></a>ssh客户端</h2><ul>
<li><p>ssh配置文件：/etc/ssh/ssh_config</p>
</li>
<li><p>格式：</p>
<p><code>ssh [user@]host [COMMAND]</code></p>
<p><code>ssh [-l user] host [COMMAND]</code></p>
</li>
<li><p>常见选项</p>
<ul>
<li>-p：远程服务器监听的端口</li>
<li>-b：指定连接的源IP</li>
<li>-v：调试模式</li>
<li>-C：压缩方式</li>
<li>-X：支持x11转发</li>
<li>-t：强制伪tty分配<br><code>ssh -t remoteserver1 ssh -t remoteserver2 ssh remoteserver3</code></li>
</ul>
</li>
<li><p>允许实现对远程系统经验证地加密安全访问</p>
</li>
<li><p>当用户远程连接ssh服务器时，会复制ssh服务器/etc/ssh/ssh_host*key.pub（CentOS7默认是ssh_host_ecdsa_key.pub）文件中的公钥到客户机的~./ssh/know_hosts中。下次连接时，会自动匹配相应私钥，不能匹配，将拒绝连接</p>
</li>
</ul>
<h2 id="ssh服务登录验证"><a href="#ssh服务登录验证" class="headerlink" title="ssh服务登录验证"></a>ssh服务登录验证</h2><ul>
<li>ssh服务登录的验证方式<ul>
<li>用户/口令</li>
<li>基于密钥</li>
</ul>
</li>
</ul>
<h3 id="基于用户-口令"><a href="#基于用户-口令" class="headerlink" title="基于用户/口令"></a>基于用户/口令</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507091835522.png" alt="image-20200507091835522"></p>
<ol>
<li><p>客户端发起ssh请求，服务器会把自己的公钥发送给用户</p>
</li>
<li><p>用户会根据服务器发来的公钥对密码进行加密</p>
</li>
<li><p>加密后的信息回传给服务器，服务器用自己的私钥解密，如果密码正确，则用户登录成功</p>
</li>
</ol>
<h3 id="基于密钥"><a href="#基于密钥" class="headerlink" title="基于密钥"></a>基于密钥</h3><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200507091958071.png" alt="image-20200507091958071"></p>
<ul>
<li><p>基于密钥的登录方式</p>
<ol>
<li>首先在客户端生成一对密钥（ssh-keygen）</li>
<li>并将客户端的公钥ssh-copy-id 拷贝到服务端</li>
<li>客户端再次发送一个连接请求，包括ip、用户名</li>
<li>服务端得到客户端的请求后，会到authorized_keys中查找，如果有响应的IP和用户，就会随机生成一个字符串，例如：abcdefg</li>
<li>服务端将使用客户端拷贝过来的公钥进行加密，然后发送给客户端</li>
<li>得到服务端发来的消息后，客户端会使用私钥进行解密，然后将解密后的字符串用服务端的公钥发送给服务端</li>
<li>服务端接受到客户端发来的字符串后，用自己的私钥跟之前的字符串进行对比，如果一 致，就允许免密码登录</li>
</ol>
</li>
<li><p>基于密钥的认证</p>
<ol>
<li><p>在客户端生成密钥对</p>
<p><code>ssh-keygen -t rsa [-P &#39;&#39;] [-f “~/.ssh/id_rsa&quot;]</code></p>
</li>
<li><p>把公钥文件传输至远程服务器对应用户的家目录 </p>
<p><code>ssh-copy-id [-i [identity_file]] [user@]host</code></p>
</li>
<li><p>测试</p>
</li>
<li><p>在SecureCRT或Xshell实现基于key验证</p>
<p>在SecureCRT工具—&gt;创建公钥—&gt;生成Identity.pub文件</p>
<p>转化为openssh兼容格式（适合SecureCRT，Xshell不需要转化格式），并复制到 需登录主机上相应文件authorized_keys中,注意权限必须为600，在需登录的ssh 主机上执行：</p>
<p><code>ssh-keygen -i -f Identity.pub &gt;&gt; .ssh/authorized_keys</code></p>
</li>
<li><p>重设私钥口令：</p>
<p><code>ssh-keygen –p</code></p>
</li>
<li><p>验证代理（authentication agent）保密解密后的密钥 这样口令就只需要输入一次。在GNOME中，代理被自动提供给root用户,否则运行</p>
<p><code>ssh-agent bash</code></p>
</li>
<li><p>钥匙通过命令添加给代理 ssh-add</p>
</li>
</ol>
</li>
</ul>
<h2 id="有关ssh的命令"><a href="#有关ssh的命令" class="headerlink" title="有关ssh的命令"></a>有关ssh的命令</h2><ul>
<li><p>scp命令：</p>
<p><code>scp [options] SRC... DEST/</code></p>
<p>两种方式：</p>
<ul>
<li><code>scp [options] [user@]host:/sourcefile/destpath</code> </li>
<li><code>scp [options] /sourcefile [user@]host:/destpath</code></li>
</ul>
<p>常用选项：</p>
<ul>
<li><p>-C 压缩数据流</p>
</li>
<li><p>-r 递归复制</p>
</li>
<li><p>-p 保持原文件的属性信息</p>
</li>
<li><p>-q 静默模式</p>
</li>
<li><p>-P PORT 指明remote host的监听的端口</p>
</li>
</ul>
</li>
<li><p>rsync</p>
<p>参考</p>
</li>
<li><p>sftp</p>
<ul>
<li><p>交互式文件传输工具</p>
</li>
<li><p>用法和传统的ftp工具相似</p>
</li>
<li><p>利用ssh服务实现安全的文件上传和下载</p>
</li>
<li><p>使用ls cd mkdir rmdir pwd get put等指令，可用？或help获取帮助信息 </p>
<p><code>sftp [user@]host</code></p>
<p><code>sftp&gt; help</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="ssh端口转发"><a href="#ssh端口转发" class="headerlink" title="ssh端口转发"></a>ssh端口转发</h2><ul>
<li><p>SSH端口转发</p>
<p>SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是， SSH 还能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了 相应的加密及解密服务。这一过程也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet， SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信 息的明文传输。而与此同时，如果工作环境中的防火墙限制了一些网络端口的使 用，但是允许 SSH 的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯</p>
</li>
<li><p>SSH 端口转发能够提供两大功能：</p>
<ul>
<li>加密 SSH Client 端至 SSH Server 端之间的通讯数据</li>
<li>突破防火墙的限制完成一些之前无法建立的 TCP 连接</li>
</ul>
</li>
<li><p>本地转发：</p>
<p>-L localport:remotehost:remotehostport sshserver</p>
</li>
<li><p>选项：</p>
<ul>
<li>-f 后台启用</li>
<li>-N 不打开远程shell，处于等待状态</li>
<li>-g 启用网关功能</li>
</ul>
<p>示例<br><code>ssh –L 9527:telnetsrv:23 -Nfg sshsrv</code><br><code>telnet 127.0.0.1 9527</code></p>
<ul>
<li>当访问本机的9527的端口时，被加密后转发到sshsrv的ssh服务，再解密被转发到telnetsrv:23</li>
<li>data ⬅➡ localhost:9527  ⬅➡localhost:XXXXX  ⬅➡sshsrv:22  ⬅➡<br>sshsrv:YYYYY  ⬅➡telnetsrv:23</li>
</ul>
</li>
<li><p>远程转发:</p>
<p>-R sshserverport:remotehost:remotehostport sshserver<br>示例：<br>ssh –R 9527:telnetsrv:23 –Nf  sshsrv</p>
<ul>
<li>让sshsrv侦听9527端口的访问，如有访问，就加密后通过ssh服务转发请求到本机ssh客户端，再由本机解密后转发到telnetsrv:23</li>
<li>Data ⬅➡ sshsrv:9527 ⬅➡ sshsrv:22 ⬅➡ localhost:XXXXX ⬅➡<br>localhost:YYYYY⬅➡ telnetsrv:23</li>
</ul>
</li>
<li><p>动态端口转发：<br>当用firefox访问internet时，本机的1080端口做为代理服务器，firefox的访问请求被转发到sshserver上，由sshserver替之访问internet</p>
<p><code>ssh -D 1080 root@sshserver -fNg</code></p>
<p>在本机firefox设置代理socket proxy:127.0.0.1:1080</p>
<p><code>curl --socks5 127.0.0.1:1080 http://www.google.com</code></p>
</li>
</ul>
<h2 id="ssh服务端"><a href="#ssh服务端" class="headerlink" title="ssh服务端"></a>ssh服务端</h2><ul>
<li><p>服务器端：sshd, 配置文件: /etc/ssh/sshd_config</p>
</li>
<li><p>常用参数：</p>
<ul>
<li>Port</li>
<li>ListenAddress ip</li>
<li>LoginGraceTime 2m</li>
<li>PermitRootLogin yes</li>
<li>StrictModes yes  检查.ssh/文件的所有者，权限等</li>
<li>MaxAuthTries 6</li>
<li>MaxSessions 10 同一个连接最大会话</li>
<li>PubkeyAuthentication yes</li>
<li>PermitEmptyPasswords no</li>
<li>PasswordAuthentication yes</li>
<li>PermitEmptyPasswords no</li>
<li>PasswordAuthentication yes</li>
<li>GatewayPorts no</li>
<li>ClientAliveInterval 单位:秒</li>
<li>ClientAliveCountMax 默认3</li>
<li>UseDNS yes </li>
<li>GSSAPIAuthentication yes 提高速度可改为no</li>
<li>MaxStartups 未认证连接最大值，默认值10</li>
<li>Banner /path/file</li>
</ul>
</li>
<li><p>限制可登录用户的办法：</p>
<ul>
<li>AllowUsers user1 user2 user3</li>
<li>DenyUsers</li>
<li>AllowGroups</li>
<li>DenyGroups</li>
<li>DenyGroups</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li><p>禁止使用protocol version 1</p>
</li>
<li><p>限制可登录用户</p>
</li>
<li><p>设定空闲会话超时时长</p>
</li>
<li><p>利用防火墙设置ssh访问策略</p>
</li>
<li><p>仅监听特定的IP地址</p>
</li>
<li><p>基于口令认证时，使用强密码策略</p>
<p>​    <code>tr -dc A-Za-z0-9_ &lt; /dev/urandom | head -c 12| xargs</code></p>
</li>
<li><p>使用基于密钥的认证</p>
</li>
<li><p>禁止使用空密码</p>
</li>
<li><p>禁止root用户直接登录</p>
</li>
<li><p>限制ssh的访问频度和并发在线数</p>
</li>
<li><p>经常分析日志</p>
</li>
</ul>
</li>
</ul>
<h1 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h1><ul>
<li><p>配置文件：/etc/sudoers, /etc/sudoers.d/</p>
</li>
<li><p>时间戳文件：/var/db/sudo</p>
</li>
<li><p>日志文件：/var/log/secure</p>
</li>
<li><p>配置文件支持使用通配符glob</p>
<ul>
<li><p>? 任意单一字符</p>
</li>
<li><p>*匹配任意长度字符</p>
</li>
<li><p>[wxc] 匹配其中一个字符</p>
</li>
<li><p>[!wxc] 除了这三个字符的其它字符</p>
</li>
<li><p>\x 转义</p>
</li>
<li><p>[[alpha]] 字母 示例： /bin/ls [[alpha]]*</p>
</li>
</ul>
</li>
<li><p>配置文件规则有两类</p>
<ol>
<li>别名定义：不是必须的</li>
<li>授权规则：必须的</li>
</ol>
</li>
</ul>
<h2 id="更改身份"><a href="#更改身份" class="headerlink" title="更改身份"></a>更改身份</h2><ul>
<li><p>su 切换身份：su –l username –c ‘command’</p>
</li>
<li><p>sudo</p>
<ul>
<li><p>来自sudo包，man 5 sudoers</p>
</li>
<li><p>sudo能够授权指定用户在指定主机上运行某些命令。如果未授权用户尝试使用 sudo，会提示联系管理员</p>
</li>
<li><p>sudo可以提供日志，记录每个用户使用sudo操作</p>
</li>
<li><p>sudo为系统管理员提供配置文件，允许系统管理员集中地管理用户的使用权 限和使用的主机</p>
</li>
<li><p>sudo使用时间戳文件来完成类似“检票”的系统，默认存活期为5分钟的“入 场券”</p>
</li>
<li><p>通过visudo命令编辑配置文件，具有语法检查功能 visudo -c 检查语法</p>
<p><code>visudo -f /etc/sudoers.d/test</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="sudoers"><a href="#sudoers" class="headerlink" title="sudoers"></a>sudoers</h2><ul>
<li><p>授权规则格式：</p>
<p>用户 登入主机=(代表用户) 命令</p>
<p>user host=(runas) command</p>
</li>
<li><p>示例：</p>
<p>root ALL=(ALL) ALL</p>
</li>
<li><p>格式说明：</p>
<ul>
<li>user: 运行命令者的身份 </li>
<li>host: 通过哪些主机 </li>
<li>runas：以哪个用户的身份 </li>
<li>command: 运行哪些命令</li>
</ul>
</li>
</ul>
<h2 id="sudo别名和示例"><a href="#sudo别名和示例" class="headerlink" title="sudo别名和示例"></a>sudo别名和示例</h2><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><ul>
<li><p>别名有四种类型：User_Alias，Runas_Alias，Host_Alias，Cmnd_Alias</p>
</li>
<li><p>别名格式：[A-Z]([A-Z][0-9]_)*</p>
</li>
<li><p>别名定义：<br>Alias_Type NAME1 = item1,item2,item3 : NAME2 = item4, item5</p>
</li>
<li><p>User和runas: </p>
<ul>
<li>username</li>
<li>#uid</li>
<li>%group_name</li>
<li>%#gid</li>
<li>user_alias|runas_alias</li>
</ul>
</li>
<li><p>host:</p>
<ul>
<li>ip或hostname</li>
<li>network(/netmask)</li>
<li>host_alias</li>
</ul>
</li>
<li><p>command:</p>
<ul>
<li>command name</li>
<li>directory</li>
<li>sudoedit</li>
<li>Cmnd_Alias</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><p>示例1：</p>
<p>Student ALL=(ALL) ALL</p>
<p>%wheel ALL=(ALL) ALL</p>
</li>
<li><p>示例2：</p>
<p>student ALL=(root) /sbin/pidof,/sbin/ifconfig</p>
<p>%wheel ALL=(ALL) NOPASSWD: ALL</p>
</li>
<li><p>示例3：</p>
<p>User_Alias NETADMIN= netuser1,netuser2 </p>
<p>Cmnd_Alias NETCMD = /usr/sbin/ip</p>
<p>NETADMIN ALL=（root） NETCMD</p>
</li>
<li><p>示例4</p>
<p>User_Alias SYSADER=wang,mage,%admins </p>
<p>User_Alias DISKADER=tom</p>
<p>Host_Alias SERS=<a target="_blank" rel="noopener" href="http://www.xxx.com,172.16.0.0/24">www.xxx.com,172.16.0.0/24</a></p>
<p>Runas_Alias OP=root</p>
<p>Cmnd_Alias SYDCMD=/bin/chown,/bin/chmod </p>
<p>Cmnd_Alias DSKCMD=/sbin/parted,/sbin/fdisk </p>
<p>SYSADER SERS= SYDCMD,DSKCMD </p>
<p>DISKADER ALL=(OP) DSKCMD</p>
</li>
<li><p>示例5：</p>
<p>User_Alias ADMINUSER = adminuser1,adminuser2</p>
<p>Cmnd_Alias ADMINCMD = /usr/sbin/useradd，/usr/sbin/usermod,/usr/bin/passwd [a-zA-Z]*, !/usr/bin/passwd root</p>
<p>ADMINUSER ALL=(root) NOPASSWD:ADMINCMD，PASSWD:/usr/sbin/userdel</p>
</li>
<li><p>示例6：</p>
<p>Defaults:wang runas_default=tom </p>
<p>xxx ALL=(tom,jerry) ALL</p>
</li>
<li><p>示例7：</p>
<p>wang 192.168.1.6,192.168.1.8=(root) /usr/sbin/,!/usr/sbin/useradd</p>
</li>
<li><p>示例8：</p>
<p>wang ALL=(ALL) /bin/cat /var/log/messages*</p>
</li>
</ul>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><ul>
<li>ls -l /usr/bin/sudo</li>
<li>sudo –i –u wang 切换身份</li>
<li>sudo [-u user] COMMAND<ul>
<li>-V 显示版本信息等配置信息</li>
<li>-u user 默认为root</li>
<li>-l,ll 列出用户在主机上可用的和被禁止的命令</li>
<li>-v 再延长密码有效期限5分钟,更新时间戳</li>
<li>-k 清除时间戳（1970-01-01），下次需要重新输密码</li>
<li>-K 与-k类似，还要删除时间戳文件</li>
<li>-b 在后台执行指令</li>
<li>-p 改变询问密码的提示符号</li>
<li>示例：-p ”password on %h for user %p:”</li>
</ul>
</li>
</ul>
<h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1><p>安全扩展的Linux</p>
<ul>
<li><p>工作于Linux内核中</p>
</li>
<li><p>DAC：自主访问控制法则 </p>
<ul>
<li>MAC：强制访问控制</li>
</ul>
</li>
<li><p>SELINUX工作级别：</p>
</li>
<li><p>strict： 每个进程都会受到selinux控制</p>
<ul>
<li>argetd： 仅有限的进程受到selinux控制，只监控容易被入侵的进程</li>
</ul>
</li>
<li><p>sandbox: </p>
</li>
<li><p>ubject: 进程</p>
<ul>
<li>object：进程、文件 <ul>
<li>文件这里：根据 open read close 等操作作selinux限制</li>
</ul>
</li>
<li>SELINUX为每个文件提供安全变迁，也为进程提供了安全标签<ul>
<li>user:role:type </li>
<li>user: selinux用户</li>
<li>role：角色</li>
<li>type：类型</li>
</ul>
</li>
</ul>
</li>
<li><p>selinux规则库： </p>
<ul>
<li>规则：哪种域能够访问哪种文件或那个进程等</li>
<li>配置selinux：<ul>
<li>selinux是否开启</li>
<li>给文件重新打标签</li>
<li>设定布尔值特性</li>
</ul>
</li>
</ul>
</li>
<li><p>selinux状态：</p>
<ul>
<li>enforcing： 强制； 每个受限的进程都必须执行selinux策略</li>
<li>permissive： 启用，每个受限的进程违规操作不会禁止，但是会被记录到审计日志中</li>
<li>disabled： 关闭</li>
</ul>
</li>
<li><p>相关命令：</p>
<ul>
<li><p>getenforce    # 获取selinux当前状态</p>
</li>
<li><p>setenforce [0|1]  # 设置当前selinux状态； </p>
<ul>
<li>0：设置为permissive </li>
<li>1: 设置为enforcing </li>
<li>临时设置；重启后会失效</li>
</ul>
</li>
<li><p>配置文件： /etc/selinux/config    永久生效<br>SELINUX={ enforcing|permissive|disabled }    </p>
</li>
<li><p>给文件重新打标签： </p>
<ul>
<li><p>chcon命令： Change the SELinux security context of each FILE to CONTEXT.<br>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: chcon [OPTION]... CONTEXT FILE...</span><br><span class="line">			  or:  chcon [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...</span><br><span class="line">			  or:  chcon [OPTION]... --reference=RFILE FILE...</span><br><span class="line">			Change the SELinux security context of each FILE to CONTEXT.</span><br></pre></td></tr></table></figure>
</li>
<li><p>-R ： 能够递归打标签    </p>
</li>
</ul>
</li>
<li><p>还原文件标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># restorecon --help  </span></span><br><span class="line">usage:  restorecon [-iFnprRv0] [-e excludedir] pathname...</span><br><span class="line">usage:  restorecon [-iFnprRv0] [-e excludedir] -f file</span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔型规则：</p>
<ul>
<li>getsebool # 获取bool规则 -a 参数： 获取所有</li>
<li>setsebool # 设置bool规则 </li>
</ul>
</li>
<li><p>设置布尔型规则：</p>
<ul>
<li><code>setsebool [ -NPV ] boolean value | bool1=val1 bool2=val2...</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><h2 id="防火墙基本概念"><a href="#防火墙基本概念" class="headerlink" title="防火墙基本概念"></a>防火墙基本概念</h2><ul>
<li><p>根据逻辑分类：</p>
<ul>
<li>主机防火墙： 对单个主机进行防护<ul>
<li>window上的防火墙</li>
<li>云上的安全组    </li>
</ul>
</li>
<li>网络防火墙：对网络入口进行防护，防火墙的背后是本地局域网<ul>
<li> 安全厂商设备</li>
<li> 云上的FaaS服务（对VPC网络进行防护）</li>
</ul>
</li>
<li>主机防火墙（个人）和网络防火墙（集体）相辅相成的 </li>
</ul>
</li>
<li><p>根据物理分类</p>
<ul>
<li>物理防火墙： 硬件级别实现部分防火墙功能；性能高，但是成本也高</li>
<li>软件防火墙： 应用软件出力逻辑运行于通用硬件平台上的防火墙；成本低，但是性能低</li>
</ul>
</li>
<li><p>IPtables： 是一个客户端代理软件，用于将用户安全设定执行到对应的“安全框架”中；所以它能够实现的是软件防火墙</p>
</li>
<li><p>“安全框架” - Netfilter 位于在内核中</p>
<ul>
<li><p>Netfilter - 内核空间；是真正去实现软件防火墙功能</p>
</li>
<li><p>Iptables - 用户空间；是一个用户空间的客户端代理软件</p>
</li>
<li><p>在用户空间中使用IPtables工具，将安全策略执行到内核空间中netfilter上从而来实现<br>Linux主机上的防火墙功能</p>
</li>
<li><p>Netfilter是Linux操作系统下的包过滤防火墙的“安全框架”（免费）；所以说IPtables没有守护进程，不是真正的服务，而是内核提供的功能</p>
</li>
<li><p>功能：</p>
<ul>
<li>网络地址转换</li>
<li>数据包内容修改</li>
<li>数据包过滤的防火墙功能(***)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IPtables基础"><a href="#IPtables基础" class="headerlink" title="IPtables基础"></a>IPtables基础</h2><ul>
<li><p>IPtables能够根据它的rule匹配而进对数据包进行处理：accept drop reject </p>
<ul>
<li>不同的处理方式 -&gt; 动作</li>
</ul>
</li>
<li><p>rule存储在内核空间的信息过滤表中，这些规则指定：SIP DIP 传输协议类型（Tcp/Udp）等等</p>
</li>
<li><p>Netfilter 位于在内核空间中，设置了”关卡”： Input Output等等</p>
</li>
<li><p>网卡的驱动 也是位于内核空间中，所以IPtables+Netfilter可以在内核空间中设置“关卡”，<br>当用户去访问应用服务的时候，数据包是通过网卡流经内核空间之后到达用户空间</p>
</li>
<li><p>如果我们的报文需要转发，则不会经过Input和output链（即不会从用户空间绕一圈）；只需要通过prerouting FORWARD postrouting链</p>
<ul>
<li>Input链 和 Output链 ： 作用于数据包于用户空间和内核空间的流入流出</li>
<li>prerouting FORWARD postrouting链： 在内核空间中关于数据包的流入流出及转发</li>
</ul>
</li>
<li><p>常见应用场景：</p>
<ul>
<li>到本地某个进程（服务）的报文： prerouting -&gt; input -&gt; ouput -&gt; postrouting</li>
<li>由本地进行转发的报文： prerouting -&gt; forward -&gt; postrouting </li>
</ul>
</li>
</ul>
<h2 id="IPtables缺点"><a href="#IPtables缺点" class="headerlink" title="IPtables缺点"></a>IPtables缺点</h2><blockquote>
<p>高并发的情况下，不建议开启IPtables，会影响性能。</p>
<p>没有绝对安全的操作系统，虽然防火墙有这些缺点，但还是能阻挡大多数来自于外网的攻击!</p>
</blockquote>
<ol>
<li>防火墙虽然可以过滤互联网的数据包，但却无法过滤内部网络的数据包。因此若有人从内部网络攻击时，防火墙没有作用。</li>
<li>电脑本身的操作系统亦可能因一些系统漏洞，使入侵者可以利用这些漏洞绕过防火墙过滤，从而入侵电脑。</li>
<li>防火墙无法有效阻挡病毒攻击，尤其是隐藏在数据中的病毒。</li>
<li>正常状况下，所有互联网的数据包软件都应经过防火墙的过滤，这将造成网络交通的瓶颈。例如在攻击性数据包出现时，攻击者会不时寄出数据包，让防火墙疲于过滤数据包，而使一些合法数据包软件亦无法正常进出防火墙。</li>
</ol>
<h2 id="链的概念"><a href="#链的概念" class="headerlink" title="链的概念"></a>链的概念</h2><ul>
<li>防火墙的作用在于对经过的报文匹配“规则”，然后执行相对应的动作，如果有多个“规则”组合到一起，那么我们就称之“链”</li>
<li>每经过一条链则需要把所有规则都匹配一遍；如果有符合条件的规则，则执行相应动作即可</li>
<li>简单来说：多个规则组成链，经过链时，链上的所有规则需要匹配一遍，符合规则的条件，执行相应动作</li>
<li>prerouting链：对数据包作路由选择前应用此链中的规则（所有的数据包进来的时侯都先由这个链处理）</li>
<li>input链：进来的数据包应用此规则链中的策略</li>
<li>forward链：转发数据包时应用此规则链中的策略</li>
<li>output链：外出的数据包应用此规则链中的策略</li>
<li>postrouting链： 对数据包作路由选择后应用此链中的规则（所有的数据包出来的时侯都先由这个链处理）</li>
</ul>
<h2 id="表的概念"><a href="#表的概念" class="headerlink" title="表的概念"></a>表的概念</h2><ul>
<li><p>每个链上都有一些规则，但是有许多相似的规则，这些规则可能是：</p>
<ul>
<li>对IP或者端口进行过滤</li>
<li>对报文进行修改</li>
<li>对网络地址进行转化<br>….</li>
</ul>
</li>
<li><p>把这些功能相似的规则的集合称之为“表”； 多张表的规则的集合叫做“链”</p>
</li>
<li><p>IPtables所有规则的定义：都是去定义到不同的表中</p>
</li>
<li><p>IPtables表：</p>
<ul>
<li>raw表：决定是否开启nat上启动的连接追踪机制； iptable_raw模块</li>
<li>mangle表：解析报文，做出修改，并重新封装的功能； iptable_mangle模块</li>
<li>nat表： 网络地址转换； iptable_nat模块</li>
<li>filter表：负责过滤功能（包过滤防火墙使用到的表）；iptables_filter模块</li>
</ul>
</li>
<li><p>表存在优先级：raw -&gt; mangle -&gt; nat -&gt; filter ； 优先级越高的表中规则优先匹配处理</p>
</li>
</ul>
<h2 id="表链关系"><a href="#表链关系" class="headerlink" title="表链关系"></a>表链关系</h2><ul>
<li><p>是不是每类链上的规则都会存在于4张表中？ 肯定不是；每个链只能有某些规则 -&gt; 拥有某些表</p>
</li>
<li><p>总结：每个链中的规则都会存在于哪些表中</p>
<ul>
<li>prerouting链： raw mangle nat </li>
<li>input链： mangle filter nat </li>
<li>forward链： mangle filter </li>
<li>output链：raw mangle nat filter </li>
<li>postrouting链： mangle nat </li>
</ul>
</li>
<li><p>实际操作过程中，往往都是通过表为操作入口，查看表中对应的规则，以及该表上规则所作用的“链”<br>表 —— 链 </p>
<ul>
<li>raw表：prerouting output</li>
<li>mangle表： prerouting input output forward postrouting </li>
<li>nat表： prerouting input output postrouting </li>
<li>filter表： input forward output </li>
</ul>
</li>
<li><p>当一个数据包经过一个“链”的时候，会将当前链上的所有规则进行匹配，而定义的规则都汇聚到表中；匹配时，因此会存在于优先级，所以就拥有了表的优先级</p>
</li>
<li><p>注意：想要主机支持转发功能，需要开启内核中ip_forward参数</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span>&gt;/proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>  <img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200505160351522.png" alt="image-20200505160351522"></p>
<h2 id="规则概念"><a href="#规则概念" class="headerlink" title="规则概念"></a>规则概念</h2><p><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/image-20200505162214040.png" alt="image-20200505162214040"></p>
<ul>
<li><p>匹配条件 + 动作</p>
</li>
<li><p>规则：规则指定的匹配条件来尝试匹配流经的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理，并不再进行匹配，LOG除外。若未匹配到规则，则按默认的规则处理。</p>
</li>
<li><p>匹配条件： </p>
<ul>
<li>基本匹配条件： SIP DIP等等</li>
<li>扩展匹配条件： Sport Dport等等</li>
<li>扩展匹配条件也是Netfilter中的一部门，以模块插件的形式存在，如果想要使用，则需要依赖对应的模块</li>
</ul>
</li>
<li><p>处理动作：在IPtables中称之为“target”</p>
<ul>
<li>常用动作：<ul>
<li>ACCEPT： 允许数据包通过</li>
<li>DROP：直接丢弃数据包，没有任何响应信息</li>
<li>REJECT：拒绝数据包通过，必要的时候会向发送端发送一个响应的拒接消息</li>
<li>SNAT：源地址转换，解决内网用户同一个公网地址上网问题</li>
<li>MASQUERADE： 是SNAT的一种特殊处理动作，适用于动态的，临时会变的公网IP地址</li>
<li>DNAT：目的地址转换，解决外部网络访问内部局域网中的服务</li>
<li>REDIRECT：在本地端口做端口映射,即重定向</li>
<li>LOG：/var/log/message系统日志文件中记录日志信息，然后将数据包传递给下一条匹配条件，不催数据包做任何处理，只是进行记录</li>
</ul>
</li>
</ul>
</li>
<li><p>规则查询： 以filter表进行操作，filter负责过滤功能<br><code>[root@test ~]# iptables -t filter -L</code></p>
<ul>
<li><p>-t： 指定表</p>
</li>
<li><p>-L： 列出表中的规则，默认是所有链的规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -vnL INPUT</span></span><br><span class="line">Chain INPUT (policy ACCEPT 172 packets, 12678 bytes)</span><br><span class="line">pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination  </span><br></pre></td></tr></table></figure>
</li>
<li><p>-v ： 显示详细信息</p>
</li>
<li><p>-n ： 展开数字</p>
</li>
<li><p>–line-numbers: 显示有序序号 </p>
</li>
<li><p>policy : 当前链的默认策略</p>
</li>
<li><p>packets: 当前链默认策略匹配到的包的数量</p>
</li>
<li><p>bytes: 当前链默认策略匹配到的包的大小总和</p>
</li>
<li><p>pkts: 对应匹配到的报文个数</p>
</li>
<li><p>bytes: 对应匹配到的报文大小综合</p>
</li>
<li><p>target: 规则对应的处理动作</p>
</li>
<li><p>prot: 规则对应的传输协议 </p>
</li>
<li><p>opt: 规格对应的选项</p>
</li>
<li><p>in: 数据包由哪个接口流入</p>
</li>
<li><p>out：数据包由哪个接口流出</p>
<ul>
<li>即设置哪块网卡的报文需要匹配当前规则</li>
</ul>
</li>
<li><p>source： 规则对应的SIP</p>
</li>
<li><p>destination： 规则对应的DIP</p>
</li>
</ul>
</li>
<li><p>规则操作 ： 增删改</p>
<p><code>iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</code></p>
<ul>
<li><p>增： <code>iptables -t filter -A INPUT -s x.x.x.x -j &lt;action&gt;</code><br>实例1： <code>[root@test ~]# iptables -t filter -A INPUT -s 172.16.0.1 -j DROP</code>    # 关于源地址为172.16.0.1/16主机数据包报文的流入给drop掉</p>
<ul>
<li><p>-A : 追加</p>
</li>
<li><p>-I ：在链的开头插入   在链名后可加数字代表第几个序列</p>
<p><code>iptables -t filter -I INPUT 2 -p icmp -j ACCEPT</code></p>
</li>
</ul>
</li>
<li><p>-j ：匹配条件中的所对应动作</p>
</li>
<li><p>清除规则：iptables -t &lt;tables..&gt; -F &lt;chains…&gt;</p>
<ul>
<li><p>方法1：根据规则的编号去删除规则</p>
</li>
<li><p>方法2：根据具体的匹配条件去删除规则</p>
</li>
<li><p>-D：删除指定链中的规则</p>
</li>
</ul>
<p><code>iptables -D INPUT 3</code></p>
<ul>
<li>-F：删除操作，清空当前表的所有规则</li>
</ul>
</li>
<li><p>修改规则：<br><code>[root@test ~]# iptables -t filter -R INPUT 1 -s 172.16.10.0/24 -j ACCEPT</code><br><code>[root@test ~]# iptables -t filter -P FORWARD DROP</code>    </p>
<ul>
<li>-R：修改规则</li>
<li>-P：修改链的默认规则的处理动作</li>
</ul>
</li>
<li><p>保存规则：<br><code>iptables-save &gt; /etc/sysconfig/iptables # 是系统启动后可导入的规则</code></p>
</li>
<li><p>导入规则：<br><code>iptables-restore &lt; /etc/sysconfig/iptables</code></p>
</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>不指定表名，默认指filter表</li>
<li>不指定链名，默认指表内的所有链</li>
<li>除非设置链的默认策略，否则必须指定匹配条件</li>
<li>选项、链名、控制类型使用大写字母，其余均为小写字母</li>
</ul>
</li>
</ul>
<h2 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h2><ul>
<li><p>基本条件：</p>
<ul>
<li><p>-s：指定源地址</p>
</li>
<li><p>-d：指定目的地址</p>
</li>
<li><p>-p：指定协议类型</p>
</li>
<li><p>-i / -o ： 指定网卡流入和流出</p>
<ul>
<li>-i : prerouting INPUT FORWARD </li>
<li>-o : output postrouting</li>
</ul>
</li>
<li><p>tcp/udp扩展模块</p>
<ul>
<li>–sport: 指定源端口</li>
<li>–dport：指定目的端口</li>
</ul>
</li>
<li><p>–icmp-type     ICMP类型</p>
<p>示例：我可以ping别人，别人不能ping通我</p>
<p><code>iptables -I INPUT -p icmp --icmp-type 0 -i ACCEPT</code></p>
<p><code>iptables -I INPUT 2 -p icmp --icmp-type 3 -i ACCEPT</code> </p>
</li>
</ul>
</li>
<li><p>扩展条件：-m 需要模块支持</p>
<ul>
<li>tcp/udp扩展模块<ul>
<li>multiport 多端口 （，不连续；- 连续）<ul>
<li>–sport: 指定源端口</li>
<li>–dport：指定目的端口</li>
</ul>
</li>
</ul>
</li>
<li>iprange扩展模块<ul>
<li>–src-range: 指定源地址范围</li>
<li>–dst-range：指定目的地址范围</li>
</ul>
</li>
<li>string扩展模块：指定匹配报文中的字符串<ul>
<li>–algo: 指定匹配算法（bm和kmp）</li>
<li>–string: 指定需要匹配的字符串</li>
</ul>
</li>
<li>time扩展模块：时间段匹配，如果报文在到达时间范围内，则符合匹配条件<ul>
<li>–timestart [起始时间] –tiemstop [结束时间]</li>
<li>–weekdays: 指定星期</li>
<li>–mouthdays: 指定日</li>
<li>–datastart [起始日期] –datastop [结束日期]</li>
</ul>
</li>
<li>connlimit扩展模块：限制每个IP地址同时连接到Server端的连接数量，不需要指定IP地址，默认就是针对每个客户端IP地址<ul>
<li>–connlimit-above : 限制每个客户端IP的并发连接数量；如果高于此数量则执行响应动作</li>
<li>–connlimit-upto  : 限制每个客户端IP的并发连接数量；如果低于次数量则执行响应动作</li>
</ul>
</li>
<li>state<ul>
<li>–state  连接状态</li>
</ul>
</li>
<li>mac<ul>
<li>–mac-source 指定源mac地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h2><blockquote>
<p>当默认链的规则非常多的时候，不方便我们管理，如果INPUT链中放置了几百条规则，我们可以针对不同服务(httpd ftp mysql)；有针对性将规则放置到自定义链中，在其他5个链进行引用即可，此时当我们想要去修改关于某个服务的规则时，只需要去对应的自定义链中修改即可</p>
</blockquote>
<ul>
<li>创建自定义链：</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -N httpd</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -I httpd -s 172.16.0.0/16 -p icmp -j REJECT </span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -I INPUT -j httpd		# 去引用自定义链中的规则</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>-N： 创建自定链</p>
</li>
<li><p>关于自定义链的增删改查同上</p>
</li>
<li><p>删除自定义链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -F httpd		# 1.清除自定义链中的规则	</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -D INPUT 1 	# 2.删除引用自定义链中的相关规则</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># iptables -t filter -X httpd		# 3.通过-X参数删除自定义链</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关于删除自定义链规则：<ol>
<li>自定义链中没有任何默认链的引用,即引用参数refer为0</li>
<li>自定义链中不能有任何规则，即自定义链为空</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><p><strong>1.批量添加防火墙的脚本(参考，自行更改)</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/<span class="built_in">local</span>/bin:/usr/1ocal/ sbin:~/bin</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">support_distro</span></span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>[ -z <span class="string">&quot;`egrep -i &quot;</span>centos<span class="string">&quot; /etc/issue`&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span><span class="string">&quot; Sorry,iptables script only support centos system now. &quot;</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">support_distro</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=======================iptables configure=======================&quot;</span></span><br><span class="line"><span class="comment"># Only support CentOs system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取SSH端口</span></span><br><span class="line"><span class="keyword">if</span> grep <span class="string">&quot;^Port&quot;</span> /etc/ssh/sshd_config&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">	sshdport=`grep <span class="string">&quot;^Port&quot;</span> /etc/ssh/sshd config|sed <span class="string">&quot;s/Port\s//g&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	sshdport=22</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取DNS服务器IP</span></span><br><span class="line"><span class="keyword">if</span> [ -s /etc/resolv.conf ];<span class="keyword">then</span></span><br><span class="line">	nameserver1=`cat /etc/reso1v.conf|grep nameserver | awk <span class="string">&#x27;NR==1&#123;print $2 &#125;&#x27;</span>`</span><br><span class="line">	nameserver1=`cat /etc/reso1v.conf|grep nameserver | awk <span class="string">&#x27;NR==2&#123;print $2 &#125;&#x27;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">IPT=<span class="string">&quot;/sbin/iptables&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除已有规则</span></span><br><span class="line"><span class="variable">$IPT</span> --delete-chain</span><br><span class="line"><span class="variable">$IPT</span> --flush</span><br><span class="line"></span><br><span class="line"><span class="comment">#禁止进,允许出,允许回环网卡</span></span><br><span class="line"><span class="variable">$IPT</span> -P INPUT DROP</span><br><span class="line"><span class="variable">$IPT</span> -P FORWARD DROP</span><br><span class="line"><span class="variable">$IPT</span> -P OUTPUT ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许已建立的或相关连接的通行</span></span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -m state --state RELATED, ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A OUTPUT -m state --state RELATED, ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#限制80端口单个IP的最大连接数为10</span></span><br><span class="line"><span class="variable">$IPT</span> -I INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许80 (HTTP) /873 (RSYNC) /443 (HTTPS) /20,21 (FTP) /25 (SMTP)端口的连接</span></span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT </span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -p tcp -m tcp --dport 873 -j ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -p tcp -m tcp --dport 443 - j ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -P tcp -m tcp --dport 21 -j ACCEPT </span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -P tcp -m tcp --dport 25 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许SSH端口的连接,脚本自动侦测目前的SSH端口，否则默认为22端口</span></span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -P tcp -m tcp --dport <span class="variable">$sshdport</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许ping</span></span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line"><span class="variable">$IPT</span> -A INPUT -P icmp -m icmp --icmp-type 11 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许DNS</span></span><br><span class="line">[ ! -z <span class="string">&quot;<span class="variable">$nameserver1</span>&quot;</span> ] &amp;&amp; <span class="variable">$IPT</span> -A OUTPUT -p udp -m udp -d <span class="variable">$nameserver1</span> --dport 53 -j ACCEPT</span><br><span class="line">[ ! -z <span class="string">&quot;<span class="variable">$nameserver2</span>&quot;</span> ] &amp;&amp; <span class="variable">$IPT</span> -A OUTPUT -p udp -m udp -d <span class="variable">$nameserver2</span> --dport 53 - j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存规则并重启IPTABLES</span></span><br><span class="line">iptables save</span><br><span class="line">systemctl restart iptables</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;==================iptables configure completed==================&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2.网络地址转换</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="comment">#重启后失效</span></span><br></pre></td></tr></table></figure>

<p>SNAT:将内网地址转化为公网地址</p>
<p>一个数据包在经过路由之后（或者说在通过防火墙的过滤之后)才被知道他的源IP是谁，在路由之前只能看到目标IP，如果我看不到你的源IP，那怎么匹配想过滤的数据包并进行源地址转换?我防火墙根本就不能确定你是否是符合匹配条件的IP，所以只能使用POSTROUTING</p>
<p><code>iptables -t nat-A POSTROUTING -s 192.168.123.0/24 -j SNAT --to-source 10.0.0.1</code></p>
<p>DNAT:将公网地址转化为内网地址</p>
<p>如果我不在路由之前就把目标地址转换完成，很显然当数据包到达入口IP之后，他的目的已经达到了，因为他本来的目标IP就是防火墙的对外公网IP，那么数据包还会往里面走吗?显然不可能了，所以只能使用PREROUTING</p>
<p><code>iptables -t nat -A PREROUTING -d 10.0.0.1 -j DNAT --to-destination 192.168.123.0</code></p>
<h1 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h1><ul>
<li><p>动态防火墙后台服务程序：提供一个动态管理的防火墙，用以支持网络“Zone”，来分配对一个<br>网络链接和界面一定程序的信息，它具备对IPv4和Ipv6防火墙设置的支持</p>
</li>
<li><p>它支持以太网桥，并有分离运行时间和永久配置选项，可以通过服务程序直接增加规则</p>
</li>
<li><p>图形化配置工具：firewall-config </p>
</li>
<li><p>命令行配置工具：firewall-cmd</p>
</li>
<li><p>用于配置firewalld服务永久性或者非永久性运行时间的改变，它依次用IPtables工具与执行<br>数据包筛选的内核中Netfilter通信</p>
</li>
</ul>
<h2 id="Firewalld和IPtables的关系"><a href="#Firewalld和IPtables的关系" class="headerlink" title="Firewalld和IPtables的关系"></a>Firewalld和IPtables的关系</h2><ol>
<li>firewalld和IPtables本身都不具备防火墙功能 </li>
<li>他们都是在用户空间将执行规则放到内核空间的“安全框架”- Netfilter中去实现</li>
</ol>
<h2 id="Firewalld和IPtables的区别"><a href="#Firewalld和IPtables的区别" class="headerlink" title="Firewalld和IPtables的区别"></a>Firewalld和IPtables的区别</h2><ol>
<li>iptables 在 /etc/sysconfig/iptables-config中存放IPtables规则设置；Firewalld 在<br>/usr/lib/firewalld/* 中进行系统配置和/etc/firewalld/* 中关于服务xml文件格式的配置</li>
<li>在使用IPtables的时候，每去操作一条规则立即生效</li>
<li>Firewalld不会创建任何新的规则，仅仅运行规则中的不同之处，因此Firewalld可以在运行时间内改变配置而不丢失现有的连接</li>
</ol>
<h2 id="Zone区域"><a href="#Zone区域" class="headerlink" title="Zone区域"></a>Zone区域</h2><p>不同区域对于网络连接的设置规范不同</p>
<ul>
<li>trusted 信任区域，接受所有网络连接</li>
<li>home 家庭区域</li>
<li>internal 内部区域</li>
<li>worker 工作区域</li>
<li>public 公共区域</li>
<li>extenal 外部区域</li>
<li>dmz 非军事区域</li>
<li>block 限制区域</li>
<li>drop 丢弃区域</li>
</ul>
<h2 id="管理防火墙"><a href="#管理防火墙" class="headerlink" title="管理防火墙"></a>管理防火墙</h2><p>每个zone中都有一套规则集，对于接收到的请求具体使用哪个zone，Firewalld通过三种方式来判断</p>
<ol>
<li>source 源地址优先级最高</li>
<li>Interface 接收请求的网卡</li>
<li>firewall.config 中配置的默认zone </li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# cat /etc/firewalld/firewalld.conf | grep Zone</span><br><span class="line">DefaultZone=public</span><br></pre></td></tr></table></figure>

<ul>
<li>查看默认zone： <code>[root@test ~]# firewall-cmd --get-default-zone</code></li>
<li>设置默认zone：   <code>--set-default-zone=&lt;zone&gt;</code></li>
<li>查看当前firewalld状态： <code>[root@test ~]# firewall-cmd --state</code></li>
<li>查看当前活动的zone：<code>[root@test ~]# firewall-cmd --get-active-zones</code></li>
<li>列出所有可用zone： <code>[root@test ~]# firewall-cmd --list-all-zones</code></li>
<li>列出所有区域设置：<code>--list-all</code></li>
<li>列出所有预定服务：<code>--get-services    # 所有已经设定好的可直接使用的服务规则</code></li>
<li>将某个网络地址放置/移除某个zone<br><code>--add-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</code><br><code>--remove-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;</code></li>
</ul>
<h2 id="管理操作"><a href="#管理操作" class="headerlink" title="管理操作"></a>管理操作</h2><ul>
<li>添加、删除、改变网络接口到制定域中（域中会有一条规则）<ul>
<li><code>--list-interfaces</code></li>
<li><code>--add-interface=&lt;interface&gt;</code></li>
<li><code>--change-interface=&lt;interface&gt;</code></li>
<li><code>--remove-interface=&lt;interface&gt;</code></li>
<li><code>--query-interface=&lt;interface&gt;</code></li>
</ul>
</li>
<li>添加、删除、列出服务<ul>
<li><code>--get-services</code></li>
<li><code>--delete-service=&lt;service&gt;</code></li>
<li><code>--add-service=&lt;service&gt;</code></li>
<li><code>--list-services</code></li>
<li><code>--remove-service=&lt;service&gt;</code></li>
<li><code>--query-service=&lt;service&gt;</code></li>
</ul>
</li>
<li>列出、添加、删除端口<ul>
<li><code>--list-ports         List ports added for a zone [P] [Z]</code></li>
<li><code>--add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</code></li>
<li><code>--remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</code></li>
<li><code>--query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;</code></li>
</ul>
</li>
<li>永久生效： <code> --permanent</code></li>
<li>重载防火墙： <code>--reload </code></li>
</ul>
<h2 id="实验操作-1"><a href="#实验操作-1" class="headerlink" title="实验操作"></a>实验操作</h2><p>部署http服务，并在防火墙开启的情况能够正常访问：</p>
<p>1.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# firewall-cmd --add-service=http</span><br><span class="line">/usr/lib/firewalld/services</span><br><span class="line">[root@test services]# cat http.xml </span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;service&gt;</span><br><span class="line">	&lt;short&gt;WWW (HTTP)&lt;/short&gt;</span><br><span class="line">	&lt;description&gt;HTTP is the protocol used to serve Web pages. If you plan to make your Web server publicly available, enable this option. This option is not required for viewing pages locally or developing Web pages.&lt;/description&gt;</span><br><span class="line">	&lt;port protocol=&quot;tcp&quot; port=&quot;80&quot;/&gt;	# 每个可添加的服务都有对应的xml文件</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个服务的xml文件当中都定义了规则（协议+端口）, 所以当我们去添加服务到当前zone中，也就意味只 对xml当中的设定的规则生效(允许放行)</li>
</ul>
<ol start="2">
<li><p><code>[root@test services]# firewall-cmd --add-port=80/tcp </code></p>
<p>总结来说：去添加服务的方式最终还是涉及到添加端口的方式（要看对应服务的xml文件如何定义）</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:kinmfer@foxmail.com">Kinmfer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kinmfer.github.io/2020/05/05/Linux%E5%9F%BA%E7%A1%80-14-%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/">https://kinmfer.github.io/2020/05/05/Linux基础-14-加密和安全/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Kinmfer.github.io" target="_blank">Kinmfer's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F/">系统</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/05/07/Linux%E5%9F%BA%E7%A1%80-15-Shell%E8%84%9A%E6%9C%AC/"><img class="prev-cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux基础-15-Shell脚本</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/05/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Ansible-03-Role/"><img class="next-cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/2d7bb9d477bdbeb14d417d84e5a818d9.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ansible-03-Role</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/05/02/Linux基础-03-IO重定向和管道/" title="Linux基础-03-IO重定向和管道"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-02</div><div class="title">Linux基础-03-IO重定向和管道</div></div></a></div><div><a href="/2020/05/03/Linux基础-04-用户组和权限管理/" title="Linux基础-04-用户组和权限管理"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-03</div><div class="title">Linux基础-04-用户组和权限管理</div></div></a></div><div><a href="/2020/05/03/Linux基础-06-vim/" title="Linux基础-06-vim"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-03</div><div class="title">Linux基础-06-vim</div></div></a></div><div><a href="/2020/05/03/Linux基础-07-文本处理和正则表达式/" title="Linux基础-07-文本处理和正则表达式"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-03</div><div class="title">Linux基础-07-文本处理和正则表达式</div></div></a></div><div><a href="/2020/05/04/Linux基础-13-CentOS7系统启动流程和Systemd/" title="Linux基础-13-CentOS7系统启动流程和Systemd"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-04</div><div class="title">Linux基础-13-CentOS7系统启动流程和Systemd</div></div></a></div><div><a href="/2020/05/03/Linux基础-05-文件管理/" title="Linux基础-05-文件管理"><img class="cover" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-03</div><div class="title">Linux基础-05-文件管理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81MTkzMi8yODQxMw=="></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Kinmfer</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kinmfer"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kinmfer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:kinmfer@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">安全机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">安全算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">非对称加密算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSA%E5%92%8CDSA"><span class="toc-number">1.3.3.</span> <span class="toc-text">RSA和DSA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97"><span class="toc-number">1.3.4.</span> <span class="toc-text">单向散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">1.3.5.</span> <span class="toc-text">数字签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%9ARPM"><span class="toc-number">1.3.6.</span> <span class="toc-text">应用程序：RPM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.3.7.</span> <span class="toc-text">密钥交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpg%E5%8A%A0%E5%AF%86"><span class="toc-number">1.3.8.</span> <span class="toc-text">gpg加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">公钥加密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-number">1.3.9.</span> <span class="toc-text">中间人攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CA%E5%92%8C%E8%AF%81%E4%B9%A6"><span class="toc-number">1.4.</span> <span class="toc-text">CA和证书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E8%8E%B7%E5%8F%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">证书获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.</span> <span class="toc-text">安全协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS"><span class="toc-number">1.5.1.</span> <span class="toc-text">SSL&#x2F;TLS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">HTTPS结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">HTTPS工作过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenSSL"><span class="toc-number">1.6.</span> <span class="toc-text">OpenSSL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#openssl%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">openssl命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CA%E5%92%8C%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.2.</span> <span class="toc-text">CA和申请证书</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSH"><span class="toc-number">2.</span> <span class="toc-text">SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Openssh%E8%BD%AF%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">2.1.</span> <span class="toc-text">Openssh软件组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">公钥交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E5%8A%A0%E5%AF%86%E9%80%9A%E8%AE%AF"><span class="toc-number">2.3.</span> <span class="toc-text">ssh加密通讯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.</span> <span class="toc-text">ssh客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81"><span class="toc-number">2.5.</span> <span class="toc-text">ssh服务登录验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7-%E5%8F%A3%E4%BB%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text">基于用户&#x2F;口令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E9%92%A5"><span class="toc-number">2.5.2.</span> <span class="toc-text">基于密钥</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%85%B3ssh%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">2.6.</span> <span class="toc-text">有关ssh的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">2.7.</span> <span class="toc-text">ssh端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ssh%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">2.8.</span> <span class="toc-text">ssh服务端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sudo"><span class="toc-number">3.</span> <span class="toc-text">sudo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E8%BA%AB%E4%BB%BD"><span class="toc-number">3.1.</span> <span class="toc-text">更改身份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sudoers"><span class="toc-number">3.2.</span> <span class="toc-text">sudoers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sudo%E5%88%AB%E5%90%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">sudo别名和示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E5%90%8D"><span class="toc-number">3.3.1.</span> <span class="toc-text">别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sudo%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">sudo命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SELinux"><span class="toc-number">4.</span> <span class="toc-text">SELinux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iptables"><span class="toc-number">5.</span> <span class="toc-text">Iptables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">防火墙基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPtables%E5%9F%BA%E7%A1%80"><span class="toc-number">5.2.</span> <span class="toc-text">IPtables基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPtables%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">IPtables缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.</span> <span class="toc-text">链的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.</span> <span class="toc-text">表的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%93%BE%E5%85%B3%E7%B3%BB"><span class="toc-number">5.6.</span> <span class="toc-text">表链关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E6%A6%82%E5%BF%B5"><span class="toc-number">5.7.</span> <span class="toc-text">规则概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.8.</span> <span class="toc-text">匹配条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE"><span class="toc-number">5.9.</span> <span class="toc-text">自定义链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">5.10.</span> <span class="toc-text">实验操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Firewalld"><span class="toc-number">6.</span> <span class="toc-text">Firewalld</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Firewalld%E5%92%8CIPtables%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">Firewalld和IPtables的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Firewalld%E5%92%8CIPtables%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">Firewalld和IPtables的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zone%E5%8C%BA%E5%9F%9F"><span class="toc-number">6.3.</span> <span class="toc-text">Zone区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">6.4.</span> <span class="toc-text">管理防火墙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.</span> <span class="toc-text">管理操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C-1"><span class="toc-number">6.6.</span> <span class="toc-text">实验操作</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-14-MongoDB/" title="综合架构-DBA-14-MongoDB"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/mongodb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合架构-DBA-14-MongoDB"/></a><div class="content"><a class="title" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-14-MongoDB/" title="综合架构-DBA-14-MongoDB">综合架构-DBA-14-MongoDB</a><time datetime="2020-09-28T06:45:34.000Z" title="发表于 2020-09-28 14:45:34">2020-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-13-Redis/" title="综合架构-DBA-13-Redis"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/redis.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合架构-DBA-13-Redis"/></a><div class="content"><a class="title" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-13-Redis/" title="综合架构-DBA-13-Redis">综合架构-DBA-13-Redis</a><time datetime="2020-09-28T06:45:04.000Z" title="发表于 2020-09-28 14:45:04">2020-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-12-Mycat/" title="综合架构-DBA-12-Mycat"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合架构-DBA-12-Mycat"/></a><div class="content"><a class="title" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-12-Mycat/" title="综合架构-DBA-12-Mycat">综合架构-DBA-12-Mycat</a><time datetime="2020-09-28T06:44:34.000Z" title="发表于 2020-09-28 14:44:34">2020-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-11-Atlas/" title="综合架构-DBA-11-Atlas"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合架构-DBA-11-Atlas"/></a><div class="content"><a class="title" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-11-Atlas/" title="综合架构-DBA-11-Atlas">综合架构-DBA-11-Atlas</a><time datetime="2020-09-28T06:43:19.000Z" title="发表于 2020-09-28 14:43:19">2020-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-10-MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF/" title="综合架构-DBA-10-MHA高可用技术"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/mysql.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合架构-DBA-10-MHA高可用技术"/></a><div class="content"><a class="title" href="/2020/09/28/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-DBA-10-MHA%E9%AB%98%E5%8F%AF%E7%94%A8%E6%8A%80%E6%9C%AF/" title="综合架构-DBA-10-MHA高可用技术">综合架构-DBA-10-MHA高可用技术</a><time datetime="2020-09-28T06:42:46.000Z" title="发表于 2020-09-28 14:42:46">2020-09-28</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Kinmfer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kinmfer.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="//code.tidio.co/mzqu2o1lbhle9bvhab8bexgtiyxgkheb.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script></div></body></html>