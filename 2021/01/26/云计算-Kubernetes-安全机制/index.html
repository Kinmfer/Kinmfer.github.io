<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Kubernetes-安全机制 | Kinmfer's Blogs</title><meta name="keywords" content="k8s,安全机制,双向TLS,TLS Bootstrapping"><meta name="author" content="Kinmfer,kinmfer@foxmail.com"><meta name="copyright" content="Kinmfer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kubernetes平台由6个组件组成：apiserver、scheduler、controller-manager、kubelet、kube-proxy、etcd，其中etcd是Kubernetes数据库，在生产环境中一般不允许直接访问。平台通过apiserver组件对外提供HTTPS协议服务接口，其它scheduler、controller-manager、kubelet、kube-proxy">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes-安全机制">
<meta property="og:url" content="https://kinmfer.github.io/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Kinmfer&#39;s Blogs">
<meta property="og:description" content="Kubernetes平台由6个组件组成：apiserver、scheduler、controller-manager、kubelet、kube-proxy、etcd，其中etcd是Kubernetes数据库，在生产环境中一般不允许直接访问。平台通过apiserver组件对外提供HTTPS协议服务接口，其它scheduler、controller-manager、kubelet、kube-proxy">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg">
<meta property="article:published_time" content="2021-01-26T02:38:31.000Z">
<meta property="article:modified_time" content="2021-03-03T07:28:31.825Z">
<meta property="article:author" content="Kinmfer">
<meta property="article:tag" content="k8s">
<meta property="article:tag" content="安全机制">
<meta property="article:tag" content="双向TLS">
<meta property="article:tag" content="TLS Bootstrapping">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kinmfer.github.io/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c46ed77365f502de73543fbf10399875";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C2N62A47W9","apiKey":"0c62f17095ec2a20c19657511a42c0b1","indexName":"Blogs","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章更新于","messageNext":"天前,内容可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Kinmfer","link":"链接: ","source":"来源: Kinmfer's Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-03 15:28:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">102</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kinmfer's Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes-安全机制<a class="post-edit-link" href="https://github.com/Kinmfer/Kinmfer.github.io/_posts/云计算-Kubernetes-安全机制.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-26T02:38:31.000Z" title="发表于 2021-01-26 10:38:31">2021-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-03T07:28:31.825Z" title="更新于 2021-03-03 15:28:31">2021-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>95分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Kubernetes平台由6个组件组成：apiserver、scheduler、controller-manager、kubelet、kube-proxy、etcd，其中etcd是Kubernetes数据库，在生产环境中一般不允许直接访问。平台通过apiserver组件对外提供HTTPS协议服务接口，其它scheduler、controller-manager、kubelet、kube-proxy组件不提供交互接口。运维中对平台的管理操作都需要通过apiserver提供的功能接口完成，因此Kubernetes总体的API安全防护机制是对用户访问操作HTTPS服务接口的控制。</p>
<p>Kubernetes只对以下的API请求属性进行检查:</p>
<ul>
<li>user - username,uid</li>
<li>group - user group </li>
<li>“extra”- 额外信息</li>
<li>API - API资源的对象 </li>
<li>Request path - 请求资源的路径(k8s使用resultful风格接口的API) </li>
<li><a target="_blank" rel="noopener" href="http://node_ipaddr:6443/apis/apps/v1/namespaces/namespaces_name/resource_name/">http://Node_IPaddr:6443/apis/apps/v1/namespaces/namespaces_name/resource_name/</a></li>
<li>HTTP 请求动作 - HTTP verbs get，post，put，和delete用于非资源请求</li>
<li>HTTP 请求动作映射到 API资源操作-  get，list，create，update，patch，watch，proxy，redirect，delete，</li>
<li>和deletecollection用于请求resource</li>
<li>Resource -被访问（仅用于resource 请求）的resource 的ID或名字- *对于使用resource 的请求get，update，</li>
<li>patch，和delete，必须提供resource 名称。</li>
<li>Subresource - 正在访问的subresource （仅用于请求resource ）</li>
<li>Namespace - 正在访问对象的命名空间（仅针对命名空间的请求资源）</li>
<li>API group - 正在访问的API组（仅用于请求资源）。空字符串指定核心API组。</li>
</ul>
<p>用户可通过客户端kubectl命令行工具或其它方式访问Kubernetes的API资源，每个访问API的请求，都要经过三个步骤校验：Authentication、Authorization、Admission Control，总体如下图所示：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/image-20210122083948239.png" alt="image-20210122083948239"></p>
<ul>
<li><p>Authentication（认证），对用户身份进行验证。认证方式现共有8种，可以启用一种或多种认证方式，只要有一种认证方式通过，就不再进行其它方式的认证。通常启用X509 Client Certs和Service Accout Tokens两种认证方式。</p>
</li>
<li><p>Authorization（授权），验证用户是否拥有访问权限。授权方式现共有6种，可以启用一种或多种授权方式，启用的任一种方式依据授权策略明确允许或拒绝请求，则立即返回，不再进行其它方式的授权。通常启用RBAC和Node授权方式。</p>
</li>
<li><p>Admission Control（准入控制），对API资源对象修改、校验。它有一个插件列表，所有请求需要经过这个列表中的每个准入控制插件修改、校验，如果某一个准入控制插件验证失败，就拒绝请求。</p>
</li>
</ul>
<p>用户访问 Kubernetes  API时，apiserver认证授权模块从HTTPS请求中获取用户的身份信息、请求资源路径和业务对象参数。身份信息是用来确认用户的身份是否合法，资源路径是用于判定用户是否拥有访问操作的权限，业务对象参数则在准入控制中接受修改或校验参数设置是否符合业务要求。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/image-20210122084021569.png" alt="image-20210122084021569"></p>
<ul>
<li><p>请求到达后，apiserver从请求的证书、Header中获取用户信息：Name（用户名）、UID（用户唯一标识）、Groups（用户分组）、Extra（用户额外信息）。认证通过后，通过Context将用户信息向下传播。</p>
</li>
<li><p>授权模块从Context、请求的Method及URI提取用户信息、请求资源属性。使用请求资源属性与授权策略匹配或向外部服务验证判断是否准予访问。</p>
</li>
<li><p>准入控制接收到HTTPS请求提交的Body内容、用户信息、资源信息，根据不同准入控制插件的功能对上述信息做修改或校验。</p>
</li>
</ul>
<p>认证即身份验证，认证关注的是谁发送的请求，也就是说用户必须用某种方式证明自己的身份信息。Kubernetes集群有两种类型的用户：普通用户（normal users）、服务账户（service  accounts），普通用户并不被Kubernetes管理和保存；而服务账户由Kubernetes存储在etcd中，并可通过apiserver  API管理。</p>
<p>从身份验证的方法上可分为4种类型：Token、证书、代理、密码。Kubernetes可以同时启用多个认证方式，在这种情况下，每个认证模块都按顺序尝试验证用户身份，直到其中一个成功就认证通过。如果启用匿名访问，没有被认证模块拒绝的请求将被视为匿名用户，并将该请求标记为system:anonymous  用户名和system:unauthenticated组。从1.6版本开始，ABAC和RBAC授权需要对system:anonymous用户或system:unauthenticated组进行明确授权。</p>
<p>kubernetes 支持很多种认证机制，包括：</p>
<ul>
<li>X509 client certs</li>
<li>Static Token File</li>
<li>Bootstrap Tokens</li>
<li>Static Password File</li>
<li>Service Account Tokens</li>
<li>OpenId Connect Tokens</li>
<li>Webhook Token Authentication</li>
<li>Authticating Proxy</li>
<li>Anonymous requests</li>
<li>User impersonation</li>
<li>Client-go credential plugins</li>
</ul>
<p>本文将对 X509 client certs、 Bootstrap Tokens、 Service Account Tokens进行详细分析</p>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="Authenticating-Proxy"><a href="#Authenticating-Proxy" class="headerlink" title="Authenticating Proxy"></a><strong>Authenticating Proxy</strong></h2><p>Authenticating Proxy（认证代理），apiserver只验证代理程序身份，不校验用户身份，验证通过后，apiserver通过指定的Header提取访问的用户信息。</p>
<p>启用此认证方式是通过设置apiserver参数–requestheader-username-headers和–requestheader-client-ca-file。</p>
<ul>
<li><p>–requestheader-username-headers（必需，不区分大小写）。设定Header中的用户标识，第一个包含value的Header将被作为用户名。</p>
</li>
<li><p>–requestheader-client-ca-file（必需）。PEM 编码的CA证书。用来校验代理端客户端证书，防止 Header 欺骗。</p>
</li>
<li><p>–requestheader-allowed-names（可选）。证书名称（CN）列表。如果设置了，则必须提供名称列表中的有效客户端证书。如果为空，则允许使用任何名称客户端证书。</p>
</li>
<li><p>–requestheader-group-headers（ 1.6 以上版本支持，可选，不区分大小写）。建议为 “X-Remote-Group”，设定Header中的用户组标识。指定 Header 中的所有值都将作为用户分组。</p>
</li>
<li><p>–requestheader-extra-headers-prefix （1.6 以上版本支持，可选，不区分大小写）。建议为  “X-Remote-Extra-”，标题前缀可用于查找用户的扩展信息，以任何指定的前缀开头的  Header删除前缀后其余部分将成为用户扩展信息的键值，而 Header值则是扩展的值。</p>
</li>
</ul>
<p><strong>例如下面的配置：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--requestheader-username-headers&#x3D;X-Remote-User</span><br><span class="line">--requestheader-group-headers&#x3D;X-Remote-Group</span><br><span class="line">--requestheader-extra-headers-prefix&#x3D;X-Remote-Extra-</span><br></pre></td></tr></table></figure>
<p><strong>代理请求：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">X-Remote-User: mifpay</span><br><span class="line">X-Remote-Group: admin</span><br><span class="line">X-Remote-Extra-Channel: vpn</span><br><span class="line">X-Remote-Extra-Scopes: openid</span><br><span class="line">X-Remote-Extra-Scopes: profile</span><br></pre></td></tr></table></figure>
<p>提取后将得到以下信息</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/image-20210122084821355.png" alt="image-20210122084821355"></p>
<h2 id="Static-Password-File"><a href="#Static-Password-File" class="headerlink" title="Static Password File"></a><strong>Static Password File</strong></h2><p>Static Password File（静态密码认证），启用此认证方式是通过设置apiserver参数–basic-auth-file=SOMEFILE。密码是无限期使用，更改密码后需要重启apiserver才能生效。</p>
<p>静态密码文件是CSV格式文件，至少包含3列：密码，用户名，用户ID。从Kubernetes 1.6版本开始，第四列（可选）为用户分组，如果有多个用户分组，则该列必须加双引号。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password,name,uid, &quot;group1,group2,group3&quot;</span><br></pre></td></tr></table></figure>
<p>当使用HTTPS客户端连接时，apiserver从HTTPS Header中，如Authorization: Basic BASE64ENCODED，提取出用户名和密码。BASE64ENCODED解码后格式为USER:PASSWORD。</p>
<p>从请求中获取到用户名和密码，与静态密码文件中的用户逐一进行比较，匹配成功则认证通过，否则认证失败。认证通过时从CSV中提取匹配的用户信息用于后续的授权等。</p>
<h2 id="Static-Token-File"><a href="#Static-Token-File" class="headerlink" title="Static Token File"></a>Static Token File</h2><p>Static Token File（静态Token认证），启用此认证方式是通过设置apiserver参数–token-auth-file=SOMEFILE。Token长期有效，更改Token列表后需要重启apiserver才能生效。</p>
<p>SOMEFILE是CSV格式文件，至少包含3列：Token、用户名、用户的UID，其次是可选的分组。每一行表示一个用户。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token,name,uid,&quot;group1,group2,group3&quot;</span><br></pre></td></tr></table></figure>
<p>当使用HTTPS客户端连接时，apiserver从HTTPS Header中提取身份Token。Token必须是一个字符序列，在HTTPS Header格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269</span><br></pre></td></tr></table></figure>
<p>从请求中提取身份Token，与静态Token文件中的用户逐一进行比较，匹配成功则认证通过，否则认证失败。认证通过后将匹配的用户信息用于后续的授权等。</p>
<h2 id="OpenID-Connect-Tokens"><a href="#OpenID-Connect-Tokens" class="headerlink" title="OpenID Connect Tokens"></a><strong>OpenID Connect Tokens</strong></h2><p>OpenID Connect Tokens是OAuth2中的一种，被许多供应商支持，尤其是Azure Active  Directory、Salesforce和 Google。该协议对OAuth2的主要扩展是返回一个额外的访问Token，叫ID  Token。这个ID Token是JSON Web Token（JWT）。</p>
<p>在请求中，使用ID Token作为bearer token（而不是 access_token）。</p>
<p>要启用此插件，需要设置下面两个参数：</p>
<ul>
<li><p>–oidc-issuer-url=<a target="_blank" rel="noopener" href="https://xxx,用于让apiserver获取到oauth2的公有密钥./">https://xxx，用于让apiserver获取到OAuth2的公有密钥。</a></p>
</li>
<li><p>–oidc-client-id 客户端的ID。</p>
</li>
</ul>
<p>该方式通过OAuth2服务的公有密钥对JWT中Signature校验实现身份认证。</p>
<h2 id="Webhook-Token-Authentication"><a href="#Webhook-Token-Authentication" class="headerlink" title="Webhook Token Authentication"></a>Webhook Token Authentication</h2><p>该认证方式类似于Static Token File，但它提供扩展Token身份验证的能力，具体的Token合法性验证由外部系统完成，Kubernetes平台将不再管理或配置具体的用户信息。</p>
<p>要启用此插件，需要设置下面两个参数：</p>
<ul>
<li><p>–authentication-token-webhook-config-file 一个kubeconfig文件描述如何访问远程webhook服务。</p>
</li>
<li><p>–authentication-token-webhook-cache-ttl 用于设置缓存时间，默认为两分钟。</p>
</li>
</ul>
<p>当客户端尝试使用承载令牌向API服务器进行身份验证时，身份验证webhook将包含令牌的JSON序列化对象POST 发送到远程服务。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/image-20210122085309532.png" alt="image-20210122085309532"></p>
<p>POST正文将采用以下格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;authentication.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;TokenReview&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;(BEARERTOKEN)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证成功将返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;authentication.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;TokenReview&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;authenticated&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;ms@mifpay.com&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;42&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;groups&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;quantai&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ms&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;extra&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;extrafield1&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;extravalue1&quot;</span>,</span><br><span class="line">          <span class="string">&quot;extravalue2&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证不成功将返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;authentication.k8s.io/v1beta1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;TokenReview&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;authenticated&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="X509-Client-Certs"><a href="#X509-Client-Certs" class="headerlink" title="X509 Client Certs"></a>X509 Client Certs</h2><h3 id="双向TLS协议"><a href="#双向TLS协议" class="headerlink" title="双向TLS协议"></a>双向TLS协议</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h5><p>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：         </p>
<ul>
<li>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。                 </li>
<li>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，<strong>也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。</strong></li>
</ul>
<p>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</p>
<h5 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h5><p>在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。这个和上面的公钥密码体制有所不同，公钥密码体制中加密是用公钥，解密使用私钥，而对称加密算法中，加密和解密都是使用同一个密钥，不区分公钥和私钥。</p>
<blockquote>
<p>密钥，一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。前面在公钥密码体制中说到的公钥、私钥就是密钥，公钥是加密使用的密钥，私钥是解密使用的密钥。</p>
</blockquote>
<h5 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h5><p>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。</p>
<h5 id="RSA简介"><a href="#RSA简介" class="headerlink" title="RSA简介"></a>RSA简介</h5><p>RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。</p>
<p>由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，<strong>RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密</strong>。</p>
<h5 id="签名和加密"><a href="#签名和加密" class="headerlink" title="签名和加密"></a>签名和加密</h5><p>我们说加密，是指对某个内容加密，加密后的内容还可以通过解密进行还原。比如我们把一封邮件进行加密，加密后的内容在网络上进行传输，接收者在收到后，通过解密可以还原邮件的真实内容。         </p>
<p>这里主要解释一下签名，签名就是在<strong>信息</strong>的后面再加上一段内容，可以证明<strong>信息</strong>没有被修改过，怎么样可以达到这个效果呢？一般是对<strong>信息</strong>做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的<strong>信息</strong>内容。在把<strong>信息</strong>发送出去时，把这个hash值加密后做为一个签名和<strong>信息</strong>一起发出去。接收方在收到<strong>信息</strong>后，会重新计算<strong>信息</strong>的hash值，并和<strong>信息</strong>所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据<strong>信息</strong>内容计算的hash值就会变化。当然，不怀好意的人也可以修改<strong>信息</strong>内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和<strong>信息</strong>一起发送，以保证这个hash值不被修改。</p>
<h4 id="一个加密通信过程的演化"><a href="#一个加密通信过程的演化" class="headerlink" title="一个加密通信过程的演化"></a>一个加密通信过程的演化</h4><p>来看一个例子，现在假设”服务器”和”客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，”服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。”客户”通过某些途径拿到了”服务器”发布的公钥，客户并不知道私钥。</p>
<p>下面看一下双方如何进行保密的通信：</p>
<h5 id="第一回合"><a href="#第一回合" class="headerlink" title="第一回合"></a>第一回合</h5><p>“客户”-&gt;”服务器”：你好         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器         </p>
<p>“客户”-&gt;”服务器”：？？？？         </p>
<p>因为消息是在网络上传输的，有人可以冒充自己是”服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：     </p>
<hr>
<p><del>“客户”-&gt;”服务器”：你好</del> </p>
<p><del>“服务器”-&gt;”客户”：你好，我是服务器</del> </p>
<p>“客户”-&gt;”黑客”：你好  // 黑客在”客户”和”服务器”之间的某个路由器上截获”客户”发给服务器的信息，然后自己冒充”服务器”                 </p>
<p>“黑客”-&gt;”客户”：你好，我是服务器 </p>
<p>因此”客户”在接到消息后，并不能肯定这个消息就是由”服务器”发出的，某些”黑客”也可以冒充”服务器”发出这个消息。如何确定信息是由”服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是”服务器”。因此通信过程可以改进为如下</p>
<h5 id="第二回合"><a href="#第二回合" class="headerlink" title="第二回合"></a>第二回合</h5><p>“客户”-&gt;”服务器”：你好         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器         </p>
<p>“客户”-&gt;”服务器”：向我证明你就是服务器         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]</p>
<blockquote>
<p>注意这里约定一下，{}表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的{你好，我是服务器}[私钥|RSA] 就表示用私钥对”你好，我是服务器”进行加密后的结果。</p>
</blockquote>
<p>为了向”客户”证明自己是”服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给”客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是服务器}[私钥|RSA] 发给客户。</p>
<p>“客户”收到信息后，用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。也就是说”客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和”你好，我是服务器”对比。因为由”服务器”用私钥加密后的内容，<strong>由并且只能由</strong>公钥进行解密，私钥只有”服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从”服务器”发过来的。</p>
<p>假设”黑客”想冒充”服务器”：         </p>
<p>“黑客”-&gt;”客户”：你好，我是服务器         </p>
<p>“客户”-&gt;”黑客”：向我证明你就是服务器         </p>
<p>“黑客”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]**  //这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。</p>
<p>“客户”-&gt;”黑客”：？？？？</p>
<p>由于”黑客”没有”服务器”的私钥，因此它发送过去的内容，”客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！         </p>
<p>到这里为止，”客户”就可以确认”服务器”的身份了，可以放心和”服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：</p>
<h5 id="第三回合"><a href="#第三回合" class="headerlink" title="第三回合"></a>第三回合</h5><p>“客户”-&gt;”服务器”：你好         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器         </p>
<p>“客户”-&gt;”服务器”：向我证明你就是服务器         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]             </p>
<p>“客户”-&gt;”服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]             </p>
<p>“服务器”-&gt;”客户”：{你的余额是100元}[私钥|RSA]</p>
<p>注意上面的的信息 {你的余额是100元}[私钥]，这个是”服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了”客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果”服务器”用私钥加密发给”客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而”服务器”也不能用公钥对发送的内容进行加密，因为”客户”没有私钥，发送个”客户”也解密不了。                         </p>
<p>这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p>
<h5 id="第四回合"><a href="#第四回合" class="headerlink" title="第四回合"></a>第四回合</h5><p>“客户”-&gt;”服务器”：你好         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器         </p>
<p>“客户”-&gt;”服务器”：向我证明你就是服务器         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]             </p>
<p>“客户”-&gt;”服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]  //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。             </p>
<p>“服务器”-&gt;”客户”：{OK，收到！}[密钥|对称加密算法]             </p>
<p>“客户”-&gt;”服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]             </p>
<p>“服务器”-&gt;”客户”：{你的余额是100元}[密钥|对称加密算法]</p>
<p>在上面的通信过程中，”客户”在确认了”服务器”的身份后，”客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给”服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被”黑客”截获了，由于没有私钥，”黑客”也无从知道对称加密算法和密钥的内容。         </p>
<p>由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是”客户”自己选择的，所以”客户”自己当然知道如何解密加密)。这样”服务器”和”客户”就可以用对称加密算法和密钥来加密通信的内容了。         </p>
<p>总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：         </p>
<ul>
<li>因为私钥只有”服务器”拥有，因此”客户”可以通过判断对方是否有私钥来判断对方是否是”服务器”。                 </li>
<li>客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。</li>
</ul>
<p>到这里，”客户”就可以确认”服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。         </p>
<p>但是这里还留有一个问题，在最开始我们就说过，”服务器”要对外发布公钥，那”服务器”如何把公钥发送给”客户”呢？我们第一反应可能会想到以下的两个方法：         </p>
<p>a)把公钥放到互联网的某个地方的一个下载地址，事先给”客户”去下载。         </p>
<p>b)每次和”客户”开始通信时，”服务器”把公钥发给”客户”。         </p>
<p>但是这个两个方法都有一定的问题，         </p>
<p>对于a)方法，”客户”无法确定这个下载地址是不是”服务器”发布的，你凭什么就相信这个地址下载的东西就是”服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的”客户”都在通信前事先去下载公钥也很不现实。         </p>
<p>对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向”客户”发送他自己的私钥就可以冒充”服务器”了。示意如下：         </p>
<p>“客户”-&gt;”黑客”：你好      //黑客截获”客户”发给”服务器”的消息                     </p>
<p>“黑客”-&gt;”客户”：你好，我是服务器，这个是我的公钥  //黑客自己生成一对公钥和私钥，把公钥发给”客户”，自己保留私    </p>
<p>“客户”-&gt;”黑客”：向我证明你就是服务器                 </p>
<p>“黑客”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]   //客户收到”黑客”用私钥加密的信息后，是可以用”黑客”发给自己的公钥解密的，从而会误认为”黑客”是”服务器”                         </p>
<p>因此”黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给”客户”，自己保留私钥，这样由于”客户”可以用黑客的公钥解密黑客的私钥加密的内容，”客户”就会相信”黑客”是”服务器”，从而导致了安全问题。<strong>这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。</strong> 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到”黑客”冒充”服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是”服务器”的就好了。         </p>
<p>为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：         </p>
<ul>
<li>证书的发布机构                 </li>
<li>证书的有效期                 </li>
<li>公钥                 </li>
<li>证书所有者（Subject）                 </li>
<li>签名所使用的算法                 </li>
<li>指纹以及指纹算法                 </li>
</ul>
<p>证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，<strong>数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。</strong>也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：</p>
<h5 id="第五回合"><a href="#第五回合" class="headerlink" title="第五回合"></a>第五回合</h5><p>“客户”-&gt;”服务器”：你好         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器，这里是我的数字证书    //这里用证书代替了公钥         </p>
<p>“客户”-&gt;”服务器”：向我证明你就是服务器         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]             </p>
<p>注意，上面第二次通信，”服务器”把自己的证书发给了”客户”，而不是发送公钥。”客户”可以根据证书校验这个证书到底是不是”服务器”的，也就是能校验这个证书的所有者是不是”服务器”，从而确认这个证书中的公钥的确是”服务器”的。后面的过程和以前是一样，”客户”让”服务器”证明自己的身份，”服务器”用私钥加密一段内容连同明文一起发给”客户”，”客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是”服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：</p>
<h5 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h5><p><strong>step1</strong>： “客户”向服务端发送一个通信请求         </p>
<p>“客户”-&gt;”服务器”：你好         </p>
<p><strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由”服务器”持有         </p>
<p>“服务器”-&gt;”客户”：你好，我是服务器，这里是我的数字证书                 </p>
<p><strong>step3</strong>： “客户”收到”服务器”的证书后，它会去验证这个数字证书到底是不是”服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是”服务器”的。检查数字证书后，”客户”会发送一个随机的字符串给”服务器”用私钥去加密，服务器把加密的结果返回给”客户”，”客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是”服务器”。         </p>
<p>“客户”-&gt;”服务器”：向我证明你就是服务器，这是一个随机字符串   //前面的例子中为了方便解释，用的是”你好”等内容，实际情况下一般是随机生成的一个字符串。             </p>
<p>“服务器”-&gt;”客户”：{一个随机字符串}[私钥|RSA]                     </p>
<p><strong>step4</strong>： 验证”服务器”的身份后，”客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，”客户”会用公钥加密后发送给”服务器”，别人截获了也没用，因为只有”服务器”手中有可以解密的私钥。这样，后面”服务器”和”客户”就都可以用对称加密算法来加密和解密通信内容了。         </p>
<p>“服务器”-&gt;”客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]             </p>
<p>“客户”-&gt;”服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]             </p>
<p>“服务器”-&gt;”客户”：{你好，你的余额是100元}[密钥|对称加密算法]             </p>
<p>…… //继续其它的通信</p>
<h5 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h5><p>【问题1】         </p>
<p>上面的通信过程中说到，在检查完证书后，”客户”发送一个随机的字符串给”服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，”黑客”也可以发送一个字符串给”服务器”去加密并且得到加密后的内容，这样对于”服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给”服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，”服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。         </p>
<p>〖解决方法〗         </p>
<p>每次收到”客户”发来的要加密的的字符串时，”服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给”客户”，”客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，”服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。”客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把”服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是”服务器”。 </p>
<p>【问题2】         </p>
<p>在双方的通信过程中，”黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。         </p>
<p>〖解决方法〗         </p>
<p>可以给通信的内容加上一个序号或者一个随机的值，如果”客户”或者”服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？         答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。 </p>
<p>【问题3】         </p>
<p>在双方的通信过程中，”黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，”客户”和”服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是”黑客”可以一直这样碰碰运气。         </p>
<p>〖解决方法〗         </p>
<p>在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。</p>
<hr>
<p>以上是单向SSL认证的内容</p>
<blockquote>
<p>双向认证 SSL 协议要求服务器和用户双方都有证书。单向认证 SSL 协议不需要客户拥有CA证书，具体的过程相对于上面的步骤，只需将服务器端验证客户证书的过程去掉，以及在协商对称密码方案，对称通话密钥时，服务器发送给客户的是没有加过密的(这并不影响 SSL 过程的安全性)密码方案。这样，双方具体的通讯内容，就是加过密的数据，如果有第三方攻击，获得的只是加密的数据，第三方要获得有用的信息，就需要对加密的数据进行解密，这时候的安全就依赖于密码方案的安全。而幸运的是，目前所用的密码方案，只要通讯密钥长度足够的长，就足够的安全。这也是我们强调要求使用128位加密通讯的原因。<br>一般Web应用都是采用SSL单向认证的，原因很简单，用户数目广泛，且无需在通讯层对用户身份进行验证，一般都在应用逻辑层来保证用户的合法登入。但如果是企业应用对接，情况就不一样，可能会要求对客户端(相对而言)做身份验证。这时就需要做SSL双向认证。</p>
</blockquote>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/3437040-88fdfaf70a49c1fb.png" alt="3437040-88fdfaf70a49c1fb"></p>
<p>①客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>②服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>③客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的”发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开;如果合法性验证通过，将继续进行第四步。</p>
<p>④用户端随机产生一个用于后面通讯的”对称密码”，然后用服务器的公钥(服务器的公钥从步骤②中的服务器的证书中获得)对其加密，然后将加密后的”预主密码”传给服务器。</p>
<p>⑤如果服务器要求客户的身份认证(在握手过程中为可选)，用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码”一起传给服务器。</p>
<p>⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表(CRL)中。检验如果没有通过，通讯立刻中断;如果验证通过，服务器将用自己的私钥解开加密的”预主密码 “，然后执行一系列步骤来产生主通讯密码(客户端也将通过同样的方法产生相同的主通讯密码)。</p>
<p>⑦服务器和客户端用相同的主密码即”通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p>
<p>⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p>
<p>⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p>
<p>⑩SSL的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/3437040-5e8d79e001ff5118.png" alt="3437040-5e8d79e001ff5118"></p>
<p>① 浏览器发送一个连接请求给安全服务器。</p>
<p>② 服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。</p>
<p>③ 客户浏览器检查服务器送过来的证书是否是由自己信赖的CA中心（如沃通CA）所签发的。如果是，就继续执行协议;如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。</p>
<p>④ 接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。</p>
<p>⑤ 服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接;如果通过验证，服务器获得用户的公钥。</p>
<p>⑥ 客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。</p>
<p>⑦ 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。</p>
<p>⑧ 浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。</p>
<p>⑨ 服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。</p>
<p>⑩ 服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。</p>
<p>SSL双向认证步骤：</p>
<ol>
<li>HTTPS通信双方的服务器端向CA机构申请证书，CA机构是可信的第三方机构，它可以是一个公认的权威的企业，也可以是企业自身。企业内部系统一般都使用企业自身的认证系统。CA机构下发根证书、服务端证书及私钥给申请者；</li>
<li>HTTPS通信双方的客户端向CA机构申请证书，CA机构下发根证书、客户端证书及私钥个申请者；</li>
<li>客户端向服务器端发起请求，服务端下发服务端证书给客户端。客户端接收到证书后，通过私钥解密证书，并利用服务器端证书中的公钥认证证书信息比较证书里的消息，例如域名和公钥与服务器刚刚发送的相关消息是否一致，如果一致，则客户端认为这个服务器的合法身份；</li>
<li>客户端发送客户端证书给服务器端，服务端接收到证书后，通过私钥解密证书，获得客户端的证书公钥，并用该公钥认证证书信息，确认客户端是否合法；</li>
<li>客户端通过随机秘钥加密信息，并发送加密后的信息给服务端。服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥，客户端通过协商好的加密方案，加密该随机秘钥，并发送该随机秘钥到服务器端。服务器端接收这个秘钥后，双方通信的所有内容都都通过该随机秘钥加密；</li>
</ol>
<h3 id="cfssl命令"><a href="#cfssl命令" class="headerlink" title="cfssl命令"></a>cfssl命令</h3><p>cfssl 是 CloudFlare 开源的一款PKI/TLS工具。 CFSSL 包含一个命令行工具(cfssl,  cfssljson)用于签名，验证并且捆绑TLS证书的 HTTP API 服务。 使用Go语言编写。与 OpenSSL 相比，cfssl  使用起来更简单。</p>
<p>大部分 cfssl 的输出为 JSON 格式。cfssljson 可以将输出拆分出来为独立的key，certificate，CSR 和 bundle文件。该工具需要指定参数，<code>-f</code> 指定输入文件，后接一个参数，指定生成的文件的基本名称。如果输入文件名是 <code>-</code>（默认值），则 cfssljson 从标准输入读取。它以下列方式将 JSON 文件中的键映射到文件名：</p>
<ul>
<li>如果指定了cert或certificate， 将生成basename.pem。</li>
<li>如果指定了key 或private_key，则将生成basename-key.pem。</li>
<li>如果指定了csr 或certificate_request，则将生成basename.csr。</li>
<li>如果 指定了bundle， 则将生成basename-bundle.pem。</li>
<li>如果指定了ocspResponse， 则将生成basename-response.der。<br>您可以传递-stdout输出编码内容到标准输出，而不是保存到文件。</li>
</ul>
<h4 id="验证证书有效期"><a href="#验证证书有效期" class="headerlink" title="验证证书有效期"></a>验证证书有效期</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cfssl certinfo -cert /etc/kubernetes/ssl/ca.pem |grep not_after</span><br><span class="line">cfssl certinfo -cert  /etc/kubernetes/ssl/admin.pem |grep not_after</span><br><span class="line">cfssl certinfo -cert /etc/kubernetes/ssl/kubernetes.pem |grep not_after</span><br><span class="line">cfssl certinfo -cert /etc/kubernetes/ssl/kube-proxy.pem  |grep not_after</span><br></pre></td></tr></table></figure>
<h4 id="生成新证书"><a href="#生成新证书" class="headerlink" title="生成新证书"></a>生成新证书</h4><p>证书分四类</p>
<ul>
<li>ca.pem -  私有CA根证书</li>
<li>kubernetes.pem  - 与 node 通信的，</li>
<li>kube-proxy.pem  - k8s 与容器通信的</li>
<li>admin.pem  - kubectl 管理用</li>
</ul>
<p>在生成证书过程中需要有四类文件</p>
<ul>
<li>*.csr - 证书请求文件,base64格式，有<code>-----BEGIN CERTIFICATE REQUEST-----</code>标识</li>
<li>*csr.json - 证书请求文件，是上面格式的再封装，便于传给<code>cfssl</code>，json格式，大括号开始</li>
<li>*-key.pem - 私匙文件，base64格式，有<code>-----BEGIN RSA PRIVATE KEY-----</code>标识</li>
<li>*.pem - 证书文件，base64格式，可以用<code>cfssl certinfo -cert 文件名</code>查看有效期，有<code>-----BEGIN CERTIFICATE-----</code>标识</li>
</ul>
<p>以上四种文件，前两类是中间产物，过后可以不保留，后两个需要配置到系统中 (通常是主从结点的<code>/etc/kubernetes/ssl</code>目录下)。</p>
<h4 id="创建CA证书"><a href="#创建CA证书" class="headerlink" title="创建CA证书"></a>创建CA证书</h4><p><strong>创建证书配置文件</strong></p>
<p>vim ca-config.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;signing&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;default&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;profiles&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;kubernetes&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;usages&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;signing&quot;</span>,</span><br><span class="line">      <span class="string">&quot;key encipherment&quot;</span>,</span><br><span class="line">      <span class="string">&quot;server auth&quot;</span>,</span><br><span class="line">      <span class="string">&quot;client auth&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<p>ca-config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</p>
<p>signing：表示该证书可以签名其他证书；生成的ca.pem证书中 CA=TRUE；</p>
<p>server auth：表示client可以用该 CA 对server提供的证书进行验证；</p>
<p>client auth：表示server可以用该CA对client提供的证书进行验证；</p>
<p>expiry：过期时间</p>
<h4 id="创建CA证书签名请求文件"><a href="#创建CA证书签名请求文件" class="headerlink" title="创建CA证书签名请求文件"></a>创建CA证书签名请求文件</h4><p>vim ca-csr.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;kubernetes&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;k8s&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;System&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line">  <span class="attr">&quot;ca&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;expiry&quot;</span>: <span class="string">&quot;87600h&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<p>“CN”：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</p>
<p>“O”：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)</p>
<h4 id="生成CA证书和私钥"><a href="#生成CA证书和私钥" class="headerlink" title="生成CA证书和私钥"></a>生成CA证书和私钥</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">ls | grep ca</span><br><span class="line">ca-config.json</span><br><span class="line">ca.csr</span><br><span class="line">ca-csr.json</span><br><span class="line">ca-key.pem</span><br><span class="line">ca.pem</span><br></pre></td></tr></table></figure>
<p>其中ca-key.pem是ca的私钥，ca.csr是一个签署请求，ca.pem是CA证书，是后面kubernetes组件会用到的RootCA。</p>
<h4 id="创建kubernetes证书"><a href="#创建kubernetes证书" class="headerlink" title="创建kubernetes证书"></a>创建kubernetes证书</h4><p>在创建这个证书之前，先规划一下架构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">k8s-master1 10.211.55.11</span><br><span class="line">k8s-master2 10.211.55.12</span><br><span class="line">k8s-master3 10.211.55.13</span><br><span class="line">etcd01     10.211.55.11</span><br><span class="line">etcd02     10.211.55.12</span><br><span class="line">etcd03     10.211.55.13</span><br><span class="line">VIP        10.211.55.8 </span><br></pre></td></tr></table></figure>
<p>创建kubernetes证书签名请求文件</p>
<p>vim kubernetes-csr.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;kubernetes&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.11&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.12&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.13&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.8&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.0.0.1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master2&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master3&quot;</span>,</span><br><span class="line">   <span class="string">&quot;etcd01&quot;</span>,</span><br><span class="line">   <span class="string">&quot;etcd02&quot;</span>,</span><br><span class="line">   <span class="string">&quot;etcd03&quot;</span>,</span><br><span class="line">   <span class="string">&quot;kubernetes&quot;</span>,</span><br><span class="line">   <span class="string">&quot;kubernetes.default&quot;</span>,</span><br><span class="line">   <span class="string">&quot;kubernetes.default.svc&quot;</span>,</span><br><span class="line">   <span class="string">&quot;kubernetes.default.svc.cluster&quot;</span>,</span><br><span class="line">   <span class="string">&quot;kubernetes.default.svc.cluster.local&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;k8s&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;System&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段说明：</p>
<p>如果 hosts 字段不为空则需要指定授权使用该证书的 IP 或域名列表。</p>
<p>由于该证书后续被 etcd 集群和 kubernetes master  集群使用，将etcd、master节点的IP都填上，同时还有service网络的首IP。(一般是 kube-apiserver 指定的  service-cluster-ip-range 网段的第一个IP，如 10.0.0.1)</p>
<p>三个etcd，三个master，以上物理节点的IP也可以更换为主机名。</p>
<p><strong>生成kubernetes证书和私钥</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json  -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br><span class="line">ls |grep kubernetes</span><br><span class="line">kubernetes.csr</span><br><span class="line">kubernetes-csr.json</span><br><span class="line">kubernetes-key.pem</span><br><span class="line">kubernetes.pem</span><br></pre></td></tr></table></figure>
<p><strong>创建admin证书</strong></p>
<p><strong>创建admin证书签名请求文件</strong></p>
<p> vim admin-csr.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;hosts&quot;</span>: [],</span><br><span class="line"> <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line"> <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;System&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>后续 kube-apiserver 使用 RBAC 对客户端(如 kubelet、kube-proxy、Pod)请求进行授权；</p>
<p>kube-apiserver 预定义了一些 RBAC 使用的 RoleBindings，如 cluster-admin 将 Group system:masters 与  Role cluster-admin 绑定，该 Role 授予了调用kube-apiserver 的所有 API的权限；</p>
<p>O指定该证书的 Group 为 system:masters，kubelet 使用该证书访问 kube-apiserver 时 ，由于证书被 CA  签名，所以认证通过，同时由于证书用户组为经过预授权的 system:masters，所以被授予访问所有 API 的权限；</p>
<p>注：这个admin 证书，是将来生成管理员用的kube config 配置文件用的，现在我们一般建议使用RBAC 来对kubernetes 进行角色权限控制， kubernetes 将证书中的CN 字段 作为User， O 字段作为 Group</p>
<p>相关权限认证可以参考下面文章</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XIkQdh5gnr-KJhuFHboNag">https://mp.weixin.qq.com/s/XIkQdh5gnr-KJhuFHboNag</a></p>
<p><strong>生成admin证书和私钥</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class="line">ls | grep admin</span><br><span class="line">admin.csr</span><br><span class="line">admin-csr.json</span><br><span class="line">admin-key.pem</span><br><span class="line">admin.pem</span><br></pre></td></tr></table></figure>
<p><strong>创建kube-proxy证书</strong></p>
<p><strong>创建 kube-proxy 证书签名请求文件</strong> </p>
<p>vim kube-proxy-csr.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;system:kube-proxy&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;hosts&quot;</span>: [],</span><br><span class="line"> <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;k8s&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;System&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>CN 指定该证书的 User 为 system:kube-proxy；</p>
<p>kube-apiserver 预定义的 RoleBinding system:node-proxier 将User system:kube-proxy 与 Role  system:node-proxier 绑定，该 Role 授予了调用 kube-apiserver Proxy 相关 API 的权限；</p>
<p>该证书只会被 kubectl 当做 client 证书使用，所以 hosts 字段为空 </p>
<p><strong>生成kube-proxy证书和私钥</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json  -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">ls |grep kube-proxy</span><br><span class="line">kube-proxy.csr</span><br><span class="line">kube-proxy-csr.json</span><br><span class="line">kube-proxy-key.pem</span><br><span class="line">kube-proxy.pem</span><br></pre></td></tr></table></figure>
<p><strong>创建kube-controoler-manager证书</strong></p>
<p><strong>创建 kube-controoler-manager 证书签名请求文件</strong> </p>
<p>vim kube-controller-manager-csr.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;system:kube-controller-manager&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.11&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.12&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.13&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master2&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master3&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;BeiJing&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;BeiJing&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;system:kube-controller-manager&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;system&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>hosts 列表包含所有 kube-controller-manager 节点 IP；</p>
<p>CN 为 system:kube-controller-manager、O 为  system:kube-controller-manager，kubernetes 内置的 ClusterRoleBindings  system:kube-controller-manager 赋予 kube-controller-manager 工作所需的权限</p>
<p><strong>生成kube-controoller-manager证书和私钥</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json  -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare  kube-controller-manager </span><br></pre></td></tr></table></figure>
<p><strong>创建kube-scheduler证书</strong> </p>
<p> <strong>创建 kube-scheduler 证书签名请求文件</strong></p>
<p>vim kube-scheduler-csr.json </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;system:kube-scheduler&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.11&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.12&quot;</span>,</span><br><span class="line">   <span class="string">&quot;10.211.55.13&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master2&quot;</span>,</span><br><span class="line">   <span class="string">&quot;k8s-master3&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;system:kube-scheduler&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;4Paradigm&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>hosts 列表包含所有 kube-scheduler 节点 IP；</p>
<p>CN 为 system:kube-scheduler、O 为 system:kube-scheduler，kubernetes 内置的  ClusterRoleBindings system:kube-scheduler 将赋予 kube-scheduler 工作所需的权限。</p>
<p><strong>经过上述操作，我们会用到如下文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json  -profile=kubernetes kube-scheduler-csr.json| cfssljson -bare  kube-scheduler</span><br><span class="line">ls | grep pem</span><br><span class="line">admin-key.pem</span><br><span class="line">admin.pem</span><br><span class="line">ca-key.pem</span><br><span class="line">ca.pem</span><br><span class="line">kube-proxy-key.pem</span><br><span class="line">kube-proxy.pem</span><br><span class="line">kubernetes-key.pem</span><br><span class="line">kubernetes.pem</span><br><span class="line">kube-controller-manager-key.pem</span><br><span class="line">kube-controller-manager.pem</span><br><span class="line">kube-scheduler-key.pem</span><br><span class="line">kube-scheduler.pem</span><br></pre></td></tr></table></figure>
<p>查看证书信息： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl-certinfo -cert kubernetes.pem</span><br></pre></td></tr></table></figure>
<h3 id="k8s的认证"><a href="#k8s的认证" class="headerlink" title="k8s的认证"></a>k8s的认证</h3><p>在 Kubernetes  中，各个组件提供的接口中包含了集群的内部信息。如果这些接口被非法访问，将影响集群的安全，因此组件之间的通信需要采用双向 TLS  认证。即客户端和服务器端都需要验证对方的身份信息。在两个组件进行双向认证时，会涉及到下面这些证书相关的文件：</p>
<ul>
<li>服务器端证书：服务器用于证明自身身份的数字证书，里面主要包含了服务器端的公钥以及服务器的身份信息。</li>
<li>服务器端私钥：服务器端证书中包含的公钥所对应的私钥。公钥和私钥是成对使用的，在进行 TLS 验证时，服务器使用该私钥来向客户端证明自己是服务器端证书的拥有者。</li>
<li>客户端证书：客户端用于证明自身身份的数字证书，里面主要包含了客户端的公钥以及客户端的身份信息。</li>
<li>客户端私钥：客户端证书中包含的公钥所对应的私钥，同理，客户端使用该私钥来向服务器端证明自己是客户端证书的拥有者。</li>
<li>服务器端 CA 根证书：签发服务器端证书的 CA 根证书，客户端使用该 CA 根证书来验证服务器端证书的合法性。</li>
<li>客户端端 CA 根证书：签发客户端证书的 CA 根证书，服务器端使用该 CA 根证书来验证客户端证书的合法性。</li>
</ul>
<h3 id="Kubernetes-中使用到的CA和证书"><a href="#Kubernetes-中使用到的CA和证书" class="headerlink" title="Kubernetes 中使用到的CA和证书"></a>Kubernetes 中使用到的CA和证书</h3><p>Kubernetes 中使用了大量的证书，本文不会试图覆盖到所有可能使用到的证书，但会讨论到主要的证书。理解了这些证书的使用方法和原理后，也能很快理解其他可能遇到的证书文件。下图标识出了在 kubernetes 中主要使用到的证书和其使用的位置：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/kubernetes-certificate-usage.png" alt="kubernetes-certificate-usage"></p>
<p>上图中使用序号对证书进行了标注。图中的箭头表明了组件的调用方向，箭头所指方向为服务提供方，另一头为服务调用方。为了实现 TLS  双向认证，服务提供方需要使用一个服务器证书，服务调用方则需要提供一个客户端证书，并且双方都需要使用一个 CA  证书来验证对方提供的证书。为了简明起见，上图中只标注了证书使用方提供的证书，并没有标注证书的验证方验证使用的 CA  证书。图中标注的这些证书的作用分别如下：</p>
<ol>
<li>etcd 集群中各个节点之间相互通信使用的证书。由于一个 etctd 节点既为其他节点提供服务，又需要作为客户端访问其他节点，因此该证书同时用作服务器证书和客户端证书。</li>
<li>etcd 集群向外提供服务使用的证书。该证书是服务器证书。</li>
<li>kube-apiserver 作为客户端访问 etcd 使用的证书。该证书是客户端证书。</li>
<li>kube-apiserver 对外提供服务使用的证书。该证书是服务器证书。</li>
<li>kube-controller-manager 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li>
<li>kube-scheduler 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li>
<li>kube-proxy 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li>
<li>kubelet 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li>
<li>管理员用户通过 kubectl 访问 kube-apiserver 使用的证书,该证书是客户端证书。</li>
<li>kubelet 对外提供服务使用的证书。该证书是服务器证书。</li>
<li>kube-apiserver 作为客户端访问 kubelet 采用的证书。该证书是客户端证书。</li>
<li>kube-controller-manager 用于生成和验证 service-account token  的证书。该证书并不会像其他证书一样用于身份认证，而是将证书中的公钥/私钥对用于 service account token  的生成和验证。kube-controller-manager 会用该证书的私钥来生成 service account token，然后以  secret 的方式加载到 pod 中。pod 中的应用可以使用该 token 来访问 kube-apiserver，  kube-apiserver 会使用该证书中的公钥来验证请求中的 token。</li>
</ol>
<p>通过这张图，对证书机制比较了解的读者可能已经看出，我们其实可以使用多个不同的 CA 来颁发这些证书。只要在通信的组件中正确配置用于验证对方证书的 CA 根证书，就可以使用不同的 CA 来颁发不同用途的证书。但我们一般建议采用统一的 CA 来颁发 kubernetes  集群中的所有证书，这是因为采用一个集群根 CA 的方式比采用多个 CA 的方式更容易管理，可以避免多个CA  导致的复杂的证书配置、更新等问题，减少由于证书配置错误导致的集群故障。</p>
<h4 id="k8s中的证书配置"><a href="#k8s中的证书配置" class="headerlink" title="k8s中的证书配置"></a>k8s中的证书配置</h4><p><strong>所有客户端的证书首先要经过集群CA的签署，否则不会被集群认可</strong> </p>
<h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><p>需要在 etcd 的启动命令行中配置以下证书相关参数：</p>
<ul>
<li>etcd 对外提供服务的服务器证书及私钥。</li>
<li>etcd 节点之间相互进行认证的 peer 证书、私钥以及验证 peer 的 CA。</li>
<li>etcd 验证访问其服务的客户端的 CA。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/etcd \\</span><br><span class="line">  --cert-file=/etc/etcd/kube-etcd.pem \\                   <span class="comment"># 对外提供服务的服务器证书</span></span><br><span class="line">  --key-file=/etc/etcd/kube-etcd-key.pem \\                <span class="comment"># 服务器证书对应的私钥</span></span><br><span class="line">  --peer-cert-file=/etc/etcd/kube-etcd-peer.pem \\         <span class="comment"># peer 证书，用于 etcd 节点之间的相互访问</span></span><br><span class="line">  --peer-key-file=/etc/etcd/kube-etcd-peer-key.pem \\      <span class="comment"># peer 证书对应的私钥</span></span><br><span class="line">  --trusted-ca-file=/etc/etcd/cluster-root-ca.pem \\       <span class="comment"># 用于验证访问 etcd 服务器的客户端证书的 CA 根证书</span></span><br><span class="line">  --peer-trusted-ca-file=/etc/etcd/cluster-root-ca.pem\\   <span class="comment"># 用于验证 peer 证书的 CA 根证书</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h5 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h5><p>kubectl只是个go编写的可执行程序，只要为kubectl配置合适的kubeconfig，就可以在集群中的任意节点使用 。kubectl的权限为admin，具有访问kubernetes所有api的权限。</p>
<table>
<thead>
<tr>
<th>证书名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ca.pem</td>
<td>CA根证书</td>
</tr>
<tr>
<td>admin.pem</td>
<td>kubectl的TLS认证证书，具有admin权限</td>
</tr>
<tr>
<td>admin-key.pem</td>
<td>kubectl的TLS认证私钥</td>
</tr>
</tbody></table>
<ul>
<li><code>--certificate-authority=/etc/kubernetes/ssl/ca.pem</code>   设置了该集群的根证书路径， <code>--embed-certs为true</code>表示将<code>--certificate-authority</code>证书写入到kubeconfig中</li>
<li><code>--client-certificate=/etc/kubernetes/ssl/admin.pem</code>  指定kubectl证书</li>
<li><code>--client-key=/etc/kubernetes/ssl/admin-key.pem</code>  指定kubectl私钥</li>
</ul>
<h5 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h5><table>
<thead>
<tr>
<th>证书名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ca.pem</td>
<td>CA根证书</td>
</tr>
<tr>
<td>kubelet-client.crt</td>
<td>kubectl的TLS认证证书</td>
</tr>
<tr>
<td>kubelet-client.key</td>
<td>kubectl的TLS认证私钥</td>
</tr>
<tr>
<td>kubelet.crt</td>
<td>独立于 apiserver CA 的自签 CA</td>
</tr>
<tr>
<td>kubelet.key</td>
<td>独立于 apiserver CA 的私钥</td>
</tr>
</tbody></table>
<p>当成功签发证书后，目标节点的 kubelet 会将证书写入到 –cert-dir= 选项指定的目录中；此时如果不做其他设置应当生成上述除ca.pem以外的4个文件</p>
<ul>
<li>kubelet-client.crt  该文件在 kubelet 完成 TLS bootstrapping 后生成，此证书是由 controller manager 签署的，此后 kubelet 将会加载该证书，用于与 apiserver 建立 TLS 通讯，同时使用该证书的 CN 字段作为用户名，O 字段作为用户组向 apiserver 发起其他请求</li>
<li>kubelet.crt  该文件在 kubelet 完成 TLS bootstrapping 后并且<strong>没有配置 –feature-gates=RotateKubeletServerCertificate=true 时才会生成</strong>；这种情况下该文件为一个独立于 apiserver CA 的自签 CA 证书，有效期为 1 年；被用作 kubelet 10250 api 端口</li>
</ul>
<h5 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h5><p>kube-apiserver是我们在部署kubernetes集群是最需要先启动的组件，也是我们和集群交互的核心组件。</p>
<p>需要在 kube-apiserver 中配置以下证书相关参数：</p>
<ul>
<li>kube-apiserver 对外提供服务的服务器证书及私钥。</li>
<li>kube-apiserver 访问 etcd 所需的客户端证书及私钥。</li>
<li>kube-apiserver 访问 kubelet 所需的客户端证书及私钥。</li>
<li>验证访问其服务的客户端的 CA。</li>
<li>验证 etcd 服务器证书的 CA 根证书。</li>
<li>验证 service account token 的公钥。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/kube-apiserver \\ </span><br><span class="line">  --tls-cert-file=/var/lib/kubernetes/kube-apiserver.pem \\                             <span class="comment"># 用于对外提供服务的服务器证书</span></span><br><span class="line">  --tls-private-key-file=/var/lib/kubernetes/kube-apiserver-key.pem \\                  <span class="comment"># 服务器证书对应的私钥</span></span><br><span class="line">  --etcd-certfile=/var/lib/kubernetes/kube-apiserver-etcd-client.pem \\                 <span class="comment"># 用于访问 etcd 的客户端证书</span></span><br><span class="line">  --etcd-keyfile=/var/lib/kubernetes/kube-apiserver-etcd-client-key.pem \\              <span class="comment"># 用于访问 etcd 的客户端证书的私钥</span></span><br><span class="line">  --kubelet-client-certificate=/var/lib/kubernetes/kube-apiserver-kubelet-client.pem \\ <span class="comment"># 用于访问 kubelet 的客户端证书</span></span><br><span class="line">  --kubelet-client-key=/var/lib/kubernetes/kube-apiserver-kubelet-client-key.pem \\     <span class="comment"># 用于访问 kubelet 的客户端证书的私钥</span></span><br><span class="line">  --client-ca-file=/var/lib/kubernetes/cluster-root-ca.pem \\                           <span class="comment"># 用于验证访问 kube-apiserver 的客户端的证书的 CA 根证书</span></span><br><span class="line">  --etcd-cafile=/var/lib/kubernetes/cluster-root-ca.pem \\                              <span class="comment"># 用于验证 etcd 服务器证书的 CA 根证书  </span></span><br><span class="line">  --kubelet-certificate-authority=/var/lib/kubernetes/cluster-root-ca.pem \\            <span class="comment"># 用于验证 kubelet 服务器证书的 CA 根证书</span></span><br><span class="line">  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\                 <span class="comment"># 用于验证 service account token 的公钥</span></span><br><span class="line">  --token-auth-file=/etc/kubernetes/token.csv \\                                        <span class="comment"># 用于kubelet组件第一次启动时没有证书如何连接 apiserver，</span></span><br><span class="line">Token 和 apiserver 的 CA 证书被写入了 kubelet 所使用的 bootstrap.kubeconfig 配置文件中；这样在首次请求时，kubelet 使用 bootstrap.kubeconfig 中的 apiserver CA 证书来与 apiserver 建立 TLS 通讯，使用 bootstrap.kubeconfig 中的用户 Token 来向 apiserver 声明自己的 RBAC 授权身份</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h4 id="采用-kubeconfig-访问-kube-apiserver"><a href="#采用-kubeconfig-访问-kube-apiserver" class="headerlink" title="采用 kubeconfig 访问 kube-apiserver"></a>采用 kubeconfig 访问 kube-apiserver</h4><p>Kubernetes  中的各个组件，包括kube-controller-mananger、kube-scheduler、kube-proxy、kubelet等，采用一个kubeconfig 文件中配置的信息来访问 kube-apiserver。该文件中包含了 kube-apiserver 的地址，验证 kube-apiserver 服务器证书的 CA 证书，自己的客户端证书和私钥等访问信息。</p>
<p>在一个使用 minikube 安装的集群中，生成的 kubeconfig 配置文件如下所示，这四个文件分别为 admin 用户，  kube-controller-mananger、kubelet 和 kube-scheduler 的kubeconfig配置文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/kubernetes/</span><br><span class="line">admin.conf  controller-manager.conf  kubelet.conf  scheduler.conf</span><br></pre></td></tr></table></figure>
<p>打开controller-manager.conf</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster: </span><br><span class="line">    <span class="comment"># 用于验证 kube-apiserver 服务器证书的 CA 根证书 </span></span><br><span class="line">    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS…………………………</span><br><span class="line">    server: https://localhost:8443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: system:kube-controller-manager</span><br><span class="line">  name: system:kube-controller-manager@kubernetes</span><br><span class="line">current-context: system:kube-controller-manager@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: system:kube-controller-manager</span><br><span class="line">  user:</span><br><span class="line">    <span class="comment"># 用于访问 kube-apiserver 的客户端证书</span></span><br><span class="line">    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FU…………………………</span><br><span class="line">    <span class="comment"># 客户端证书对应的私钥</span></span><br><span class="line">    client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0t…………………………</span><br></pre></td></tr></table></figure>
<p>可以看到，访问 kube-apiserver 所需要的相关证书内容已经被采用 base64 编码写入了文件中。其他几个文件中的内容也是类似的，只是配置的用户名和客户端证书有所不同。</p>
<p>在启动这些组件时，需要在参数中指出 kubeconfig 文件的路径，例如 kube-controller-manager 的启动命令如下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/kube-controller-manager \\</span><br><span class="line"> --kubeconfig=/etc/kubernetes/controller-manager.conf </span><br><span class="line"> <span class="comment"># 下面几个证书和访问 kube-apiserver 无关，我们会在后面介绍到</span></span><br><span class="line"> --cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="comment"># 用于签发证书的 CA 根证书</span></span><br><span class="line"> --cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="comment"># 用于签发证书的 CA 根证书的私钥  </span></span><br><span class="line"> --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="comment"># 用于对 service account token 进行签名的私钥</span></span><br><span class="line"> ... </span><br></pre></td></tr></table></figure>
<h4 id="Service-Account证书"><a href="#Service-Account证书" class="headerlink" title="Service Account证书"></a>Service Account证书</h4><p>Kubernetes 中有两类用户，一类为 user account，一类为 service account。 service account  主要被 pod 用于访问 kube-apiserver。 在为一个 pod 指定了 service account 后，kubernetes  会为该 service account 生成一个 JWT token，并使用 secret 将该 service account token  加载到 pod 上。pod 中的应用可以使用 service account token 来访问 api server。service  account 证书被用于生成和验证 service account  token。该证书的用法和前面介绍的其他证书不同，因为实际上使用的是其公钥和私钥，而并不需要对证书进行验证。</p>
<p>可以看到 service account 证书的公钥和私钥分别被配置到了 kube-apiserver 和 kube-controller-manager 的命令行参数中，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/kube-apiserver \\ </span><br><span class="line">  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\          <span class="comment"># 用于验证 service account token 的公钥</span></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"> /usr/<span class="built_in">local</span>/bin/kube-controller-manager \\</span><br><span class="line"> --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="comment"># 用于对 service account token 进行签名的私钥</span></span><br><span class="line"> ... </span><br></pre></td></tr></table></figure>
<p>下图展示了kubernetes中生成、使用和验证service account token的过程</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/service-account-token.png" alt="service-account-token"></p>
<h4 id="Kubernetes-证书签发"><a href="#Kubernetes-证书签发" class="headerlink" title="Kubernetes 证书签发"></a>Kubernetes 证书签发</h4><p>Kubernetes 提供了一个 <code>certificates.k8s.io</code> API，可以使用配置的 CA  根证书来签发用户证书。该 API 由 kube-controller-manager  实现，其签发证书使用的根证书在下面的命令行中进行配置。我们希望 Kubernetes 采用集群根 CA 来签发用户证书，因此在  kube-controller-manager 的命令行参数中将相关参数配置为了集群根 CA。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/kube-controller-manager \\</span><br><span class="line">--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="comment"># 用于签发证书的 CA 根证书</span></span><br><span class="line">--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="comment"># 用于签发证书的 CA 根证书的私钥  </span></span><br><span class="line">... </span><br><span class="line">多是用来签发TLS-Bootstrapping的</span><br></pre></td></tr></table></figure>
<h2 id="TLS-bootstrapping"><a href="#TLS-bootstrapping" class="headerlink" title="TLS bootstrapping"></a>TLS bootstrapping</h2><h3 id="引导流程"><a href="#引导流程" class="headerlink" title="引导流程"></a>引导流程</h3><p>当集群开启了 TLS 认证后，每个节点的 kubelet 组件都要使用由 apiserver 使用的 CA 签发的有效证书才能与  apiserver 通讯；此时如果节点多起来，为每个节点单独签署证书将是一件非常繁琐的事情；TLS bootstrapping 功能就是让  kubelet 先使用一个预定的低权限用户连接到 apiserver，然后向 apiserver 申请证书，kubelet 的证书由  apiserver 动态签署；在配合 RBAC 授权模型下的工作流程大致如下所示(不完整，下面细说)</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/ixtwd.webp" alt="ixtwd"></p>
<p>kubelet启动时候向kube-apiserver进行认证过程：</p>
<ol>
<li><p>kubelet启动时查找配置的kubeconfig文件</p>
</li>
<li><p>从kubeconfig文件中得到apiserver的URL和认证信息(一般是TLS key和CA签发的证书)</p>
</li>
<li><p>使用认证信息向apiserver进行认证</p>
</li>
</ol>
<p>集群管理需要为kubelet做的事</p>
<ol>
<li><p>为kubernetes集群创建CA和CA-KEY</p>
</li>
<li><p>将CA和CA-KEY给kube-apiserver使用</p>
</li>
<li><p>为每个node的kubelet创建证书和key(强烈建议每个node使用唯一证书，并设置唯一CN)</p>
</li>
<li><p>使用CA-KEY签发kubelet的证书</p>
</li>
<li><p>将kubelet的证书给kubelet使用</p>
</li>
</ol>
<p><strong>TLS Bootstrapping旨在简化从第三步开始的步骤，因为这是每个kubelet都需要的。</strong></p>
<p>TLS Bootstrap初始化过程：</p>
<ol>
<li><p>kubelet进程启动</p>
</li>
<li><p>kubelet查找kubeconfig，没找到(因为没配置)</p>
</li>
<li><p>kubelet查找到bootstrap-kubeconfig文件</p>
</li>
<li><p>kubelet通过bootstrap-kubeconfig文件，查找到apiserver的URL和有限制权限的”token”，该”token”可以通过apiserver的认证，且只能向apiserver发送CSR请求</p>
</li>
<li><p>kubelet使用”token”向apiserver认证</p>
</li>
<li><p>kubelet现在有权限创建一个CSR并发给apiserver</p>
</li>
<li><p>kubelet创建一个key和cert，并使用cert创建一个带signerName=kubernetes.io/kube-apiserver-client-kubelet的CSR，并发送给apiserver</p>
</li>
<li><p>apiserver签发该CSR：</p>
<p>如果配置了自动签发，kube-controller-manager将会自动签发该CSR</p>
<p>可以使用集群外的程序或人使用kubectl或Kubernetes API进行签发</p>
</li>
<li><p>为kubelet签发证书(一般证书有效期为1年)</p>
</li>
<li><p>将签发好的证书分发给kubelet</p>
</li>
<li><p>kubelet得到签发的证书</p>
</li>
<li><p>kubelet使用key和签发的证书生成kubeconfig</p>
</li>
<li><p>kubelet现在可以正常与apiserver交互了</p>
</li>
<li><p>可选：如果配置了，kubelet将会在证书快过期的时候，自动发起新的CSR请求更新自己的证书</p>
</li>
<li><p>apiserver或手动或自动签发kubelet发送的更新证书的CSR请求</p>
</li>
</ol>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><h4 id="kubelet-server"><a href="#kubelet-server" class="headerlink" title="kubelet server"></a>kubelet server</h4><p>在官方 TLS bootstrapping 文档中多次提到过 <code>kubelet server</code> 这个东西；在经过翻阅大量文档以及 TLS bootstrapping 设计文档后得出，**<code>kubelet server</code> 指的应该是 kubelet 的 10250 端口；**</p>
<p><strong>kubelet 组件在工作时，采用主动的查询机制，即定期请求 apiserver 获取自己所应当处理的任务，如哪些 pod  分配到了自己身上，从而去处理这些任务；同时 kubelet 自己还会暴露出两个本身 api 的端口，用于将自己本身的私有 api  暴露出去，这两个端口分别是 10250 与 10255；对于 10250 端口，kubelet 会在其上采用 TLS  加密以提供适当的鉴权功能；对于 10255 端口，kubelet 会以只读形式暴露组件本身的私有 api，并且不做鉴权处理</strong></p>
<p><strong>总结一下，就是说 kubelet 上实际上有两个地方用到证书，一个是用于与 API server 通讯所用到的证书，另一个是 kubelet 的 10250 私有 api 端口需要用到的证书</strong></p>
<p><strong>注意：默认情况下，TLS bootstrap签发的证书仅用于client auth，出于安全考虑，不会用于server  auth。如果想要自动签发server证书，打开RotateKubeletServerCertificate特性，并且自己实现一个自动签发server证书的controller。但是，你也可以启动服务器证书，至少支持kubelet发送证书轮询请求，但是kube-controller-manager不能自动签发。</strong></p>
<h4 id="CSR-请求类型"><a href="#CSR-请求类型" class="headerlink" title="CSR 请求类型"></a>CSR 请求类型</h4><p>kubelet 发起的 CSR 请求都是由 controller manager 来做实际签署的，对于 controller manager 来说，TLS bootstrapping 下 kubelet 发起的 CSR 请求大致分为以下三种</p>
<ul>
<li>nodeclient: kubelet 以 <code>O=system:nodes</code> 和 <code>CN=system:node:(node name)</code> 形式发起的 CSR 请求</li>
<li>selfnodeclient: kubelet client renew 自己的证书发起的 CSR 请求(与上一个证书就有相同的 O 和 CN)</li>
<li>selfnodeserver: kubelet server renew 自己的证书发起的 CSR 请求</li>
</ul>
<p>大白话加自己测试得出的结果: nodeclient 类型的 CSR 仅在第一次启动时会产生，selfnodeclient 类型的 CSR 请求实际上就是 kubelet  renew 自己作为 client 跟 apiserver 通讯时使用的证书产生的，selfnodeserver 类型的 CSR 请求则是  kubelet 首次申请或后续 renew 自己的 10250 api 端口证书时产生的</p>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>Token格式：[a-z0-9]{6}.[a-z0-9]{16}</p>
<p>点号之前的是token ID，之后的是token Secret</p>
<p>如：abcdef.0123456789abcdef</p>
<p>权限</p>
<p>token认证的所使用的用户名是system:bootstrap:&lt;token id&gt;，属于system:bootstrappers组，可以在secret中的auth-extra-groups字段添加额外组</p>
<p>生成bootstrap-kubeconfig</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl config --embed-certs=<span class="literal">true</span> --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server=<span class="string">&#x27;https://192.168.81.10:6443&#x27;</span> --certificate-authority=/var/lib/kubernetes/ca.pem</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=10001.be31df5b85f4f55404b96bffe768562a</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap</span><br><span class="line"><span class="comment"># 将bootstrap-kubeconfig文件分发到kubelet上</span></span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h4><p>token由token-id和token-secret组成，id相当于用户名，secret相当于密码。</p>
<p>token-id由自己取一个，密码可以通过以下命令生成。</p>
<p>生成token密码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c 16 /dev/urandom | od -An -t x | tr -d <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="kube-apiserver配置"><a href="#kube-apiserver配置" class="headerlink" title="kube-apiserver配置"></a>kube-apiserver配置</h4><p>配置kube-apiserver参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--client-ca-file&#x3D;FILENAME</span><br></pre></td></tr></table></figure>
<p>该CA用于验证客户端证书的有效性。</p>
<ul>
<li><p>用于认证bootstrapping kubelet的组system:bootstrappers</p>
</li>
<li><p>批准CSR</p>
</li>
</ul>
<p>kube-apiserver启用token认证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--enable-bootstrap-token-auth</span><br></pre></td></tr></table></figure>
<p>方法一：Bootstrap Tokens Kubernetes <code>v1.18 [stable]</code></p>
<p>这是一种更加简单方便的认证方式。</p>
<p>创建包含token ID，token密码，作用范围的secret</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># Name MUST be of form &quot;bootstrap-token-&lt;token id&gt;&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bootstrap-token-07401b</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="comment"># Type MUST be &#x27;bootstrap.kubernetes.io/token&#x27;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">bootstrap.kubernetes.io/token</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line">  <span class="comment"># Human readable description. Optional.</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&quot;The default bootstrap token generated by &#x27;kubeadm init&#x27;.&quot;</span></span><br><span class="line">  <span class="comment"># Token ID and secret. Required.</span></span><br><span class="line">  <span class="attr">token-id:</span> <span class="string">&quot;07401b&quot;</span></span><br><span class="line">  <span class="attr">token-secret:</span> <span class="string">f395accd246ae52d</span></span><br><span class="line">  <span class="comment"># Expiration. Optional.</span></span><br><span class="line">  <span class="comment">#expiration: 2017-03-10T03:22:11Z</span></span><br><span class="line">  <span class="comment"># Allowed usages.</span></span><br><span class="line">  <span class="attr">usage-bootstrap-authentication:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">usage-bootstrap-signing:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="comment"># Extra groups to authenticate the token as. Must start with &quot;system:bootstrappers:&quot;  auth-extra-groups: system:bootstrappers:worker,system:bootstrappers:ingress</span></span><br></pre></td></tr></table></figure>
<p>Secret说明</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md</a></p>
<ul>
<li>type: bootstrap.kubernetes.io/token</li>
<li>name: bootstrap-token-&lt;token id&gt;</li>
<li>token-id: 自己定义的</li>
<li>token-secret: 自己生成</li>
<li>expiration: 过期时间</li>
<li>usage-bootstrap-signing: 为true时，表示允许这个token的请求签发bootstrap配置</li>
<li>usage-bootstrap-authentication: 这个token是否允许用于apiserver的认证</li>
<li>description(optional)： 描述信息</li>
<li>auth-groups(or auth-extra-groups?): 逗号分隔的认证组列表，必须以system:bootstrappers:开头</li>
<li>ConfigMap Signing</li>
</ul>
<p>方法二：Token authentication file</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file">https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file</a></p>
<p>生成token文件</p>
<p>如：<code>02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&quot;system:bootstrappers&quot;</code> token,user,uid,”group1,group2,group3”</p>
<p>kube-apiserver添加参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--token-auth-file&#x3D;FILENAME</span><br></pre></td></tr></table></figure>
<h4 id="配置bootstrapper有生成csr的权限"><a href="#配置bootstrapper有生成csr的权限" class="headerlink" title="配置bootstrapper有生成csr的权限"></a>配置bootstrapper有生成csr的权限</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">  --clusterrole=system:node-bootstrapper \</span><br><span class="line">  --user=kubelet-bootstrap</span><br></pre></td></tr></table></figure>
<h4 id="kube-controller-manager配置"><a href="#kube-controller-manager配置" class="headerlink" title="kube-controller-manager配置"></a>kube-controller-manager配置</h4><p>签发kubelet证书所用的ca和ca-key，这个ca应用和kube-apiserver中的–client-ca-file一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--cluster-signing-cert-file&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;kubernetes&#x2F;ca.pem&quot; </span><br><span class="line">--cluster-signing-key-file&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;kubernetes&#x2F;ca-key.pem&quot;</span><br></pre></td></tr></table></figure>
<p>在kubernetes 1.19中提供了更加细致的CA配置，仅供参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Csrsigning controller flags:</span><br><span class="line"></span><br><span class="line">      --cluster-signing-cert-file string                         Filename containing a PEM-encoded X509 CA certificate used to issue</span><br><span class="line">cluster-scoped certificates.  If specified, no more specific --cluster-signing-* flag may be specified.</span><br><span class="line">      --cluster-signing-duration duration                        The length of duration signed certificates will be given. (default 8</span><br><span class="line">760h0m0s)</span><br><span class="line">      --cluster-signing-key-file string                          Filename containing a PEM-encoded RSA or ECDSA private key used to s</span><br><span class="line">ign cluster-scoped certificates.  If specified, no more specific --cluster-signing-* flag may be specified.</span><br><span class="line">      --cluster-signing-kube-apiserver-client-cert-file string   Filename containing a PEM-encoded X509 CA certificate used to issue</span><br><span class="line">certificates for the kubernetes.io&#x2F;kube-apiserver-client signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set.</span><br><span class="line">      --cluster-signing-kube-apiserver-client-key-file string    Filename containing a PEM-encoded RSA or ECDSA private key used to s</span><br><span class="line">ign certificates for the kubernetes.io&#x2F;kube-apiserver-client signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set</span><br><span class="line">.</span><br><span class="line">      --cluster-signing-kubelet-client-cert-file string          Filename containing a PEM-encoded X509 CA certificate used to issue</span><br><span class="line">certificates for the kubernetes.io&#x2F;kube-apiserver-client-kubelet signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be</span><br><span class="line"> set.</span><br><span class="line">      --cluster-signing-kubelet-client-key-file string           Filename containing a PEM-encoded RSA or ECDSA private key used to s</span><br><span class="line">ign certificates for the kubernetes.io&#x2F;kube-apiserver-client-kubelet signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must no</span><br><span class="line">t be set.</span><br><span class="line">      --cluster-signing-kubelet-serving-cert-file string         Filename containing a PEM-encoded X509 CA certificate used to issue</span><br><span class="line">certificates for the kubernetes.io&#x2F;kubelet-serving signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set.</span><br><span class="line">      --cluster-signing-kubelet-serving-key-file string          Filename containing a PEM-encoded RSA or ECDSA private key used to s</span><br><span class="line">ign certificates for the kubernetes.io&#x2F;kubelet-serving signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set.</span><br><span class="line">      --cluster-signing-legacy-unknown-cert-file string          Filename containing a PEM-encoded X509 CA certificate used to issue</span><br><span class="line">certificates for the kubernetes.io&#x2F;legacy-unknown signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set.</span><br><span class="line">      --cluster-signing-legacy-unknown-key-file string           Filename containing a PEM-encoded RSA or ECDSA private key used to s</span><br><span class="line">ign certificates for the kubernetes.io&#x2F;legacy-unknown signer.  If specified, --cluster-signing-&#123;cert,key&#125;-file must not be set.</span><br></pre></td></tr></table></figure>
<p>看个实践的例子</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl versionClient Version: version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;19&quot;</span>, GitVersion:<span class="string">&quot;v1.19.0&quot;</span>, GitCommit:<span class="string">&quot;e19964183377d0ec2052d1f1fa930c4d7575bd50&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2020-09-04T02:07:01Z&quot;</span>, GoVersion:<span class="string">&quot;go1.15&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;Server Version: version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;19&quot;</span>, GitVersion:<span class="string">&quot;v1.19.0&quot;</span>, GitCommit:<span class="string">&quot;e19964183377d0ec2052d1f1fa930c4d7575bd50&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2020-09-04T02:07:01Z&quot;</span>, GoVersion:<span class="string">&quot;go1.15&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;</span><br><span class="line">$ kubectl get csr</span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR                      CONDITION</span><br><span class="line">csr-9d7qd   0s    kubernetes.io/kubelet-serving                 system:node:k8s00.99bill.com   Pending  <span class="comment">#没有手工签发前的server证书csr</span></span><br><span class="line">csr-qzbmz   8s    kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:07401b        Approved,Issued <span class="comment"># client证书csr</span></span><br><span class="line">$ kubectl certificate approve csr-9d7qd</span><br><span class="line">certificatesigningrequest.certificates.k8s.io/csr-9d7qd approved</span><br><span class="line">$ kubectl get csr</span><br><span class="line">NAME        AGE   SIGNERNAME                                    REQUESTOR                      CONDITION</span><br><span class="line">csr-9d7qd   43s   kubernetes.io/kubelet-serving                 system:node:k8s00.99bill.com   Approved,Issued</span><br><span class="line">csr-qzbmz   51s   kubernetes.io/kube-apiserver-client-kubelet   system:bootstrap:07401b        Approved,Issued</span><br></pre></td></tr></table></figure>
<p>证书有效期参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster-signing-duration</span><br></pre></td></tr></table></figure>
<p>自动续签证书请求参数（默认开启）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--feature-gates&#x3D;RotateKubeletServerCertificate&#x3D;true</span><br></pre></td></tr></table></figure>
<p>(可选)自动删除过期token，在controller-manager添加参数,tokencleaner控制器负责这个工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--controllers&#x3D;*,tokencleaner(默认开启)</span><br></pre></td></tr></table></figure>
<p>签发证书配置：</p>
<p>为了批准csr，您需要告诉controller-manager批准它们是可以接受的。这是通过将RBAC权限授予正确的组来实现的。</p>
<h4 id="配置证书自动签发权限"><a href="#配置证书自动签发权限" class="headerlink" title="配置证书自动签发权限"></a>配置证书自动签发权限</h4><p>证书签发有CSR approving controllers实现，自动签发只针对client证书。</p>
<p>创建clusterrole</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A ClusterRole which instructs the CSR approver to approve a user requesting</span></span><br><span class="line"><span class="comment"># node client credentials.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:certificates.k8s.io:certificatesigningrequests:nodeclient</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests/nodeclient&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># A ClusterRole which instructs the CSR approver to approve a node renewing its</span></span><br><span class="line"><span class="comment"># own client credentials.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests/selfnodeclient&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>创建clusterrolebinding</p>
<p>自动批准 kubelet 的首次 CSR 请求(用于与 apiserver 通讯的证书)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding auto-approve-csrs-for-group --clusterrole=system:certificates.k8s.io:certificatesigningrequests:nodeclient --group=system:bootstrappers</span><br></pre></td></tr></table></figure>
<p>自动批准 kubelet 后续 renew 用于与 apiserver 通讯证书的 CSR 请求</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding auto-approve-renewals-for-nodes --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeclient --group=system:nodes</span><br></pre></td></tr></table></figure>
<p>自动批准 kubelet 发起的用于 10250 端口鉴权证书的 CSR 请求(包括后续 renew)(下面用到的clusterrole是不会默认创建的，需要手工创建一下)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A ClusterRole which instructs the CSR approver to approve a node requesting a</span></span><br><span class="line"><span class="comment"># serving cert matching its client cert.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">approve-node-server-renewal-csr</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;certificates.k8s.io&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;certificatesigningrequests/selfnodeserver&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding node-server-auto-renew-crt --clusterrole=approve-node-server-renewal-csr --group=system:nodes</span><br></pre></td></tr></table></figure>
<h4 id="kubelet配置"><a href="#kubelet配置" class="headerlink" title="kubelet配置"></a>kubelet配置</h4><p>kubelet加参数启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--feature-gates&#x3D;RotateKubeletClientCertificate&#x3D;true,RotateKubeletServerCertificate&#x3D;true(1.12后默认开启)</span><br><span class="line">--rotate-certificates</span><br><span class="line">--rotate-server-certificates</span><br><span class="line">--bootstrap-kubeconfig&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;bootstrap-kubeconfig&quot; </span><br><span class="line">--kubeconfig&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeconfig&quot;</span><br></pre></td></tr></table></figure>
<p>kubelet配置bootstrap需要以下东西：</p>
<p>存储签发好的证书的路径(可以使用默认/var/lib/kubelet/pki)</p>
<p>存放kubeconfig文件的路径(kubeconfig还不存在)</p>
<p>bootstrap kubeconfig文件</p>
<p>(可选)rotate证书</p>
<p>当kubelet启动时，如果kubeconfig文件不存在，将使用bootstrap-kubeconfig文件</p>
<p>获取到的证书将放在<code>--cert-dir</code>路径下</p>
<h4 id="证书自动续期"><a href="#证书自动续期" class="headerlink" title="证书自动续期"></a>证书自动续期</h4><p>默认情况下kube-apiserver签发的证书有效期1年，当然可以调整kube-controller-manager参数<code>--cluster-signing-duration</code>(早期版本是<code>--experimental-cluster-signing-duration</code>)修改有效期，但是生产环境不建议将时间修改得太长。</p>
<p>kubelet开启client证书轮询：<code>--rotate-certificates</code></p>
<p>kubelet开启server证书轮询：<code>--rotate-server-certificates</code></p>
<p>开启了参数之后，kubelet在证书将要到期的时候会向kube-apiserver发送续签证书请求。</p>
<p>该功能需要kubelet开启特性RotateKubeletClientCertificate(beta默认开始) 和 RotateKubeletServerCertificate(beta默认开启)</p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tls/certificate-rotation/">https://kubernetes.io/docs/tasks/tls/certificate-rotation/</a></p>
<blockquote>
<p>注意：由于安全原因，在Kubernetes核心中实现的CSR审批控制器不审批节点serving证书。要使用RotateKubeletServerCertificate，需要运行自定义的审批控制器，或手动审批提供服务的证书请求。</p>
</blockquote>
<p>RBAC 中 ClusterRole 只是描述或者说定义一种集群范围内的能力，这三个 ClusterRole 在 1.7  之前需要自己手动创建，在 1.8 后 apiserver 会自动创建前两个(1.8 以后名称有改变，自己查看文档)；以上三个  ClusterRole 含义如下</p>
<ul>
<li>approve-node-client-csr: 具有自动批准 nodeclient 类型 CSR 请求的能力</li>
<li>approve-node-client-renewal-csr: 具有自动批准 selfnodeclient 类型 CSR 请求的能力</li>
<li>approve-node-server-renewal-csr: 具有自动批准 selfnodeserver 类型 CSR 请求的能力</li>
</ul>
<p><strong>所以，如果想要 kubelet 能够自动续期，那么就应当将适当的 ClusterRole 绑定到 kubelet 自动续期时所采用的用户或者用户组身上</strong></p>
<p>在自动续期下引导过程与单纯的手动批准 CSR 有点差异，具体的引导流程地址如下</p>
<ul>
<li>kubelet 读取 bootstrap.kubeconfig，使用其 CA 与 Token 向 apiserver 发起第一次 CSR 请求(nodeclient)</li>
<li>apiserver 根据 RBAC 规则自动批准首次 CSR 请求(approve-node-client-csr)，并下发证书(kubelet-client.crt)</li>
<li>kubelet **使用刚刚签发的证书(O=system:nodes, CN=system:node:NODE_NAME)**与 apiserver 通讯，并发起申请 10250 server 所使用证书的 CSR 请求</li>
<li>apiserver 根据 RBAC 规则自动批准 kubelet 为其 10250 端口申请的证书(kubelet-server-current.crt)</li>
<li>证书即将到期时，kubelet 自动向 apiserver 发起用于与 apiserver 通讯所用证书的 renew CSR 请求和 renew 本身 10250 端口所用证书的 CSR 请求</li>
<li>apiserver 根据 RBAC 规则自动批准两个证书</li>
<li>kubelet 拿到新证书后关闭所有连接，reload 新证书，以后便一直如此</li>
</ul>
<p><strong>从以上流程我们可以看出，我们如果要创建 RBAC 规则，则至少能满足四种情况:</strong></p>
<ul>
<li>自动批准 kubelet 首次用于与 apiserver 通讯证书的 CSR 请求(nodeclient)</li>
<li>自动批准 kubelet 首次用于 10250 端口鉴权的 CSR 请求(实际上这个请求走的也是 selfnodeserver 类型 CSR)</li>
<li>自动批准 kubelet 后续 renew 用于与 apiserver 通讯证书的 CSR 请求(selfnodeclient)</li>
<li>自动批准 kubelet 后续 renew 用于 10250 端口鉴权的 CSR 请求(selfnodeserver)</li>
</ul>
<h3 id="证书及配置文件作用"><a href="#证书及配置文件作用" class="headerlink" title="证书及配置文件作用"></a>证书及配置文件作用</h3><ul>
<li>token.csv</li>
</ul>
<p>该文件为一个用户的描述文件，基本格式为 <code>Token,用户名,UID,用户组</code>；这个文件在 apiserver 启动时被 apiserver 加载，然后就相当于在集群内创建了一个这个用户；接下来就可以用 RBAC  给他授权；持有这个用户 Token 的组件访问 apiserver 的时候，apiserver 根据 RBAC  定义的该用户应当具有的权限来处理相应请求</p>
<ul>
<li>bootstarp.kubeconfig</li>
</ul>
<p>该文件中内置了 token.csv 中用户的 Token，以及 apiserver CA 证书；kubelet 首次启动会加载此文件，使用 apiserver CA 证书建立与 apiserver 的 TLS 通讯，使用其中的用户 Token 作为身份标识像 apiserver 发起 CSR 请求</p>
<ul>
<li>kubelet-client.crt</li>
</ul>
<p>该文件在 kubelet 完成 TLS bootstrapping 后生成，此证书是由 controller manager 签署的，此后  kubelet 将会加载该证书，用于与 apiserver 建立 TLS 通讯，同时使用该证书的 CN 字段作为用户名，O 字段作为用户组向  apiserver 发起其他请求</p>
<ul>
<li>kubelet.crt</li>
</ul>
<p>该文件在 kubelet 完成 TLS bootstrapping 后并且<strong>没有配置 <code>--feature-gates=RotateKubeletServerCertificate=true</code> 时才会生成</strong>；这种情况下该文件为一个独立于 apiserver CA 的自签 CA 证书，有效期为 1 年；被用作 kubelet 10250 api 端口，删除后 kubelet 组件会重新生成它</p>
<ul>
<li>kubelet-server.crt</li>
</ul>
<p>该文件在 kubelet 完成 TLS bootstrapping 后并且<strong>配置了 <code>--feature-gates=RotateKubeletServerCertificate=true</code> 时才会生成</strong>；这种情况下该证书由 apiserver CA 签署，默认有效期同样是 1 年，被用作 kubelet 10250 api 端口鉴权</p>
<ul>
<li>kubelet-client-current.pem</li>
</ul>
<p>这是一个软连接文件，当 kubelet 配置了 <code>--feature-gates=RotateKubeletClientCertificate=true</code> 选项后，会在证书总有效期的 <code>70%~90%</code> 的时间内发起续期请求，请求被批准后会生成一个 <code>kubelet-client-时间戳.pem</code>；<code>kubelet-client-current.pem</code> 文件则始终软连接到最新的真实证书文件，除首次启动外，kubelet 一直会使用这个证书同 apiserver 通讯</p>
<ul>
<li>kubelet-server-current.pem</li>
</ul>
<p>同样是一个软连接文件，当 kubelet 配置了 <code>--feature-gates=RotateKubeletServerCertificate=true</code> 选项后，会在证书总有效期的 <code>70%~90%</code> 的时间内发起续期请求，请求被批准后会生成一个 <code>kubelet-server-时间戳.pem</code>；<code>kubelet-server-current.pem</code> 文件则始终软连接到最新的真实证书文件，该文件将会一直被用于 kubelet 10250 api 端口鉴权</p>
<h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><p>kubeconfig 是用来访问 k8s 集群的凭证，生成 kubeconfig 的步骤很简单但参数很多，这里以生成 admin 的 kubeconfig 为例，解释各参数的含义。</p>
<h3 id="生成最高权限的-kubeconfig"><a href="#生成最高权限的-kubeconfig" class="headerlink" title="生成最高权限的 kubeconfig"></a>生成最高权限的 kubeconfig</h3><p>一般情况下集群创建之后，会先生成一份最高权限的 kubeconfig，即管理员角色，可以操作集群的所有资源，并为其他用户创建或删除权限，可以称之为 admin 证书，生成方式是：</p>
<p><strong>admin-csr.json</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;CN&quot;</span>: <span class="string">&quot;kubernetes-admin&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hosts&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;172.18.0.1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;100.64.230.122&quot;</span>,</span><br><span class="line">      <span class="string">&quot;100.75.187.77&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;algo&quot;</span>: <span class="string">&quot;rsa&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;C&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ST&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;L&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;O&quot;</span>: <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;OU&quot;</span>: <span class="string">&quot;cloudnative&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>admin 证书</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=demo admin-csr.json | cfssljson -bare admin</span><br></pre></td></tr></table></figure>
<p>生成 admin.conf，即最高权限的 kubeconfig</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置kubernetes集群参数</span></span><br><span class="line"></span><br><span class="line">kubectl config set-cluster kubernetes \</span><br><span class="line">  --certificate-authority=/etc/kubernetes/pki/ca.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --server=https://vip:6443 \</span><br><span class="line">  --kubeconfig=admin.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置客户端认证参数</span></span><br><span class="line">kubectl config set-credentials kubernetes-admin \</span><br><span class="line">  --client-certificate=/etc/kubernetes/pki/admin.pem \</span><br><span class="line">  --embed-certs=<span class="literal">true</span> \</span><br><span class="line">  --client-key=/etc/kubernetes/pki/admin-key.pem \</span><br><span class="line">  --kubeconfig=admin.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置上下文参数 </span></span><br><span class="line">kubectl config set-context kubernetes-admin@kubernetes \</span><br><span class="line">  --cluster=kubernetes \</span><br><span class="line">  --user=kubernetes-admin \</span><br><span class="line">  --kubeconfig=admin.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认上下文</span></span><br><span class="line">kubectl config use-context kubernetes-admin@kubernetes --kubeconfig=admin.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 kubeconfig 拷贝到默认路径~/.kube/下，这是 kubectl 命令寻找 kubeconfig 时的默认路径</span></span><br><span class="line"><span class="comment"># 也可以在 kubectl 中手动指定 kubeconfig 文件。如 kubectl --kubeconfig=zhangsan.conf get cs </span></span><br><span class="line">mkdir -p ~/.kube; cp admin.conf ~/.kube/config`</span><br></pre></td></tr></table></figure>
<h4 id="集群参数"><a href="#集群参数" class="headerlink" title="集群参数"></a>集群参数</h4><p>本段设置了所需要访问的集群的信息。</p>
<ul>
<li>使用 set-cluster 设置了需要访问的集群，如上为 kubernetes 这只是个名称，实际为 –server 指向的 apiserver 所在的集群</li>
<li>–certificate-authority 设置了该集群的公钥</li>
<li>–embed-certs 为 true 表示将 –certificate-authority 证书写入到 kubeconfig 中</li>
<li>–server 则表示该集群的 apiserver 地址</li>
</ul>
<h4 id="用户参数"><a href="#用户参数" class="headerlink" title="用户参数"></a>用户参数</h4><p>本段主要设置用户的相关信息，主要是用户证书。</p>
<ul>
<li>用户名: zhangsan</li>
<li>证书: /etc/kubernetes/ssl/zhangsan.pem</li>
<li>私钥: /etc/kubernetes/ssl/zhangsan-key.pem</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=demo zhangsan.json | cfssljson -bare zhangsan</span><br><span class="line"></span><br><span class="line">得到：</span><br><span class="line"></span><br><span class="line">* zhangsan.pem</span><br><span class="line">* zhangsan-key.pem</span><br></pre></td></tr></table></figure>
<p>这一步操作是指客户端的证书首先要经过集群 CA 的签署，否则不会被集群认可，认证就失败。</p>
<p>此处使用的是 客户端 x509 认证方式，也可以使用token认证，如kubelet的 TLS Boostrap机制下的bootstrapping 使用的就是 token 认证方式</p>
<h4 id="上下文参数"><a href="#上下文参数" class="headerlink" title="上下文参数"></a>上下文参数</h4><p>集群参数和用户参数可以同时设置多对，而上下文参数就是集群参数和用户参数关联起来。</p>
<p>上面的上下文名称为 kubenetes，集群为 kubenetes(apiserver 地址对应的集群)，用户为zhangsan，表示使用 zhangsan 的用户凭证来访问 kubenetes 集群</p>
<p>最后使用 <code>kubectl config use-context kubernetes</code> 来使用名为 kubenetes 的环境项来作为配置。</p>
<p>如果配置了多个环境项，可以通过切换不同的环境项名字来访问到不同的集群环境。</p>
<h3 id="kubeconfig-的认证过程"><a href="#kubeconfig-的认证过程" class="headerlink" title="kubeconfig 的认证过程"></a>kubeconfig 的认证过程</h3><p>正向生成 kubeconfig 我们已经做完了，apiserver 认证请求时，如何解析 kubeconfig 文件的内容呢？</p>
<p>我们可以看下 kubeconfig 的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: REDACTED</span><br><span class="line">    server: https://xx:6443</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetes</span><br><span class="line">current-context: kubernetes-admin@kubernetes</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure>
<p>除了 context，里面有三个证书字段，都是 base64 编码后的内容</p>
<ul>
<li>certificate-authority-data: server 端的证书，用于验证 apiserver 的合法性</li>
<li>client-certificate-data: 客户端证书</li>
<li>client-key-data: 客户端私钥</li>
</ul>
<p>可以提取出来 certificate-authority-data 的内容放到一个文件cert.txt，然后base64解码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cert.txt | base64 -d </span><br></pre></td></tr></table></figure>
<p>certificate-authority-data：</p>
<p>得到的内容其实就是 ca.pem 即服务端证书，apiserver 的证书也是基于ca.pem签发，因为 TLS  是双向认证，apiserver 在认证 kubectl请求时，kubectl 也需要验证 apiserver  的证书，防止中间人攻击，验证的字段就是certificate-authority-data</p>
<p>client-certificate：</p>
<p>因为 k8s 没有 user 这种资源，因此在使用 kubeconfig 访问时，身份信息就“隐藏”在client-certificate的数据中，我们来查看一下。</p>
<p>将 kubeconfig 中的client-certificate-data的内容放在一个文件 client.txt 中，然后解码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat client.txt | base64 -d &gt; admin.pem</span><br></pre></td></tr></table></figure>
<p>查看证书内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl certinfo -cert admin.pem</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;subject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;common_name&quot;</span>: <span class="string">&quot;kubernetes-admin&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;organization&quot;</span>: <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;organizational_unit&quot;</span>: <span class="string">&quot;cloudnative&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;locality&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:masters&quot;</span>,</span><br><span class="line">      <span class="string">&quot;cloudnative&quot;</span>,</span><br><span class="line">      <span class="string">&quot;kubernetes-admin&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;issuer&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;common_name&quot;</span>: <span class="string">&quot;kubernetes&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;country&quot;</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;organization&quot;</span>: <span class="string">&quot;k8s&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;organizational_unit&quot;</span>: <span class="string">&quot;cloudnative&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;locality&quot;</span>: <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;province&quot;</span>: <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;names&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Jiangsu&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Wuxi&quot;</span>,</span><br><span class="line">      <span class="string">&quot;k8s&quot;</span>,</span><br><span class="line">      <span class="string">&quot;cloudnative&quot;</span>,</span><br><span class="line">      <span class="string">&quot;kubernetes&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;serial_number&quot;</span>: <span class="string">&quot;566012679603493454812450131987428233530903130206&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sans&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;172.18.0.1&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;not_before&quot;</span>: <span class="string">&quot;2020-06-25T01:50:00Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;not_after&quot;</span>: <span class="string">&quot;2030-06-23T01:50:00Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sigalg&quot;</span>: <span class="string">&quot;SHA256WithRSA&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authority_key_id&quot;</span>: <span class="string">&quot;DA:2B:A9:AE:AA:89:19:B7:0D:5F:FA:8B:1C:2D:EE:5D:EB:6E:D5:CB&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;subject_key_id&quot;</span>: <span class="string">&quot;FC:38:3A:C0:A4:E9:A6:41:16:24:AA:E6:1C:9C:7F:46:EF:42:61:08&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;pem&quot;</span>: xxx</span><br></pre></td></tr></table></figure>
<p>从输出内容可以看到Subject: organization=system:masters, common_name=kubernetes-admin</p>
<p>apiserver 验证、解析请求，得到 system:masters 的http上下文信息，并传给后续的authorizers来做权限校验。</p>
<h3 id="O-和-CN-的含义"><a href="#O-和-CN-的含义" class="headerlink" title="O 和 CN 的含义"></a>O 和 CN 的含义</h3><p>“O”：Organization, apiserver接到请求后从证书中提取该字段作为请求用户所属的组 (Group)<br> “CN”：Common Name，apiserver从证书中提取该字段作为请求的用户名 (User Name)</p>
<p>在admin-csr.json中， admin使用了system:masters作为组 (Group)</p>
<p>k8s 预定义了 RoleBinding:cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予了调用 k8s 相关 API 的权限，权限极高。</p>
<p>即：</p>
<ul>
<li>Group: system:masters</li>
<li>ClusterRole: cluster-admin</li>
<li>ClusterRoleBinding: cluster-admin</li>
</ul>
<h3 id="k8s-核心组件的默认权限"><a href="#k8s-核心组件的默认权限" class="headerlink" title="k8s 核心组件的默认权限"></a>k8s 核心组件的默认权限</h3><ul>
<li>admin权限： system:masters组，clusterrole 和 rolebinding 都叫 cluster-admin</li>
<li>kubelet: system:nodes组，clusterrole  和 rolebinding 都叫system:nodes，下同</li>
<li>kube-proxy: system:kube-proxy组</li>
<li>scheduler: system:kube-scheduler组</li>
<li>controller-manager: system:kube-controller-manager组</li>
</ul>
<h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><p>在Kubernetes中，授权作为一个独立的步骤。根据所有授权策略匹配请求资源属性，决定允许或拒绝请求。</p>
<p><strong>授权包括六种方式：</strong>AlwaysDeny、AlwaysAllow、ABAC、RBAC、Webhook、Node。配置多个授权时，将按顺序检查每个授权，任何一个匹配的授权策略允许或拒绝请求时，则立即返回该决定，并且不会再检查其他授权策略；所有授权策略都没有允许或拒绝时，最终则拒绝该请求。</p>
<p>通过设置apiserver配置参数（–authorization-mode）启用授权插件。启用多个时，以逗号分隔。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--authorization-mode&#x3D;AlwaysAllow,AlwaysDeny,ABAC,Webhook,RBAC,Node</span><br></pre></td></tr></table></figure>
<p>启用多个授权时，授权验证顺序由配置参数中的顺序决定。</p>
<p>本文仅对ServiceAccount做详细分析</p>
<p>在讲ServiceAccount之前，首先需要了解一下Secret</p>
<h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>Secret有三种类型</p>
<ul>
<li>Opaque：base64编码格式的Secret，用来存储密码、密钥等；但数据也通过base64 –decode解码得到原始数据，所以加密性很弱。</li>
<li>kubernetes.io/dockerconfigjson：用来存储私有docker registry的认证信息。</li>
<li>kubernetes.io/service-account-token： 用于被serviceaccount引用。serviceaccout创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod目录/run/secrets/ kubernetes.io/serviceaccount中。</li>
</ul>
<p><strong>Opaque Secret</strong></p>
<p>Opaque类型的数据是一个map类型，要求value是base64编码格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;admin&quot;</span> | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;1f2d1e2e67df&quot;</span> | base64</span><br><span class="line">MWYyZDFlMmU2N2Rm</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">secrets.yml</span></span><br><span class="line"><span class="string">-----------</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MWYyZDFlMmU2N2Rm</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br></pre></td></tr></table></figure>
<p>创建secret：<code>kubectl create -f secrets.yml</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get secret</span></span><br><span class="line">NAME                  	   TYPE                                  		DATA      AGE</span><br><span class="line">default-token-cty7p   	kubernetes.io/service-account-token   	3         45d</span><br><span class="line">mysecret              	  Opaque                                	   	2         7s</span><br></pre></td></tr></table></figure>
<p>注意：其中default-token-cty7p为创建集群时默认创建的secret，被serviceacount/default引用。</p>
<p>如果是从文件创建secret，则可以用更简单的kubectl命令，比如创建tls的secret：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret generic helloworld-tls \</span><br><span class="line">  --from-file=key.pem \</span><br><span class="line">  --from-file=cert.pem</span><br></pre></td></tr></table></figure>
<p><strong>Opaque Secret的使用</strong></p>
<p>创建好secret之后，有以下方式来使用它：</p>
<ul>
<li><p>以Volume方式</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/my_project_id/pg:v1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;/etc/secrets&quot;</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cp</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">5432</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">5432</span></span><br></pre></td></tr></table></figure>
<p>查看pod中对应的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /etc/secrets</span></span><br><span class="line">password  username</span><br><span class="line"><span class="comment"># cat  /etc/secrets/username</span></span><br><span class="line">admin</span><br><span class="line"><span class="comment"># cat  /etc/secrets/password</span></span><br><span class="line">1f2d1e2e67df</span><br></pre></td></tr></table></figure></li>
<li><p>以环境变量方式</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">wordpress-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">wordpress</span></span><br><span class="line">        <span class="attr">visualize:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;wordpress&quot;</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&quot;wordpress&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_USER</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WORDPRESS_DB_PASSWORD</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">secretKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">mysecret</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure>
<p>将Secret挂载指定的key</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">mysecret</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">password</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">511</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">tst/psd</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">username</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">511</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">tst/usr</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">&quot;/etc/secrets&quot;</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cp</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">5432</span></span><br></pre></td></tr></table></figure>
<p>创建Pod成功后，可以在对应的目录看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl exec db ls /etc/secrets/tst </span></span><br><span class="line">psd</span><br><span class="line">usr</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>kubernetes.io/dockerconfigjson</strong></p>
<p>可以直接用kubectl命令来创建用于docker registry认证的secret：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret docker-registry myregistrykey </span><br><span class="line">--docker-server=DOCKER_REGISTRY_SERVER</span><br><span class="line"> --docker-username=DOCKER_USER </span><br><span class="line"> --docker-password=DOCKER_PASSWORD </span><br><span class="line"> --docker-email=DOCKER_EMAIL</span><br><span class="line"> </span><br><span class="line">secret <span class="string">&quot;myregistrykey&quot;</span> created.</span><br></pre></td></tr></table></figure>
<p>查看secret的内容</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get secret myregistrykey  -o yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.dockercfg:</span> <span class="string">eyJjY3IuY2NzLnRlbmNlbnR5dW4uY29tL3RlbmNlbnR5dW4iOnsidXNlcm5hbWUiOiIzMzIxMzM3OTk0IiwicGFzc3dvcmQiOiIxMjM0NTYuY29tIiwiZW1haWwiOiIzMzIxMzM3OTk0QHFxLmNvbSIsImF1dGgiOiJNek15TVRNek56azVORG94TWpNME5UWXVZMjl0In19</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="number">2017-08-04T02:06:05Z</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;1374279324&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/secrets/myregistrykey</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">78f6a423-78b9-11e7-a70a-525400bc11f0</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/dockercfg</span></span><br></pre></td></tr></table></figure>
<p>也可以直接读取~/.dockercfg的内容来创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret docker-registry myregistrykey \</span><br><span class="line">  --from-file=<span class="string">&quot;~/.dockercfg&quot;</span></span><br></pre></td></tr></table></figure>
<p>在创建Pod的时候，通过imagePullSecrets来引用刚创建的myregistrykey:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">janedoe/awesomeapp:v1</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br></pre></td></tr></table></figure>
<p><strong>kubernetes.io/service-account-token</strong></p>
<p>用于被serviceaccount引用。serviceaccout创建时Kubernetes会默认创建对应的secret。Pod如果使用了serviceaccount，对应的secret会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run nginx --image nginx</span><br><span class="line">deployment <span class="string">&quot;nginx&quot;</span> created</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME                     READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-3137573019-md1u2   1/1       Running   0          13s</span><br><span class="line">$ kubectl <span class="built_in">exec</span> nginx-3137573019-md1u2 ls /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">ca.crt</span><br><span class="line">namespace</span><br><span class="line">token</span><br></pre></td></tr></table></figure>
<p>Secret与ConfigMap对比</p>
<p>相同点：</p>
<ul>
<li>key/value的形式</li>
<li>属于某个特定的namespace</li>
<li>可以导出到环境变量</li>
<li>可以通过目录/文件形式挂载(支持挂载所有key和部分key)</li>
</ul>
<p>不同点：</p>
<ul>
<li>Secret可以被ServerAccount关联(使用)</li>
<li>Secret可以存储register的鉴权信息，用在ImagePullSecret参数中，用于拉取私有仓库的镜像</li>
<li>Secret支持Base64加密</li>
<li>Secret分为kubernetes.io/Service Account，kubernetes.io/dockerconfigjson，Opaque三种类型,Configmap不区分类型</li>
<li>Secret文件存储在tmpfs文件系统中，Pod删除后Secret文件也会对应的删除。</li>
</ul>
<h2 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h2><p>首先Kubernetes中账户区分为：User Accounts（用户账户） 和 Service Accounts（服务账户） 两种，它们的设计及用途如下：</p>
<ul>
<li><p>UserAccount是给kubernetes集群外部用户使用的，例如运维或者集群管理人员，使用kubectl命令时用的就是UserAccount账户；UserAccount是全局性。在集群所有namespaces中，名称具有唯一性，默认情况下用户为admin；</p>
<p>用户名称可以在kubeconfig中查看</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos8 ~]<span class="comment"># cd ~/.kube/</span></span><br><span class="line">[root@Centos8 .kube]<span class="comment"># cat config</span></span><br><span class="line">    users:</span><br><span class="line">    - name: kubernetes-admin</span><br></pre></td></tr></table></figure>
<ul>
<li>ServiceAccount是给运行在Pod的程序使用的身份认证，Pod容器的进程需要访问API  Server时用的就是ServiceAccount账户；ServiceAccount仅局限它所在的namespace，每个namespace都会自动创建一个default service account；创建Pod时，如果没有指定Service Account，Pod则会使用default Service  Account。</li>
</ul>
<p>Kubernetes区分普通帐户（user accounts）和服务帐户（service accounts）的原因</p>
<ul>
<li>普通帐户是针对（人）用户的，服务账户针对Pod进程。</li>
<li>普通帐户是全局性。在集群所有namespaces中，名称具有唯一性。</li>
<li>通常，群集的普通帐户可以与企业数据库同步，新的普通帐户创建需要特殊权限。服务账户创建目的是更轻量化，允许集群用户为特定任务创建服务账户。</li>
<li>普通帐户和服务账户的审核注意事项不同。</li>
<li>对于复杂系统的配置包，可以包括对该系统的各种组件的服务账户的定义。</li>
</ul>
<h3 id="Token-Controller"><a href="#Token-Controller" class="headerlink" title="Token Controller"></a>Token Controller</h3><p>TokenController作为controller-manager的一部分运行。异步行为:</p>
<ul>
<li>观察serviceAccount的创建，并创建一个相应的Secret 来允许API访问。</li>
<li>观察serviceAccount的删除，并删除所有相应的ServiceAccountToken Secret</li>
<li>观察secret 添加，并确保关联的ServiceAccount存在，并在需要时向secret 中添加一个Token。</li>
<li>观察secret 删除，并在需要时对应 ServiceAccount 的关联</li>
</ul>
<p>需要使用<code>–service-account-private-key-file</code>参数选项将Service Account  密匙（key）文件传递给controller-manager中的Token controller。key用于 Service Account  Token签名。同样，也需要使用<code>–service-account-key-file</code> 参数选项将相应的（public  key）公匙传递给kube-apiserver ，公钥用于在认证期间验证Token。</p>
<h3 id="Service-Account-Controller"><a href="#Service-Account-Controller" class="headerlink" title="Service Account Controller"></a>Service Account Controller</h3><p>Service Account Controller在namespaces里管理ServiceAccount，并确保每个有效的namespaces中都存在一个名为“default”的ServiceAccount。</p>
<p>Service Account 用来访问 kubernetes API，通过 kubernetes API 创建和管理，每个 account  只能在一个 namespace 上生效，存储在 kubernetes API 中的 Secrets 资源。kubernetes  会默认创建，并且会自动挂载到 Pod 中的 /run/secrets/kubernetes.io/serviceaccount 目录下。<br> Service account是为了方便Pod里面的进程调用Kubernetes API或其他外部服务而设计的。它与User account不同：</p>
<ul>
<li>User account是为人设计的，而service account则是为Pod中的进程调用Kubernetes API而设计；</li>
<li>User account是跨namespace的，而service account则是仅局限它所在的namespace；</li>
<li>每个namespace都会自动创建一个default service account</li>
<li>Token controller检测service account的创建，并为它们创建secret</li>
<li>开启ServiceAccount Admission Controller后<ul>
<li>每个Pod在创建后都会自动设置spec.serviceAccount为default（除非指定了其他ServiceAccout）</li>
<li>验证Pod引用的service account已经存在，否则拒绝创建</li>
<li>如果Pod没有指定ImagePullSecrets，则把service account的ImagePullSecrets加到Pod中</li>
<li>每个container启动后都会挂载该service account的token和ca.crt到/var/run/secrets/kubernetes.io/serviceaccount/　　</li>
</ul>
</li>
</ul>
<p>当创建 pod 的时候，如果没有指定一个 service account，系统会自动在与该pod 相同的 namespace  下为其指派一个default service  account。而pod和apiserver之间进行通信的账号，称为serviceAccountName。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                     READY     STATUS    RESTARTS   AGE</span><br><span class="line">filebeat-ds-hxgdx        1/1       Running   1          34d</span><br><span class="line">filebeat-ds-s466l        1/1       Running   2          34d</span><br><span class="line">myapp-0                    1/1       Running   0          3h</span><br><span class="line">myapp-1                    1/1       Running   0          3h</span><br><span class="line">myapp-2                    1/1       Running   0          4h</span><br><span class="line">myapp-3                    1/1       Running   0          4h</span><br><span class="line">pod-vol-demo              2/2       Running   0          2d</span><br><span class="line">redis-5b5d6fbbbd-q8ppz  1/1       Running   1          2d</span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods/myapp-0 -o yaml |grep &quot;serviceAccountName&quot;</span></span><br><span class="line"> serviceAccountName: default</span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl describe pods myapp-0</span></span><br><span class="line">Name:               myapp-0</span><br><span class="line">Namespace:          default</span><br><span class="line">......</span><br><span class="line">Volumes:</span><br><span class="line"> ......</span><br><span class="line">default-token-j5pf5:</span><br><span class="line">  Type:        Secret (a volume populated by a Secret)</span><br><span class="line">  SecretName:  default-token-j5pf5</span><br><span class="line">  Optional:    <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到每个Pod无论定义与否都会有个存储卷，这个存储卷为default-token-***  token令牌，这就是pod和serviceaccount认证信息。通过secret进行定义，由于认证信息属于敏感信息，所以需要保存在secret资源当中，并以存储卷的方式挂载到Pod当中。从而让Pod内运行的应用通过对应的secret中的信息来连接apiserver，并完成认证。每个 namespace 中都有一个默认的叫做 default 的 service account  资源。进行查看名称空间内的secret，也可以看到对应的default-token。让当前名称空间中所有的pod在连接apiserver时可以使用的预制认证信息，从而保证pod之间的通信。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl create namespace kinmfer  #创建一个名称空间</span></span><br><span class="line">namespace <span class="string">&quot;kinmfer&quot;</span> created</span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get sa -n kinmfer  #名称空间创建完成后会自动创建一个sa</span></span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         11s</span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get secret -n kinmfer  #同时也会自动创建一个secret</span></span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">default-token-5jtz2   kubernetes.io/service-account-token   3         19s</span><br></pre></td></tr></table></figure>
<p>在创建的名称空间中新建一个pod</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">pod-example</span>]<span class="comment"># cat pod_demo.yaml </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">task-pv-pod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kinmfer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">       <span class="attr">name:</span> <span class="string">www</span></span><br></pre></td></tr></table></figure>
<p>查看pod信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 pod-example]<span class="comment"># kubectl apply -f  pod_demo.yaml </span></span><br><span class="line">pod <span class="string">&quot;task-pv-pod&quot;</span> created</span><br><span class="line">[root@k8s-master01 pod-example]<span class="comment"># kubectl get pod -n kinmfer </span></span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">task-pv-pod   1/1       Running   0          13s</span><br><span class="line">[root@k8s-master01 pod-example]<span class="comment"># kubectl get  pod task-pv-pod -o yaml   -n kinmfer </span></span><br><span class="line">......</span><br><span class="line">volumeMounts:</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: default-token-5jtz2</span><br><span class="line">......</span><br><span class="line">volumes:  <span class="comment">#挂载sa的secret</span></span><br><span class="line">  - name: default-token-5jtz2</span><br><span class="line">    secret:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      secretName: default-token-5jtz2 </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>一个ServiceAccount可包含多个Secret</p>
<p>其中</p>
<ul>
<li>名为Tokens的Secret用于访问API Server的Secret，也被称为Service Account Secret。</li>
<li>名为imagePullSecrets的Secret用于下载容器镜像时的认证过程，通常镜像库运行在Insecure模式下，所以这个为空</li>
<li>用户自定义的其他Secret，用于用户的进程。</li>
</ul>
<p>名称空间新建的pod如果不指定sa，会自动挂载当前名称空间中默认的sa(default)。而默认的service account仅仅只能获取当前Pod自身的相关属性，无法观察到其他名称空间Pod的相关属性信息。如果想要扩展Pod，假设有一个Pod需要用于管理其他Pod或者是其他资源对象，是无法通过自身的名称空间的serviceaccount进行获取其他Pod的相关属性信息的，此时就需要进行手动创建一个serviceaccount，并在创建Pod时进行定义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl explain sa</span></span><br><span class="line">KIND:     ServiceAccount</span><br><span class="line">VERSION:  v1</span><br><span class="line"> </span><br><span class="line">DESCRIPTION:</span><br><span class="line">     ServiceAccount binds together: * a name, understood by users, and perhaps</span><br><span class="line">     by peripheral systems, <span class="keyword">for</span> an identity * a principal that can be</span><br><span class="line">     authenticated and authorized * a <span class="built_in">set</span> of secrets</span><br><span class="line"> </span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion    &lt;string&gt;</span><br><span class="line">     APIVersion defines the versioned schema of this representation of an</span><br><span class="line">     object. Servers should convert recognized schemas to the latest internal</span><br><span class="line">     value, and may reject unrecognized values. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/api-conventions.md<span class="comment">#resources</span></span><br><span class="line"> </span><br><span class="line">   automountServiceAccountToken    &lt;boolean&gt;</span><br><span class="line">     AutomountServiceAccountToken indicates whether pods running as this service</span><br><span class="line">     account should have an API token automatically mounted. Can be overridden</span><br><span class="line">     at the pod level.</span><br><span class="line"> </span><br><span class="line">   imagePullSecrets    &lt;[]Object&gt;</span><br><span class="line">     ImagePullSecrets is a list of references to secrets <span class="keyword">in</span> the same namespace</span><br><span class="line">     to use <span class="keyword">for</span> pulling any images <span class="keyword">in</span> pods that reference this ServiceAccount.</span><br><span class="line">     ImagePullSecrets are distinct from Secrets because Secrets can be mounted</span><br><span class="line">     <span class="keyword">in</span> the pod, but ImagePullSecrets are only accessed by the kubelet. More</span><br><span class="line">     info:</span><br><span class="line">     https://kubernetes.io/docs/concepts/containers/images/<span class="comment">#specifying-imagepullsecrets-on-a-pod</span></span><br><span class="line"> </span><br><span class="line">   kind    &lt;string&gt;</span><br><span class="line">     Kind is a string value representing the REST resource this object</span><br><span class="line">     represents. Servers may infer this from the endpoint the client submits</span><br><span class="line">     requests to. Cannot be updated. In CamelCase. More info:</span><br><span class="line">     https://git.k8s.io/community/contributors/devel/api-conventions.md<span class="comment">#types-kinds</span></span><br><span class="line"> </span><br><span class="line">   metadata    &lt;Object&gt;</span><br><span class="line">     Standard object<span class="string">&#x27;s metadata. More info:</span></span><br><span class="line"><span class="string">     https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">   secrets    &lt;[]Object&gt;</span></span><br><span class="line"><span class="string">     Secrets is the list of secrets allowed to be used by pods running using</span></span><br><span class="line"><span class="string">     this ServiceAccount. More info:</span></span><br><span class="line"><span class="string">     https://kubernetes.io/docs/concepts/configuration/secret</span></span><br></pre></td></tr></table></figure>
<p>创建serviceaccount(以下简称sa)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment">#  kubectl create  serviceaccount admin   #创建一个sa 名称为admin</span></span><br><span class="line">serviceaccount <span class="string">&quot;admin&quot;</span> created</span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get sa </span></span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">admin     1         6s</span><br><span class="line">default   1         28d</span><br><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl describe sa admin   #查看名称为admin的sa的信息，系统会自动创建一个token信息</span></span><br><span class="line">Name:                admin</span><br><span class="line">Namespace:           default</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   admin-token-rxtrc</span><br><span class="line">Tokens:              admin-token-rxtrc</span><br><span class="line">Events:              &lt;none&gt;s</span><br></pre></td></tr></table></figure>
<p>看到有一个 token 已经被自动创建，并被 service account 引用。设置非默认的 service account，只需要在  pod 的spec.serviceAccountName 字段中将name设置为您想要用的 service account 名字即可。在 pod 创建之初 service account 就必须已经存在，否则创建将被拒绝。需`要注意的是不能更新已创建的 pod 的 service  account。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 ~]<span class="comment"># kubectl get secret  #会自动创建一个secret(admin-token-rxtrc),用于当前sa连接至当前API server时使用的认证信息</span></span><br><span class="line">NAME                    TYPE                                 			 DATA      AGE</span><br><span class="line">admin-token-rxtrc       kubernetes.io/service-account-token   	3         1m</span><br><span class="line">default-token-tcwjz     kubernetes.io/service-account-token   	3         28d</span><br><span class="line">myapp-ingress-secret    kubernetes.io/tls                     		2         6h</span><br><span class="line">mysql-passwd              Opaque                                		1         17d</span><br><span class="line">tomcat-ingress-secret   kubernetes.io/tls                     		2         7h</span><br></pre></td></tr></table></figure>
<p>创建一个pod应用刚刚创建的sa</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl create serviceaccount admin</span></span><br><span class="line"><span class="string">serviceaccount/admin</span> <span class="string">created</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl get sa</span></span><br><span class="line"><span class="string">NAME</span>      <span class="string">SECRETS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">admin</span>     <span class="number">1</span>         <span class="string">3s</span></span><br><span class="line"><span class="string">default</span>   <span class="number">1</span>         <span class="string">50d</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl describe sa/admin</span></span><br><span class="line"><span class="attr">Name:</span>                <span class="string">admin</span></span><br><span class="line"><span class="attr">Namespace:</span>           <span class="string">default</span></span><br><span class="line"><span class="attr">Labels:</span>              <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Annotations:</span>         <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Image pull secrets:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Mountable secrets:</span>   <span class="string">admin-token-7k5nr</span></span><br><span class="line"><span class="attr">Tokens:</span>              <span class="string">admin-token-7k5nr</span></span><br><span class="line"><span class="attr">Events:</span>              <span class="string">&lt;none&gt;</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl get secret</span></span><br><span class="line"><span class="string">NAME</span>                    <span class="string">TYPE</span>                                  <span class="string">DATA</span>      <span class="string">AGE</span></span><br><span class="line"><span class="string">admin-token-7k5nr</span>       <span class="string">kubernetes.io/service-account-token</span>   <span class="number">3</span>         <span class="string">31s</span></span><br><span class="line"><span class="string">default-token-j5pf5</span>     <span class="string">kubernetes.io/service-account-token</span>   <span class="number">3</span>         <span class="string">50d</span></span><br><span class="line"><span class="string">mysecret</span>                <span class="string">Opaque</span>                                <span class="number">2</span>         <span class="string">1d</span></span><br><span class="line"><span class="string">tomcat-ingress-secret</span>   <span class="string">kubernetes.io/tls</span>                     <span class="number">2</span>         <span class="string">10d</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># vim pod-sa-demo.yaml　　#Pod中引用新建的serviceaccount</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-sa-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ikubernetes/myapp:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">admin</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl apply -f pod-sa-demo.yaml </span></span><br><span class="line"><span class="string">pod/pod-sa-demo</span> <span class="string">created</span></span><br><span class="line">[<span class="string">root@k8s-master</span> <span class="string">mainfests</span>]<span class="comment"># kubectl describe pods pod-sa-demo</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">Volumes:</span></span><br><span class="line">  <span class="attr">admin-token-7k5nr:</span></span><br><span class="line">    <span class="attr">Type:</span>        <span class="string">Secret</span> <span class="string">(a</span> <span class="string">volume</span> <span class="string">populated</span> <span class="string">by</span> <span class="string">a</span> <span class="string">Secret)</span></span><br><span class="line">    <span class="attr">SecretName:</span>  <span class="string">admin-token-7k5nr</span></span><br><span class="line">    <span class="attr">Optional:</span>    <span class="literal">false</span></span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure>
<p>ServiceAccount中添加Image pull secrets</p>
<p>创建docker-registry的Secret</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos8 rbac]<span class="comment"># kubectl create secret docker-registry myregistrykey --docker-server=hub.vfancloud.com --docker-username=admin --docker-password=admin@123 --docker-email=xxx@163.com -n kinmfer</span></span><br><span class="line">secret/myregistrykey created</span><br><span class="line"></span><br><span class="line">[root@Centos8 rbac]<span class="comment"># kubectl get secret -n kinmfer</span></span><br><span class="line">NAME                  TYPE                                  DATA   AGE</span><br><span class="line">default-token-wwbc8   kubernetes.io/service-account-token   3      62m</span><br><span class="line">myregistrykey         kubernetes.io/dockerconfigjson        1      7s</span><br><span class="line">kinmfer-token-9s8f7    kubernetes.io/service-account-token   3      43m</span><br></pre></td></tr></table></figure>
<p>将docker-registry的Secret添加到SA</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kinmfersa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kinmfer</span></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kinmfer-token-9s8f7</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br></pre></td></tr></table></figure>
<p>查看SA的Image pull secrets</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Centos8 rbac]<span class="comment"># kubectl describe sa vfansa -n vfan </span></span><br><span class="line">Name:                kinmfer</span><br><span class="line">Namespace:           vfan</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  myregistrykey</span><br><span class="line">Mountable secrets:   kinmfer-token-9s8f7</span><br><span class="line">Tokens:              kinmfer-token-9s8f7</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>这个时候，只要是使用此sa的pod，都可以在docker-registry中拉取镜像了，同样，可以把此secret添加到default的SA中。达到相同的效果。</p>
<blockquote>
<p>可以为serviceaccount创建多个token</p>
</blockquote>
<h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:kinmfer@foxmail.com">Kinmfer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kinmfer.github.io/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">https://kinmfer.github.io/2021/01/26/云计算-Kubernetes-安全机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Kinmfer.github.io" target="_blank">Kinmfer's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/k8s/">k8s</a><a class="post-meta__tags" href="/tags/%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">安全机制</a><a class="post-meta__tags" href="/tags/%E5%8F%8C%E5%90%91TLS/">双向TLS</a><a class="post-meta__tags" href="/tags/TLS-Bootstrapping/">TLS Bootstrapping</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/26/%E4%BA%91%E8%AE%A1%E7%AE%97-Kubernetes-%E7%BD%91%E7%BB%9C-%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B/"><img class="prev-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kubernetes-网络模型</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/25/GOLANG-08-%E5%87%BD%E6%95%B0/"><img class="next-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GOLANG-08-函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/26/云计算-Kubernetes-服务暴露-ingress/" title="Kubernetes-服务暴露-ingress"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Kubernetes-服务暴露-ingress</div></div></a></div><div><a href="/2021/01/26/云计算-Kubernetes-网络-基本模型/" title="Kubernetes-网络模型"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Kubernetes-网络模型</div></div></a></div><div><a href="/2021/01/29/云计算-Kubernetes-网络-Flannel+Calico/" title="Kubernetes-网络-Flannel+Calico"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">Kubernetes-网络-Flannel+Calico</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81MTkzMi8yODQxMw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Kinmfer</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">102</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kinmfer"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kinmfer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:kinmfer@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！本博客用于记录一些学习过程中的文章，包括原创，也包括转录其他大神的博客。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81"><span class="toc-number">1.</span> <span class="toc-text">认证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Authenticating-Proxy"><span class="toc-number">1.1.</span> <span class="toc-text">Authenticating Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Password-File"><span class="toc-number">1.2.</span> <span class="toc-text">Static Password File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Token-File"><span class="toc-number">1.3.</span> <span class="toc-text">Static Token File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenID-Connect-Tokens"><span class="toc-number">1.4.</span> <span class="toc-text">OpenID Connect Tokens</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Webhook-Token-Authentication"><span class="toc-number">1.5.</span> <span class="toc-text">Webhook Token Authentication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#X509-Client-Certs"><span class="toc-number">1.6.</span> <span class="toc-text">X509 Client Certs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91TLS%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.1.</span> <span class="toc-text">双向TLS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text">公钥密码体制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text">对称加密算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.1.3.</span> <span class="toc-text">非对称加密算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.1.1.4.</span> <span class="toc-text">RSA简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E5%92%8C%E5%8A%A0%E5%AF%86"><span class="toc-number">1.6.1.1.5.</span> <span class="toc-text">签名和加密</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E7%9A%84%E6%BC%94%E5%8C%96"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">一个加密通信过程的演化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%9B%9E%E5%90%88"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">第一回合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%9B%9E%E5%90%88"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">第二回合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%9B%9E%E5%90%88"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text">第三回合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%9B%9E%E5%90%88"><span class="toc-number">1.6.1.2.4.</span> <span class="toc-text">第四回合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E5%9B%9E%E5%90%88"><span class="toc-number">1.6.1.2.5.</span> <span class="toc-text">第五回合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.1.2.6.</span> <span class="toc-text">完整过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.2.7.</span> <span class="toc-text">其他问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cfssl%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">cfssl命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6%E6%9C%89%E6%95%88%E6%9C%9F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">验证证书有效期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%B0%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">生成新证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACA%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">创建CA证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACA%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">创建CA证书签名请求文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90CA%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%81%E9%92%A5"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">生成CA证书和私钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAkubernetes%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">创建kubernetes证书</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s%E7%9A%84%E8%AE%A4%E8%AF%81"><span class="toc-number">1.6.3.</span> <span class="toc-text">k8s的认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84CA%E5%92%8C%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.4.</span> <span class="toc-text">Kubernetes 中使用到的CA和证书</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#k8s%E4%B8%AD%E7%9A%84%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">k8s中的证书配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#etcd"><span class="toc-number">1.6.4.1.1.</span> <span class="toc-text">etcd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kubectl"><span class="toc-number">1.6.4.1.2.</span> <span class="toc-text">kubectl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kubelet"><span class="toc-number">1.6.4.1.3.</span> <span class="toc-text">kubelet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#kube-apiserver"><span class="toc-number">1.6.4.1.4.</span> <span class="toc-text">kube-apiserver</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8-kubeconfig-%E8%AE%BF%E9%97%AE-kube-apiserver"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">采用 kubeconfig 访问 kube-apiserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service-Account%E8%AF%81%E4%B9%A6"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">Service Account证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%8F%91"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">Kubernetes 证书签发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS-bootstrapping"><span class="toc-number">1.7.</span> <span class="toc-text">TLS bootstrapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">引导流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.7.2.</span> <span class="toc-text">相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kubelet-server"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">kubelet server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSR-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">CSR 请求类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Token"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">Token</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90token"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">生成token</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kube-apiserver%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">kube-apiserver配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEbootstrapper%E6%9C%89%E7%94%9F%E6%88%90csr%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">配置bootstrapper有生成csr的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kube-controller-manager%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">kube-controller-manager配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%8F%91%E6%9D%83%E9%99%90"><span class="toc-number">1.7.3.5.</span> <span class="toc-text">配置证书自动签发权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kubelet%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.3.6.</span> <span class="toc-text">kubelet配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F"><span class="toc-number">1.7.3.7.</span> <span class="toc-text">证书自动续期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E4%B9%A6%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.4.</span> <span class="toc-text">证书及配置文件作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubeconfig"><span class="toc-number">1.8.</span> <span class="toc-text">kubeconfig</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%9C%80%E9%AB%98%E6%9D%83%E9%99%90%E7%9A%84-kubeconfig"><span class="toc-number">1.8.1.</span> <span class="toc-text">生成最高权限的 kubeconfig</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">集群参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">用户参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">上下文参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubeconfig-%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">kubeconfig 的认证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-%E5%92%8C-CN-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">O 和 CN 的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90"><span class="toc-number">1.8.4.</span> <span class="toc-text">k8s 核心组件的默认权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%88%E6%9D%83"><span class="toc-number">2.</span> <span class="toc-text">授权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Secret"><span class="toc-number">2.1.</span> <span class="toc-text">Secret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceAccount"><span class="toc-number">2.2.</span> <span class="toc-text">ServiceAccount</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Token-Controller"><span class="toc-number">2.2.1.</span> <span class="toc-text">Token Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Account-Controller"><span class="toc-number">2.2.2.</span> <span class="toc-text">Service Account Controller</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">准入控制</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/02/04/GOLANG-16-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="GOLANG-16-网络编程"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GOLANG-16-网络编程"/></a><div class="content"><a class="title" href="/2021/02/04/GOLANG-16-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="GOLANG-16-网络编程">GOLANG-16-网络编程</a><time datetime="2021-02-04T12:10:02.000Z" title="发表于 2021-02-04 20:10:02">2021-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/02/03/GOLANG-15-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" title="GOLANG-15-单元测试"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GOLANG-15-单元测试"/></a><div class="content"><a class="title" href="/2021/02/03/GOLANG-15-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" title="GOLANG-15-单元测试">GOLANG-15-单元测试</a><time datetime="2021-02-03T12:28:06.000Z" title="发表于 2021-02-03 20:28:06">2021-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/31/GOLANG-14-%E5%B9%B6%E5%8F%91/" title="GOLANG-14-并发"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GOLANG-14-并发"/></a><div class="content"><a class="title" href="/2021/01/31/GOLANG-14-%E5%B9%B6%E5%8F%91/" title="GOLANG-14-并发">GOLANG-14-并发</a><time datetime="2021-01-31T11:53:30.000Z" title="发表于 2021-01-31 19:53:30">2021-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/30/GOLANG-13-%E5%8F%8D%E5%B0%84/" title="GOLANG-13-反射"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GOLANG-13-反射"/></a><div class="content"><a class="title" href="/2021/01/30/GOLANG-13-%E5%8F%8D%E5%B0%84/" title="GOLANG-13-反射">GOLANG-13-反射</a><time datetime="2021-01-30T12:54:53.000Z" title="发表于 2021-01-30 20:54:53">2021-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/29/GOLANG-12-%E6%8E%A5%E5%8F%A3/" title="GOLANG-12-接口"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GOLANG-12-接口"/></a><div class="content"><a class="title" href="/2021/01/29/GOLANG-12-%E6%8E%A5%E5%8F%A3/" title="GOLANG-12-接口">GOLANG-12-接口</a><time datetime="2021-01-29T10:35:31.000Z" title="发表于 2021-01-29 18:35:31">2021-01-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Kinmfer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kinmfer.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'vSKb5nQqvUv44yjbvGjUmk3E-gzGzoHsz',
      appKey: '4TRbJGECRE8pcN777qgBXsKO',
      placeholder: '记得留下你的昵称和邮箱,可以快速收到回复哦~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_����":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_͵Ц":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_�ټ�":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_��Į":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_��ŭ":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_�ɰ�":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_��Ѫ":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_��":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_Ż��":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_��Ц":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_���":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_ί��":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_΢Ц":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_˼��":"90cf159733e558137ed20aa04d09964436f618a1.png"},
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="//code.tidio.co/mzqu2o1lbhle9bvhab8bexgtiyxgkheb.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>