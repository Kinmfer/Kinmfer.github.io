<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Kubernetes-网络-Flannel+Calico | Kinmfer's Blogs</title><meta name="keywords" content="k8s,网络模型,Flannel,Calico"><meta name="author" content="Kinmfer,kinmfer@foxmail.com"><meta name="copyright" content="Kinmfer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Flannel简介Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。 在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。并使这些容器之间能够之间通过IP地址相互找到，也就">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes-网络-Flannel+Calico">
<meta property="og:url" content="https://kinmfer.github.io/2021/01/29/%E4%BA%91-Kubernetes-%E7%BD%91%E7%BB%9C-Flannel+Calico/index.html">
<meta property="og:site_name" content="Kinmfer&#39;s Blogs">
<meta property="og:description" content="Flannel简介Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。 在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。并使这些容器之间能够之间通过IP地址相互找到，也就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg">
<meta property="article:published_time" content="2021-01-29T01:46:46.000Z">
<meta property="article:modified_time" content="2021-03-03T08:41:30.658Z">
<meta property="article:author" content="Kinmfer">
<meta property="article:tag" content="k8s">
<meta property="article:tag" content="网络模型">
<meta property="article:tag" content="Flannel">
<meta property="article:tag" content="Calico">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kinmfer.github.io/2021/01/29/%E4%BA%91-Kubernetes-%E7%BD%91%E7%BB%9C-Flannel+Calico/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c46ed77365f502de73543fbf10399875";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C2N62A47W9","apiKey":"0c62f17095ec2a20c19657511a42c0b1","indexName":"Blogs","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章更新于","messageNext":"天前,内容可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Kinmfer","link":"链接: ","source":"来源: Kinmfer's Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes-网络-Flannel+Calico',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-03 16:41:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kinmfer's Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes-网络-Flannel+Calico</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-29T01:46:46.000Z" title="发表于 2021-01-29 09:46:46">2021-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-03T08:41:30.658Z" title="更新于 2021-03-03 16:41:30">2021-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/Kubernetes/">Kubernetes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes-网络-Flannel+Calico"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/01/29/%E4%BA%91-Kubernetes-%E7%BD%91%E7%BB%9C-Flannel+Calico/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/01/29/%E4%BA%91-Kubernetes-%E7%BD%91%E7%BB%9C-Flannel+Calico/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。</p>
<p>在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。并使这些容器之间能够之间通过IP地址相互找到，也就是相互ping通。</p>
<p>Flannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。</p>
<p>Flannel实质上是一种“覆盖网络(overlaynetwork)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持udp、vxlan、host-gw、aws-vpc、gce和alloc路由等数据转发方式，默认的节点间数据通信方式是UDP转发。</p>
<p>简单总结Flannel特点</p>
<p>1.使集群中的不同Node主机创建的Docker容器都具有全集群唯一的虚拟IP地址。</p>
<p>2.建立一个覆盖网络（overlay network），通过这个覆盖网络，将数据包原封不动的传递到目标容器。覆盖网络是建立在另一个网络之上并由其基础设施支持的虚拟网络。覆盖网络通过将一个分组封装在另一个分组内来将网络服务与底层基础设施分离。在将封装的数据包转发到端点后，将其解封装。</p>
<p>3.创建一个新的虚拟网卡flannel0接收docker网桥的数据，通过维护路由表，对接收到的数据进行封包和转发（vxlan）。</p>
<p>4.etcd保证了所有node上flanned所看到的配置是一致的。同时每个node上的flanned监听etcd上的数据变化，实时感知集群中node的变化。</p>
<h2 id="Flannel对网络要求提出的解决办法"><a href="#Flannel对网络要求提出的解决办法" class="headerlink" title="Flannel对网络要求提出的解决办法"></a>Flannel对网络要求提出的解决办法</h2><h3 id="互相不冲突的ip"><a href="#互相不冲突的ip" class="headerlink" title="互相不冲突的ip"></a>互相不冲突的ip</h3><p>1.flannel利用Kubernetes API或者etcd用于存储整个集群的网络配置，根据配置记录集群使用的网段。</p>
<p>2.flannel在每个主机中运行flanneld作为agent，它会为所在主机从集群的网络地址空间中，获取一个小的网段subnet，本主机内所有容器的IP地址都将从中分配。</p>
<p>如测试环境中ip分配：</p>
<p>1.master节点</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145028603-1562039245.png" alt="img"></p>
<p>2.node1</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145159494-804778941.png" alt="img"></p>
<p>3.node2</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145219198-1737771651.png" alt="img"></p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145226180-224637322.png" alt="img"></p>
<p>在flannel network中，每个pod都会被分配唯一的ip地址，且每个K8s node的subnet各不重叠，没有交集。</p>
<h3 id="Pod之间互相访问"><a href="#Pod之间互相访问" class="headerlink" title="Pod之间互相访问"></a>Pod之间互相访问</h3><ol>
<li>flanneld将本主机获取的subnet以及用于主机间通信的Public IP通过etcd存储起来，需要时发送给相应模块。</li>
<li>flannel利用各种backend mechanism，例如udp，vxlan等等，跨主机转发容器间的网络流量，完成容器间的跨主机通信。</li>
</ol>
<h2 id="Flannel架构原理"><a href="#Flannel架构原理" class="headerlink" title="Flannel架构原理"></a>Flannel架构原理</h2><p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145249573-1127241268.png" alt="img"></p>
<p>各个组件的解释</p>
<p><strong>Cni0</strong>:网桥设备，每创建一个pod都会创建一对 veth pair。其中一端是pod中的eth0，另一端是Cni0网桥中的端口（网卡）。Pod中从网卡eth0发出的流量都会发送到Cni0网桥设备的端口（网卡）上。</p>
<p> <img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145308681-317197626.png" alt="img"></p>
<p> Cni0 设备获得的ip地址是该节点分配到的网段的第一个地址。</p>
<p><strong>Flannel.1</strong>: overlay网络的设备，用来进行 vxlan 报文的处理（封包和解包）。不同node之间的pod数据流量都从overlay设备以隧道的形式发送到对端。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145322264-465199087.png" alt="img"></p>
<p><strong>Flanneld</strong>：flannel在每个主机中运行flanneld作为agent，它会为所在主机从集群的网络地址空间中，获取一个小的网段subnet，本主机内所有容器的IP地址都将从中分配。同时Flanneld监听K8s集群数据库，为flannel.1设备提供封装数据时必要的mac，ip等网络数据信息。</p>
<p><strong>不同node上的pod的通信流程：</strong></p>
<ol>
<li>pod中产生数据，根据pod的路由信息，将数据发送到Cni0</li>
<li>Cni0 根据节点的路由表，将数据发送到隧道设备flannel.1</li>
<li>Flannel.1查看数据包的目的ip，从flanneld获得对端隧道设备的必要信息，封装数据包。</li>
<li>Flannel.1将数据包发送到对端设备。对端节点的网卡接收到数据包，发现数据包为overlay数据包，解开外层封装，并发送内层封装到flannel.1设备。</li>
<li>Flannel.1设备查看数据包，根据路由表匹配，将数据发送给Cni0设备。</li>
<li>Cni0匹配路由表，发送数据给网桥上对应的端口。</li>
</ol>
<p>下面请看详细流程</p>
<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><h3 id="Pod1中的容器到cni0"><a href="#Pod1中的容器到cni0" class="headerlink" title="Pod1中的容器到cni0"></a>Pod1中的容器到cni0</h3><p>Pod1与Pod3能够互相ping通</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145345725-337345611.png" alt="img"></p>
<p>Ping包的dst ip 为192.20.1.43，根据路由匹配到最后一条路由表项，去往192.20.0.0/12的包都转发给192.20.0.1。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145401389-532913287.png" alt="img"></p>
<p>192.20.0.1为cni0的ip地址。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145413015-1004337524.png" alt="img"></p>
<h3 id="cni0到flannel1-1"><a href="#cni0到flannel1-1" class="headerlink" title="cni0到flannel1.1"></a>cni0到flannel1.1</h3><p>当icmp包达到cni0之后，cni0发现dst为192.20.1.43，cni根据主机路由表来查找匹配项。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145427108-2140471234.png" alt="img"></p>
<p>根据最小匹配原则，匹配到图上的一条路由表项。去往192.20.1.0/24 网段的包，发送192.20.1.0网关，网关设备是flannel.1。</p>
<h3 id="flannel1"><a href="#flannel1" class="headerlink" title="flannel1"></a>flannel1</h3><p>flannel.1为vxlan设备，当数据包来到flannel.1时，需要将数据包封装起来。此时的dst ip 为192.20.1.43，src ip为192.20.0.51。数据包继续封装需要知道192.20.1.43 ip地址对应的mac地址。此时，flannel.1不会发送arp请求去获得192.20.1.42的mac地址，而是由Linux kernel将一个“L3 Miss”事件请求发送的用户空间的flanned程序。Flanned程序收到内核的请求事件之后，从etcd查找能够匹配该地址的子网的flannel.1设备的mac地址，即发往的pod所在host中flannel.1设备的mac地址。Flannel在为Node节点分配ip网段时记录了所有的网段和mac等信息，所以能够知道。交互流程如下图所示：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145440459-866148029.png" alt="img"></p>
<p>flanned将查询到的信息放入master node host的arp cache表中：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145453004-206623983.png" alt="img"></p>
<p>到这里，vxlan的内层数据包就完成了封装。格式是这样的：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145506201-1839601264.png" alt="img"></p>
<p>简单总结这个流程：</p>
<ol>
<li>数据包到达flannel.1，通过查找路由表，知道数据包要通过flannel.1发往192.20.1.0</li>
<li>通过arp cache表，知道了目的ip192.20.1.0的mac地址。</li>
</ol>
<p>kernel需要查看node上的fdb(forwarding database)以获得内层封包中目的vtep设备所在的node地址。因为已经从arp table中查到目的设备mac地址为52:77:71:e6:4f:58，同时在fdb中存在该mac地址对应的node节点的IP地址。如果fdb中没有这个信息，那么kernel会向用户空间的flanned程序发起”L2 MISS”事件。flanneld收到该事件后，会查询etcd，获取该vtep设备对应的node的”Public IP“，并将信息注册到fdb中。</p>
<p>当内核获得了发往机器的ip地址后，arp得到mac地址，之后就能完成vxlan的外层封装。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145524328-1990216206.png" alt="img"></p>
<h3 id="对端flannel1"><a href="#对端flannel1" class="headerlink" title="对端flannel1"></a>对端flannel1</h3><p>Node节点的eth0网卡接收到vxlan设备包，kernel将识别出这是一个vxlan包，将包拆开之后转给节点上的flannel.1设备。这样数据包就从发送节点到达目的节点，flannel.1设备将接收到一个如下的数据包：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145537234-1878339801.png" alt="img"></p>
<p>目的地址为192.20.1.43，flannel.1查找自己的路由表，根据路由表完成转发。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145551119-2117095430.png" alt="img"></p>
<p>根据最下匹配原则，flannel.1将去往192.20.1.0/24的流量转发到cni0上去。</p>
<h3 id="cni0到pod"><a href="#cni0到pod" class="headerlink" title="cni0到pod"></a>cni0到pod</h3><p>cni0是一个网桥设备。当cni0拿到数据包之后，通过veth pair，将数据包发送给pod。查看Node节点中的网桥。 </p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145612880-2009563108.png" alt="img"></p>
<p>在node节点上通过arp解析可以开出，192.20.1.43的mac地址为 66:57:8e:3d:00:85</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145627101-1742990375.png" alt="img"></p>
<p>该地址为pod的网卡eth0的地址。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145642859-905674623.png" alt="img"></p>
<p>同时通过veth pair的配对关系可以看出，pod中的eth0是veth pair的一端，另一端在node节点行上，对应的网卡是vethd356ffc1@if3。所以，在cni0网桥上挂载的pod的veth pair为vethd356ffc1，即：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190420145704371-1775051009.png" alt="img"></p>
<p>eth0@if50和vethd356ffc1@if3组成的一对veth，pair。其效果相当于将pod中的eth0直接插在到cni0上。所以简单总结cni0转发流量的原理：</p>
<ol>
<li>首先通过arp查找出ip地址对应的mac地址</li>
<li>将流量转发给mac地址所在eth0网的对应的veth pair端口</li>
<li>veth pair端口接收到流量，直接将流量注入到pod的eth0网卡上。</li>
</ol>
<h2 id="不同后端的封装"><a href="#不同后端的封装" class="headerlink" title="不同后端的封装"></a>不同后端的封装</h2><h3 id="UDP模式（性能差）"><a href="#UDP模式（性能差）" class="headerlink" title="UDP模式（性能差）"></a>UDP模式（性能差）</h3><p>核心就是通过TUN设备flannel0实现（TUN设备是工作在三层的虚拟网络设备，功能是：在操作系统内核和用户应用程序之间传递IP包）<br>相比两台宿主机直接通信，多出了flanneld的处理过程，这个过程，使用了flannel0这个TUN设备，仅在发出IP包的过程中就要经过了两次用户态到内核态的数据拷贝（linux的上下文切换代价比较大），所以性能非常差<br>原理如下：<br><img src="https://c1.lmlphp.com/user/master/2019/10/22/a5d3e9201094b94204bea90b5d97a0ec.png" alt="Kubernetes网络插件Flannel的三种工作模式-LMLPHP"></p>
<p>以flannel0为例，操作系统将一个IP包发给flannel0，flannel0把IP包发给创建这个设备的应用程序：flanneld进程（内核态-&gt;用户态）<br>相反，flaneld进程向flanel0发送一个IP包，IP包会出现在宿主机的网络栈中，然后根据宿主机的路由表进行下一步处理（用户态-&gt;内核态）<br>当IP包从容器经过docker0出现在宿主机，又根据路由表进入flannel0设备后，宿主机上的flanneld进程就会收到这个IP包</p>
<p>flannel管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的“子网”，子网与宿主机的对应关系，存在Etcd中（例如Node1的子网是100.96.1.0/24，container-1的IP地址是100.96.1.2）<br>当flanneld进程处理flannel0传入的IP包时，就可以根据目的IP地址（如100.96.2.3），匹配到对应的子网（比如100.96.2.0/24），从Etcd中找到这个子网对应的宿主机的IP地址（10.168.0.3）<br>然后flanneld在收到container-1给container-2的包后，把这个包直接封装在UDP包里，发送给Node2（UDP包的源地址，就是Node1，目的地址是Node2）<br>每台宿主机的flanneld都监听着8285端口，所以flanneld只要把UDP发给Node2的8285端口就行了。然后Node2的flanneld再把IP包发送给它所管理的TUN设备flannel0，flannel0设备再发给docker0</p>
<p>当容器10.1.15.2/24要和容器10.1.20.2/24通信时，</p>
<p>1.因为该封包的目的地不在本主机subnet内，因此封包会首先通过网桥转发到主机中。</p>
<p>2.在主机上经过路由匹配，进入网卡flannel.1。(需要注意的是flannel.1是一个tun设备，它是一种工作在三层的虚拟网络设备，而flanneld是一个proxy，它会监听flannel.1并转发流量。)</p>
<p>3.当封包进入flannel.1时，flanneld就可以从flanne.1中将封包读出，由于flanne.1是三层设备，所以读出的封包仅仅包含IP层的报头及其负载。</p>
<p>4.最后flanneld会将获取的封包作为负载数据，通过udp socket发往目的主机。</p>
<p>5.在目的主机的flanneld会监听Public IP所在的设备，从中读取udp封包的负载，并将其放入flannel.1设备内。</p>
<p>6.容器网络封包到达目的主机，之后就可以通过网桥转发到目的容器了。</p>
<p>优点：Pod能够跨网段访问</p>
<p>缺点：隔离性不够，udp不能隔离两个网段。</p>
<h3 id="VXLAN模式（性能较好）"><a href="#VXLAN模式（性能较好）" class="headerlink" title="VXLAN模式（性能较好）"></a>VXLAN模式（性能较好）</h3><p>什么是VXLAN？</p>
<p>VXLAN，即Virtual Extensible LAN（虚拟可扩展局域网），是Linux本身支持的一网种网络虚拟化技术。VXLAN可以完全在内核态实现封装和解封装工作，从而通过“隧道”机制，构建出覆盖网络（Overlay Network）</p>
<p>VXLAN的设计思想是：<br>在现有的三层网络之上，“覆盖”一层虚拟的、由内核VXLAN模块负责维护的二层网络，使得连接在这个VXLAN二nfcu网络上的“主机”（虚拟机或容器都可以），可以像在同一个局域网（LAN）里那样自由通信。<br>为了能够在二nfcu网络上打通“隧道”，VXLAN会在宿主机上设置一个特殊的网络设备作为“隧道”的两端，叫VTEP：VXLAN Tunnel End Point（虚拟隧道端点）<br>原理如下：</p>
<p><img src="https://c1.lmlphp.com/user/master/2019/10/22/de81065800d92e0152e412a376589157.png" alt="Kubernetes网络插件Flannel的三种工作模式-LMLPHP"></p>
<p>flanel.1设备，就是VXLAN的VTEP，即有IP地址，也有MAC地址<br>与UPD模式类似，当container-发出请求后，上的地址10.1.16.3的IP包，会先出现在docker网桥，再路由到本机的flannel.1设备进行处理（进站）<br>为了能够将“原始IP包”封装并发送到正常的主机，VXLAN需要找到隧道的出口：上的宿主机的VTEP设备，这个设备信息，由宿主机的flanneld进程维护</p>
<p>VTEP设备之间通过二层数据帧进行通信<br>源VTEP设备收到原始IP包后，在上面加上一个目的MAC地址，封装成一个导去数据桢，发送给目的VTEP设备（获取 MAC地址需要通过三层IP地址查询，这是ARP表的功能）<br><img src="https://c1.lmlphp.com/user/master/2019/10/22/90ce2e1e52b4608da20cffef6258963c.png" alt="Kubernetes网络插件Flannel的三种工作模式-LMLPHP"></p>
<p>封装过程只是加了一个二层头，不会改变“原始IP包”的内容<br>这些VTEP设备的MAC地址，对宿主机网络来说没什么实际意义，称为内部数据桢，并不能在宿主机的二层网络传输，Linux内核还需要把它进一步封装成为宿主机的一个普通的数据桢，好让它带着“内部数据桢”通过宿主机的eth0进行传输，Linux会在内部数据桢前面，加上一个VXLAN头，VXLAN头里有一个重要的标志叫VNI，它是VTEP识别某个数据帧是不是应该归自己处理的重要标识。<br>在Flannel中，VNI的默认值是1，这也是为什么宿主机的VTEP设备都叫flannel.1的原因</p>
<p>一个flannel.1设备只知道另一端flannel.1设备的MAC地址，却不知道对应的宿主机地址是什么。<br>在linux内核里面，网络设备进行转发的依据，来自FDB的转发数据库，这个flannel.1网桥对应的FDB信息，是由flanneld进程维护的<br>linux内核再在IP包前面加上二层数据桢头，把Node2的MAC地址填进去。这个MAC地址本身，是Node1的ARP表要学习的，需<br>Flannel维护，这时候Linux封装的“外部数据桢”的格式如下<br><img src="https://c1.lmlphp.com/user/master/2019/10/22/3c15cf4640b4d57634b79ae76c3816de.png" alt="Kubernetes网络插件Flannel的三种工作模式-LMLPHP"></p>
<p>然后Node1的flannel.1设备就可以把这个数据桢从eth0发出去，再经过宿主机网络来到Node2的eth0<br>Node2的内核网络栈会发现这个数据帧有VXLAN Header，并且VNI为1，Linux内核会对它进行拆包，拿到内部数据桢，根据VNI的值，所它交给Node2的flannel.1设备</p>
<p>当初始化集群里，vxlan网络的初始化工作：</p>
<p>主机B加入flannel网络时,它会将自己的三个信息写入etcd中，分别是：subnet 10.1.16.0/24、Public IP 192.168.0.101、vtep设备flannel.1的mac地址 MAC B。之后，主机A会得到EventAdded事件，并从中获取上文中B添加至etcd的各种信息。这个时候，它会在本机上添加三条信息：</p>
<ol>
<li><p>路由信息：所有通往目的地址10.1.16.0/24的封包都通过vtep设备flannel.1设备发出，发往的网关地址为10.1.16.0，即主机B中的flannel.1设备。</p>
</li>
<li><p>fdb信息：MAC地址为MAC B的封包，都将通过vxlan发往目的地址192.168.0.101，即主机B</p>
</li>
</ol>
<p>3）arp信息：网关地址10.1.16.0的地址为MAC B</p>
<h3 id="host-gw模式（性能最高）"><a href="#host-gw模式（性能最高）" class="headerlink" title="host-gw模式（性能最高）"></a>host-gw模式（性能最高）</h3><p>这是一种纯三层网络的方案，性能最高<br><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/5ffccb76dd4309dd8014b9c837728a89.png" alt="5ffccb76dd4309dd8014b9c837728a89"></p>
<p>howt-gw模式的工作原理，就是将每个Flannel子网的下一跳，设置成了该子网对应的宿主机的IP地址，也就是说，宿主机（host）充当了这条容器通信路径的“网关”（Gateway），这正是host-gw的含义<br>所有的子网和主机的信息，都保存在Etcd中，flanneld只需要watch这些数据的变化 ，实时更新路由表就行了。<br>核心是IP包在封装成桢的时候，使用路由表的“下一跳”设置上的MAC地址，这样可以经过二层网络到达目的宿主机</p>
<p>事实上，flannel只使用了vxlan的部分功能，由于VNI被固定为1，本质上工作方式和udp backend是类似的，区别无非是将udp的proxy换成了内核中的vxlan处理模块。而原始负载由三层扩展到了二层，但是这对三层网络方案flannel是没有意义的，这么做也仅仅只是为了适配vxlan的模型。vxlan详细的原理参见文后的参考文献，其中的分析更为具体，也更易理解。</p>
<p>总的来说，flannel更像是经典的桥接模式的扩展。我们知道，在桥接模式中，每台主机的容器都将使用一个默认的网段，容器与容器之间，主机与容器之间都能互相通信。要是，我们能手动配置每台主机的网段，使它们互不冲突。接着再想点办法，将目的地址为非本机容器的流量送到相应主机：如果集群的主机都在一个子网内，就搞一条路由转发过去；若是不在一个子网内，就搞一条隧道转发过去。这样以来，容器的跨网络通信问题就解决了。而flannel做的，其实就是将这些工作自动化了而已。</p>
<h1 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Calico 是一种容器之间互通的网络方案。在虚拟化平台中，比如 OpenStack、Docker 等都需要实现 workloads 之间互连，但同时也需要对容器做隔离控制，就像在 Internet 中的服务仅开放80端口、公有云的多租户一样，提供隔离和管控机制。而在多数的虚拟化平台实现中，通常都使用二层隔离技术来实现容器的网络，这些二层的技术有一些弊端，比如需要依赖 VLAN、bridge 和隧道等技术，其中 bridge 带来了复杂性，vlan 隔离和 tunnel 隧道则消耗更多的资源并对物理环境有要求，随着网络规模的增大，整体会变得越加复杂。我们尝试把 Host 当作 Internet 中的路由器，同样使用 BGP 同步路由，并使用 iptables 来做安全访问策略，最终设计出了 Calico 方案。</p>
<p><strong>适用场景</strong>：k8s环境中的pod之间需要隔离</p>
<p><strong>设计思想</strong>：Calico 不使用隧道或 NAT 来实现转发，而是巧妙的把所有二三层流量转换成三层流量，并通过 host 上路由配置完成跨 Host 转发。</p>
<p><strong>设计优势</strong>：</p>
<p><strong>1.更优的资源利用</strong></p>
<p>二层网络通讯需要依赖广播消息机制，广播消息的开销与 host 的数量呈指数级增长，Calico 使用的三层路由方法，则完全抑制了二层广播，减少了资源开销。</p>
<p>另外，二层网络使用 VLAN 隔离技术，天生有 4096 个规格限制，即便可以使用 vxlan 解决，但 vxlan 又带来了隧道开销的新问题。而 Calico 不使用 vlan 或 vxlan 技术，使资源利用率更高。</p>
<p><strong>2.可扩展性</strong></p>
<p>Calico 使用与 Internet 类似的方案，Internet 的网络比任何数据中心都大，Calico 同样天然具有可扩展性。</p>
<p><strong>3.简单而更容易 debug</strong></p>
<p>因为没有隧道，意味着 workloads 之间路径更短更简单，配置更少，在 host 上更容易进行 debug 调试。</p>
<p><strong>4.更少的依赖</strong></p>
<p>Calico 仅依赖三层路由可达。</p>
<p><strong>5.可适配性</strong></p>
<p>Calico 较少的依赖性使它能适配所有 VM、Container、白盒或者混合环境场景。</p>
<h2 id="Calico架构"><a href="#Calico架构" class="headerlink" title="Calico架构"></a>Calico架构</h2><p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413152300545-538840176.png" alt="img"></p>
<p>Calico网络模型主要工作组件：</p>
<p>1.Felix：运行在每一台 Host 的 agent 进程，主要负责网络接口管理和监听、路由、ARP 管理、ACL 管理和同步、状态上报等。</p>
<p>2.etcd：分布式键值存储，主要负责网络元数据一致性，确保Calico网络状态的准确性，可以与kubernetes共用；</p>
<p>3.BGP Client（BIRD）：Calico 为每一台 Host 部署一个 BGP Client，使用 BIRD 实现，BIRD 是一个单独的持续发展的项目，实现了众多动态路由协议比如 BGP、OSPF、RIP 等。在 Calico 的角色是监听 Host 上由 Felix 注入的路由信息，然后通过 BGP 协议广播告诉剩余 Host 节点，从而实现网络互通。</p>
<p>4.BGP Route Reflector：在大型网络规模中，如果仅仅使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，因为所有节点之间俩俩互联，需要 N^2 个连接，为了解决这个规模问题，可以采用 BGP 的 Router Reflector 的方法，使所有 BGP Client 仅与特定 RR 节点互联并做路由同步，从而大大减少连接数。</p>
<p><strong>Felix</strong></p>
<p>Felix会监听ECTD中心的存储，从它获取事件，比如说用户在这台机器上加了一个IP，或者是创建了一个容器等。用户创建pod后，Felix负责将其网卡、IP、MAC都设置好，然后在内核的路由表里面写一条，注明这个IP应该到这张网卡。同样如果用户制定了隔离策略，Felix同样会将该策略创建到ACL中，以实现隔离。</p>
<p><strong>BIRD</strong></p>
<p>BIRD是一个标准的路由程序，它会从内核里面获取哪一些IP的路由发生了变化，然后通过标准BGP的路由协议扩散到整个其他的宿主机上，让外界都知道这个IP在这里，你们路由的时候得到这里来。</p>
<p><strong>架构特点</strong></p>
<p>由于Calico是一种纯三层的实现，因此可以避免与二层方案相关的数据包封装的操作，中间没有任何的NAT，没有任何的overlay，所以它的转发效率可能是所有方案中最高的，因为它的包直接走原生TCP/IP的协议栈，它的隔离也因为这个栈而变得好做。因为TCP/IP的协议栈提供了一整套的防火墙的规则，所以它可以通过IPTABLES的规则达到比较复杂的隔离逻辑。</p>
<h2 id="Calico的两种工作模式"><a href="#Calico的两种工作模式" class="headerlink" title="Calico的两种工作模式"></a>Calico的两种工作模式</h2><h3 id="IPIP"><a href="#IPIP" class="headerlink" title="IPIP"></a>IPIP</h3><p>从字面来理解，就是把一个IP数据包又套在一个IP包里，即把 IP 层封装到 IP 层的一个 tunnel。它的作用其实基本上就相当于一个基于IP层的网桥！一般来说，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。 </p>
<h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><p>一个msater节点，ip 172.171.5.95，一个node节点 ip 172.171.5.96 </p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150641464-621788389.png" alt="img"></p>
<p>创建一个daemonset的应用，pod1落在master节点上 ip地址为192.168.236.3，pod2落在node节点上 ip地址为192.168.190.203</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150652618-320617155.png" alt="img"></p>
<p>pod1 ping pod2</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413153642465-2094530861.png" alt="img"></p>
<h4 id="ping包之旅"><a href="#ping包之旅" class="headerlink" title="ping包之旅"></a>ping包之旅</h4><p>pod1上的路由信息</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150713064-1083686463.png" alt="img"></p>
<p>根据路由信息，ping 192.168.190.203，会匹配到第一条。第一条路由的意思是：去往任何网段的数据包都发往网管169.254.1.1，然后从eth0网卡发送出去。</p>
<p>路由表中Flags标志的含义：</p>
<table>
<thead>
<tr>
<th>Flags</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>U</td>
<td>up表示当前为启动状态</td>
</tr>
<tr>
<td>H</td>
<td>host表示该路由为一个主机，多为达到数据包的路由</td>
</tr>
<tr>
<td>G</td>
<td>Gateway 表示该路由是一个网关，如果没有说明目的地是直连的</td>
</tr>
<tr>
<td>D</td>
<td>Dynamicaly 表示该d路由是重定向报文修改</td>
</tr>
<tr>
<td>M</td>
<td>表示该路由已被重定向报文修改</td>
</tr>
</tbody></table>
<p>master节点上的路由信息</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150720233-1995872444.png" alt="img"></p>
<p>当ping包来到master节点上，会匹配到路由tunl0。该路由的意思是：去往192.169.190.192/26的网段的数据包都发往网关172.171.5.96。因为pod1在5.95，pod2在5.96。所以数据包就通过设备tunl0发往到node节点上。 </p>
<p>node节点上路由信息</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413154329954-1165326319.png" alt="img"></p>
<p>当node节点网卡收到数据包之后，发现去往的目的ip为192.168.190.203，于是匹配到红线的路由。该路由的意思是：192.168.190.203是本机直连设备，去往设备的数据包发往caliadce112d250。</p>
<p>那么该设备是什么呢？这个设备就是veth  pair的一端。在创建pod2时calico会给pod2创建一个veth  pair设备。一端是pod2的网卡，另一端就是我们看到的caliadce112d250。下面我们验证一下。在pod2中安装ethtool工具，然后使用ethtool -S eth0,查看veth pair另一端的设备号。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413154707177-2093232618.png" alt="img"></p>
<p>pod2网卡另一端的设备号是18，在node上查看编号为18的网络设备，可以发现该网络设备就是caliadce112d250。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413155040787-1729369707.png" alt="img"></p>
<p>所以，node上的路由，发送caliadce112d250的数据其实就是发送到pod2的网卡中。ping包的旅行到这里就到了目的地。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150729776-1365068043.png" alt="img"></p>
<p>查看一下pod2中的路由信息，发现该路由信息和pod1中是一样的。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150746241-395523835.png" alt="img"></p>
<p>顾名思义，IPIP网络就是将IP网络封装在IP网络里。IPIP网络的特点是所有pod的数据流量都从隧道tunl0发送，并且在tunl0这增加了一层传输层的封包。</p>
<p>在master网卡上抓包分析该过程。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190414232527057-801852995.png" alt="img"></p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150813156-308581738.png" alt="img"></p>
<p>打开ICMP 285，pod1 ping pod2的数据包，能够看到该数据包一共5层，其中IP所在的网络层有两个，分别是pod之间的网络和主机之间的网络封装。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150820715-66735737.png" alt="img"></p>
<p>根据数据包的封装顺序，应该是在pod1 ping pod2的ICMP包外面多封装了一层主机之间的数据包</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190414173605263-65569449.png" alt="img"></p>
<p>之所以要这样做是因为tunl0是一个隧道端点设备，在数据到达时要加上一层封装，便于发送到对端隧道设备中。 </p>
<p>两层IP封装的具体内容</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190413150826196-1894311200.png" alt="img"></p>
<p>ipip的连接方式</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415165144848-1984358878.png" alt="img"></p>
<h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>边界网关协议（Border Gateway Protocol, BGP）是互联网上一个核心的去中心化自治路由协议。它通过维护IP路由表或‘前缀’表来实现自治系统（AS）之间的可达性，属于矢量路由协议。BGP不使用传统的内部网关协议（IGP）的指标，而使用基于路径、网络策略或规则集来决定路由。因此，它更适合被称为矢量性协议，而不是路由协议。BGP，通俗的讲就是讲接入到机房的多条线路（如电信、联通、移动等）融合为一体，实现多线单IP，BGP 机房的优点：服务器只需要设置一个IP地址，最佳访问路由是由网络上的骨干路由器根据路由跳数与其它技术指标来确定的，不会占用服务器的任何系统。</p>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>在安装calico网络时，默认安装是IPIP网络。calico.yaml文件中，将CALICO_IPV4POOL_IPIP的值修改成 “off”，就能够替换成BGP网络。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190414174416871-1167710181.png" alt="img"></p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>BGP网络相比较IPIP网络，最大的不同之处就是没有了隧道设备 tunl0。 前面介绍过IPIP网络pod之间的流量发送tunl0，然后tunl0发送对端设备。BGP网络中，pod之间的流量直接从网卡发送目的地，减少了tunl0这个环节。</p>
<p>master节点上路由信息。从路由信息来看，没有tunl0设备。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415113440788-275117848.png" alt="img"></p>
<p>同样创建一个daemonset，pod1在master节点上，pod2在node节点上</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415114541797-340745707.png" alt="img"></p>
<h4 id="ping包之旅-1"><a href="#ping包之旅-1" class="headerlink" title="ping包之旅"></a>ping包之旅</h4><p>pod1 ping pod2。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415114230073-496262441.png" alt="img"></p>
<p>根据pod1中的路由信息，ping包通过eth0网卡发送到master节点上。</p>
<p>master节点上路由信息。根据匹配到的 192.168.190.192 路由，该路由的意思是：去往网段192.168.190.192/26 的数据包，发送网段172.171.5.96。而5.96就是node节点。所以，该数据包直接发送了5.96节点。 </p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415114439204-1886327378.png" alt="img"></p>
<p>node节点上的路由信息。根据匹配到的192.168.190.192的路由，数据将发送给 cali6fcd7d1702e设备，该设备和上面分析的是一样，为pod2的veth pair 的一端。数据就直接发送给pod2的网卡。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415115008617-409053518.png" alt="img"></p>
<p>当pod2对ping包做出回应之后，数据到达node节点上，匹配到192.168.236.0的路由，该路由说的是：去往网段192.168.236.0/26 的数据，发送给网关 172.171.5.95。数据包就直接通过网卡ens160，发送到master节点上。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415115329941-1036275159.png" alt="img"></p>
<p>通过在master节点上抓包，查看经过的流量，筛选出ICMP，找到pod1 ping pod2的数据包。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415115718930-42251257.png" alt="img"></p>
<p>可以看到BGP网络下，没有使用IPIP模式，数据包是正常的封装。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415113605760-703346562.png" alt="img"></p>
<p>值得注意的是mac地址的封装。192.168.236.0是pod1的ip，192.168.190.198是pod2的ip。而源mac地址是 master节点网卡的mac，目的mac是node节点的网卡的mac。这说明，在  master节点的路由接收到数据，重新构建数据包时，使用arp请求，将node节点的mac拿到，然后封装到数据链路层。</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415113611124-513029729.png" alt="img"></p>
<p>BGP的连接方式：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/1060878-20190415165320714-135136611.png" alt="img"></p>
<h3 id="两种网络对比"><a href="#两种网络对比" class="headerlink" title="两种网络对比"></a>两种网络对比</h3><p><strong>IPIP网络</strong>：</p>
<p>流量：tunlo设备封装数据，形成隧道，承载流量。</p>
<p>适用网络类型：适用于互相访问的pod不在同一个网段中，跨网段访问的场景。外层封装的ip能够解决跨网段的路由问题。</p>
<p>效率：流量需要tunl0设备封装，效率略低</p>
<p><strong>BGP网络</strong>：</p>
<p>流量：使用路由信息导向流量</p>
<p>适用网络类型：适用于互相访问的pod在同一个网段，适用于大型网络。</p>
<p>效率：原生hostGW，效率高</p>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>(1) 缺点租户隔离问题</p>
<p>Calico 的三层方案是直接在 host 上进行路由寻址，那么对于多租户如果使用同一个 CIDR 网络就面临着地址冲突的问题。</p>
<p>(2) 路由规模问题</p>
<p>通过路由规则可以看出，路由规模和 pod 分布有关，如果 pod离散分布在 host 集群中，势必会产生较多的路由项。</p>
<p>(3) iptables 规则规模问题</p>
<p>1台 Host 上可能虚拟化十几或几十个容器实例，过多的 iptables 规则造成复杂性和不可调试性，同时也存在性能损耗。</p>
<p>(4) 跨子网时的网关路由问题</p>
<p>当对端网络不为二层可达时，需要通过三层路由机时，需要网关支持自定义路由配置，即 pod 的目的地址为本网段的网关地址，再由网关进行跨三层转发。</p>
<h2 id="补充：169-254-1-1到底是个啥"><a href="#补充：169-254-1-1到底是个啥" class="headerlink" title="补充：169.254.1.1到底是个啥"></a>补充：169.254.1.1到底是个啥</h2><p>先随便瞅一眼一个容器的默认网关</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip route</span><br><span class="line">default via 169.254.1.1 dev eth0</span><br><span class="line">169.254.1.1 dev eth0 scope link</span><br></pre></td></tr></table></figure>
<p>现在问题来了，从路由表可以知道 <code>169.254.1.1</code> 是容器的默认网关，但却找不到任何一张网卡对应这个 IP 地址，这是个什么鬼？</p>
<p>莫慌，先回忆一下，当一个数据包的目的地址不是本机时，就会查询路由表，从路由表中查到网关后，它首先会通过 <code>ARP</code> 获得网关的 MAC 地址，然后在发出的网络数据包中将目标 MAC 改为网关的 MAC，而网关的 IP 地址不会出现在任何网络包头中。也就是说，没有人在乎这个 IP 地址究竟是什么，只要能找到对应的 MAC 地址，能响应 ARP 就行了。</p>
<p>想到这里，我们就可以继续往下进行了，可以通过 <code>ip neigh</code> 命令查看一下本地的 ARP 缓存：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ip neigh</span><br><span class="line">169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee REACHABLE</span><br></pre></td></tr></table></figure>
<p>这个 MAC 地址应该是 Calico 硬塞进去的，而且还能响应 ARP。但它究竟是怎么实现的呢？</p>
<p>我们先来回想一下正常情况，内核会对外发送 ARP 请求，询问整个二层网络中谁拥有 <code>169.254.1.1</code> 这个 IP 地址，拥有这个 IP 地址的设备会将自己的 MAC<br> 地址返回给对方。但现在的情况比较尴尬，容器和主机都没有这个 IP 地址，甚至连主机上的端口 <code>calicba2f87f6bb</code>，MAC 地址也是一个无用的 <code>ee:ee:ee:ee:ee:ee</code>。按道理容器和主机网络根本就无法通信才对呀！所以 Calico 是怎么做到的呢？</p>
<p>这里我就不绕弯子了，实际上 Calico 利用了网卡的代理 ARP 功能。代理 ARP 是 ARP 协议的一个变种，当 ARP  请求目标跨网段时，网关设备收到此 ARP 请求，会用自己的 MAC 地址返回给请求者，这便是代理 ARP（Proxy ARP）。举个例子：</p>
<p><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/2019-07-30-061928.jpg" alt="img"></p>
<p>上面这张图中，电脑发送 ARP 请求服务器 8.8.8.8 的 MAC 地址，路由器（网关）收到这个请求时会进行判断，由于目标  8.8.8.8 不属于本网段（即跨网段），此时便返回自己的接口 MAC 地址给 PC，后续电脑访问服务器时，目标 MAC 直接封装为  MAC254。</p>
<p>现在我们知道，Calico 本质上还是利用了代理 ARP 撒了一个“善意的谎言”，下面我们来确认一下。</p>
<p>查看宿主机的网卡信息和路由信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr</span><br><span class="line">...</span><br><span class="line">771: calicba2f87f6bb@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1440 qdisc noqueue state UP group default</span><br><span class="line">    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 14</span><br><span class="line">    inet6 fe80::ecee:eeff:feee:eeee/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">$ ip route </span><br><span class="line">...</span><br><span class="line">172.17.8.2 dev calicba2f87f6bb scope link</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看是否开启代理 ARP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/conf/calicba2f87f6bb/proxy_arp</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果还不放心，可以通过 tcpdump 抓包验证一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i calicba2f87f6bb -e -nn</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on calicba2f87f6bb, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line"> </span><br><span class="line">14:27:13.565539 ee:ee:ee:ee:ee:ee &gt; 0a:58:ac:1c:ce:12, ethertype IPv4 (0x0800), length 4191: 10.96.0.1.443 &gt; 172.17.8.2.36180: Flags [P.], seq 403862039:403866164, ack 2023703985, win 990, options [nop,nop,TS val 331780572 ecr 603755526], length 4125</span><br><span class="line">14:27:13.565613 0a:58:ac:1c:ce:12 &gt; ee:ee:ee:ee:ee:ee, ethertype IPv4 (0x0800), length 66: 172.17.8.2.36180 &gt; 10.96.0.1.443: Flags [.], ack 4125, win 2465, options [nop,nop,TS val 603758497 ecr 331780572], length 0</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>Calico 通过一个巧妙的方法将 workload 的所有流量引导到一个特殊的网关 169.254.1.1，从而引流到主机的 calixxx 网络设备上，最终将二三层流量全部转换成三层流量来转发。</li>
<li>在主机上通过开启代理 ARP 功能来实现 ARP 应答，使得 ARP 广播被抑制在主机上，抑制了广播风暴，也不会有 ARP 表膨胀的问题。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:kinmfer@foxmail.com">Kinmfer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kinmfer.github.io/2021/01/29/%E4%BA%91-Kubernetes-%E7%BD%91%E7%BB%9C-Flannel+Calico/">https://kinmfer.github.io/2021/01/29/云-Kubernetes-网络-Flannel+Calico/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Kinmfer.github.io" target="_blank">Kinmfer's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/k8s/">k8s</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">网络模型</a><a class="post-meta__tags" href="/tags/Flannel/">Flannel</a><a class="post-meta__tags" href="/tags/Calico/">Calico</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/29/GOLANG-11-%E5%8C%85/"><img class="prev-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GOLANG-11-包</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/27/GOLANG-10-%E7%BB%93%E6%9E%84%E4%BD%93/"><img class="next-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GOLANG-10-结构体</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/26/云-Kubernetes-网络-基本模型/" title="Kubernetes-网络模型"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Kubernetes-网络模型</div></div></a></div><div><a href="/2021/04/22/云-Kubernetes-升级/" title="云计算-Kubernetes-升级"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-22</div><div class="title">云计算-Kubernetes-升级</div></div></a></div><div><a href="/2021/01/26/云-Kubernetes-服务暴露-ingress/" title="Kubernetes-服务暴露-ingress"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Kubernetes-服务暴露-ingress</div></div></a></div><div><a href="/2021/01/26/云-Kubernetes-安全机制/" title="Kubernetes-安全机制"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-26</div><div class="title">Kubernetes-安全机制</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81MTkzMi8yODQxMw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kinmfer</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kinmfer"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kinmfer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:kinmfer@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！本博客用于记录一些学习过程中的文章，包括原创，也包括转录其他大神的博客。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Flannel"><span class="toc-number">1.</span> <span class="toc-text">Flannel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flannel%E5%AF%B9%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82%E6%8F%90%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">Flannel对网络要求提出的解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E7%9B%B8%E4%B8%8D%E5%86%B2%E7%AA%81%E7%9A%84ip"><span class="toc-number">1.2.1.</span> <span class="toc-text">互相不冲突的ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E4%B9%8B%E9%97%B4%E4%BA%92%E7%9B%B8%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">Pod之间互相访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flannel%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">Flannel架构原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod1%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E5%88%B0cni0"><span class="toc-number">1.4.1.</span> <span class="toc-text">Pod1中的容器到cni0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cni0%E5%88%B0flannel1-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">cni0到flannel1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flannel1"><span class="toc-number">1.4.3.</span> <span class="toc-text">flannel1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%AB%AFflannel1"><span class="toc-number">1.4.4.</span> <span class="toc-text">对端flannel1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cni0%E5%88%B0pod"><span class="toc-number">1.4.5.</span> <span class="toc-text">cni0到pod</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%90%8E%E7%AB%AF%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">1.5.</span> <span class="toc-text">不同后端的封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%80%A7%E8%83%BD%E5%B7%AE%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">UDP模式（性能差）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VXLAN%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%80%A7%E8%83%BD%E8%BE%83%E5%A5%BD%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">VXLAN模式（性能较好）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#host-gw%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%80%A7%E8%83%BD%E6%9C%80%E9%AB%98%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">host-gw模式（性能最高）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Calico"><span class="toc-number">2.</span> <span class="toc-text">Calico</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calico%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">Calico架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calico%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">Calico的两种工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPIP"><span class="toc-number">2.3.1.</span> <span class="toc-text">IPIP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">测试环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E5%8C%85%E4%B9%8B%E6%97%85"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">ping包之旅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP"><span class="toc-number">2.3.2.</span> <span class="toc-text">BGP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">修改配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ping%E5%8C%85%E4%B9%8B%E6%97%85-1"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">ping包之旅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.3.</span> <span class="toc-text">两种网络对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">存在问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A169-254-1-1%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5"><span class="toc-number">2.5.</span> <span class="toc-text">补充：169.254.1.1到底是个啥</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/11/%E7%AC%94%E8%AE%B0-02-Golang%E6%B3%A8%E6%84%8F%E7%82%B9/" title="笔记-02-Golang注意点"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/GO.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笔记-02-Golang注意点"/></a><div class="content"><a class="title" href="/2021/09/11/%E7%AC%94%E8%AE%B0-02-Golang%E6%B3%A8%E6%84%8F%E7%82%B9/" title="笔记-02-Golang注意点">笔记-02-Golang注意点</a><time datetime="2021-09-11T03:39:21.000Z" title="发表于 2021-09-11 11:39:21">2021-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/10/%E7%AC%94%E8%AE%B0-01-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84shell%E8%84%9A%E6%9C%AC/" title="笔记-01-如何编写可靠的shell脚本"><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笔记-01-如何编写可靠的shell脚本"/></a><div class="content"><a class="title" href="/2021/09/10/%E7%AC%94%E8%AE%B0-01-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84shell%E8%84%9A%E6%9C%AC/" title="笔记-01-如何编写可靠的shell脚本">笔记-01-如何编写可靠的shell脚本</a><time datetime="2021-09-10T11:25:37.000Z" title="发表于 2021-09-10 19:25:37">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/Vue-2.x%E7%AC%94%E8%AE%B0/" title="Vue 2.x笔记"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue 2.x笔记"/></a><div class="content"><a class="title" href="/2021/05/22/Vue-2.x%E7%AC%94%E8%AE%B0/" title="Vue 2.x笔记">Vue 2.x笔记</a><time datetime="2021-05-22T11:30:24.000Z" title="发表于 2021-05-22 19:30:24">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/13/%E5%AE%9E%E7%94%A8Python%E8%84%9A%E6%9C%AC/" title="实用Python脚本"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/python.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实用Python脚本"/></a><div class="content"><a class="title" href="/2021/05/13/%E5%AE%9E%E7%94%A8Python%E8%84%9A%E6%9C%AC/" title="实用Python脚本">实用Python脚本</a><time datetime="2021-05-13T01:25:54.000Z" title="发表于 2021-05-13 09:25:54">2021-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/13/%E5%AE%9E%E7%94%A8Shell%E8%84%9A%E6%9C%AC/" title="实用Shell脚本"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/shell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实用Shell脚本"/></a><div class="content"><a class="title" href="/2021/05/13/%E5%AE%9E%E7%94%A8Shell%E8%84%9A%E6%9C%AC/" title="实用Shell脚本">实用Shell脚本</a><time datetime="2021-05-13T01:12:20.000Z" title="发表于 2021-05-13 09:12:20">2021-05-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Kinmfer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kinmfer.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'vSKb5nQqvUv44yjbvGjUmk3E-gzGzoHsz',
      appKey: '4TRbJGECRE8pcN777qgBXsKO',
      placeholder: '记得留下你的昵称和邮箱,可以快速收到回复哦~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_����":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_͵Ц":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_�ټ�":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_��Į":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_��ŭ":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_�ɰ�":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_��Ѫ":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_��":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_Ż��":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_��Ц":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_���":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_ί��":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_΢Ц":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_˼��":"90cf159733e558137ed20aa04d09964436f618a1.png"},
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="//code.tidio.co/mzqu2o1lbhle9bvhab8bexgtiyxgkheb.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>