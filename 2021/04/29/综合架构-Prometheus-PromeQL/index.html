<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>综合架构-Prometheus-PromQL | Kinmfer's Blogs</title><meta name="keywords" content="监控,Prometheus"><meta name="author" content="Kinmfer,kinmfer@foxmail.com"><meta name="copyright" content="Kinmfer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="理解时间序列123456# HELP node_cpu Seconds the cpus spent in each mode.# TYPE node_cpu counternode_cpu&amp;#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&quot;&amp;#125; 362812.7890625# HELP node_load1 1m load">
<meta property="og:type" content="article">
<meta property="og:title" content="综合架构-Prometheus-PromQL">
<meta property="og:url" content="https://kinmfer.github.io/2021/04/29/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Prometheus-PromeQL/index.html">
<meta property="og:site_name" content="Kinmfer&#39;s Blogs">
<meta property="og:description" content="理解时间序列123456# HELP node_cpu Seconds the cpus spent in each mode.# TYPE node_cpu counternode_cpu&amp;#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&quot;&amp;#125; 362812.7890625# HELP node_load1 1m load">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/prometheus.jpg">
<meta property="article:published_time" content="2021-04-29T08:03:41.000Z">
<meta property="article:modified_time" content="2021-04-29T08:10:12.732Z">
<meta property="article:author" content="Kinmfer">
<meta property="article:tag" content="监控">
<meta property="article:tag" content="Prometheus">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/kinmfer/BlogImages/raw/master/img/prometheus.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kinmfer.github.io/2021/04/29/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Prometheus-PromeQL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c46ed77365f502de73543fbf10399875";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"C2N62A47W9","apiKey":"0c62f17095ec2a20c19657511a42c0b1","indexName":"Blogs","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"这篇文章更新于","messageNext":"天前,内容可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Kinmfer","link":"链接: ","source":"来源: Kinmfer's Blogs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-29 16:10:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/prometheus.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kinmfer's Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">综合架构-Prometheus-PromQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-29T08:03:41.000Z" title="发表于 2021-04-29 16:03:41">2021-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-29T08:10:12.732Z" title="更新于 2021-04-29 16:10:12">2021-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/">综合架构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1/">监控服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="综合架构-Prometheus-PromQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/04/29/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Prometheus-PromeQL/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/04/29/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Prometheus-PromeQL/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="理解时间序列"><a href="#理解时间序列" class="headerlink" title="理解时间序列"></a>理解时间序列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HELP node_cpu Seconds the cpus spent in each mode.</span><br><span class="line"># TYPE node_cpu counter</span><br><span class="line">node_cpu&#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&quot;&#125; 362812.7890625</span><br><span class="line"># HELP node_load1 1m load average.</span><br><span class="line"># TYPE node_load1 gauge</span><br><span class="line">node_load1 3.0703125</span><br></pre></td></tr></table></figure>
<p>其中非#开头的每一行表示当前Node Exporter采集到的一个监控样本：node_cpu和node_load1表明了当前指标的名称、大括号中的标签则反映了当前样本的一些特征和维度、浮点数则是该监控样本的具体值。</p>
<h2 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h2><p>Prometheus会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。time-series是按照时间戳和值的序列顺序存放的，我们称之为向量(vector). 每条time-series通过指标名称(metrics name)和一组标签集(labelset)命名。</p>
<p>在time-series中的每一个点称为一个样本（sample），样本由以下三部分组成：</p>
<ul>
<li>指标(metric)：metric name和描述当前样本特征的labelsets;</li>
<li>时间戳(timestamp)：一个精确到毫秒的时间戳;</li>
<li>样本值(value)： 一个float64的浮点型数据表示当前样本的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;</span><br><span class="line">http_request_total&#123;status&#x3D;&quot;200&quot;, method&#x3D;&quot;GET&quot;&#125;@1434417560938 &#x3D;&gt; 94355</span><br><span class="line">http_request_total&#123;status&#x3D;&quot;200&quot;, method&#x3D;&quot;GET&quot;&#125;@1434417561287 &#x3D;&gt; 94334</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status&#x3D;&quot;404&quot;, method&#x3D;&quot;GET&quot;&#125;@1434417560938 &#x3D;&gt; 38473</span><br><span class="line">http_request_total&#123;status&#x3D;&quot;404&quot;, method&#x3D;&quot;GET&quot;&#125;@1434417561287 &#x3D;&gt; 38544</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status&#x3D;&quot;200&quot;, method&#x3D;&quot;POST&quot;&#125;@1434417560938 &#x3D;&gt; 4748</span><br><span class="line">http_request_total&#123;status&#x3D;&quot;200&quot;, method&#x3D;&quot;POST&quot;&#125;@1434417561287 &#x3D;&gt; 4785</span><br></pre></td></tr></table></figure>
<h2 id="指标-Metric"><a href="#指标-Metric" class="headerlink" title="指标(Metric)"></a>指标(Metric)</h2><p>在形式上，所有的指标(Metric)都通过如下格式标示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;&#x3D;&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>
<p>指标的名称(metric name)可以反映被监控样本的含义（比如，<code>http_request_total</code> - 表示当前系统接收到的HTTP请求总量）。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。</p>
<p>标签(label)反映了当前样本的特征维度，通过这些维度Prometheus可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式<code>[a-zA-Z_][a-zA-Z0-9_]*</code>。</p>
<p>其中以<code>__</code>作为前缀的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何Unicode编码的字符。在Prometheus的底层实现中指标名称实际上是以<code>__name__=&lt;metric name&gt;</code>的形式保存在数据库中的，因此以下两种方式均表示的同一条time-series：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total&#123;method&#x3D;&quot;POST&quot;, handler&#x3D;&quot;&#x2F;messages&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>等同于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__&#x3D;&quot;api_http_requests_total&quot;，method&#x3D;&quot;POST&quot;, handler&#x3D;&quot;&#x2F;messages&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>在Prometheus源码中也可以找到指标(Metric)对应的数据结构，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Metric LabelSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LabelSet <span class="keyword">map</span>[LabelName]LabelValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LabelName <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LabelValue <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h1 id="Metrics类型"><a href="#Metrics类型" class="headerlink" title="Metrics类型"></a>Metrics类型</h1><p>在Prometheus的存储实现上所有的监控样本都是以time-series的形式保存在Prometheus内存的TSDB（时序数据库）中，而time-series所对应的监控指标(metric)也是通过labelset进行唯一命名的。</p>
<p>从存储上来讲所有的监控指标metric都是相同的，但是在不同的场景下这些metric又有一些细微的差异。 例如，在Node Exporter返回的样本中指标node_load1反应的是当前系统的负载状态，随着时间的变化这个指标返回的样本数据是在不断变化的。而指标node_cpu所获取到的样本数据却不同，它是一个持续增大的值，因为其反应的是CPU的累积使用时间，从理论上讲只要系统不关机，这个值是会无限变大的。</p>
<p>为了能够帮助用户理解和区分这些不同监控指标之间的差异，Prometheus定义了4种不同的指标类型(metric type)：Counter（计数器）、Gauge（仪表盘）、Histogram（直方图）、Summary（摘要）。</p>
<p>在Exporter返回的样本数据中，其注释中也包含了该样本的类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># HELP node_cpu Seconds the cpus spent in each mode.</span><br><span class="line"># TYPE node_cpu counter</span><br><span class="line">node_cpu&#123;cpu&#x3D;&quot;cpu0&quot;,mode&#x3D;&quot;idle&quot;&#125; 362812.7890625</span><br></pre></td></tr></table></figure>
<h2 id="Counter：只增不减的计数器"><a href="#Counter：只增不减的计数器" class="headerlink" title="Counter：只增不减的计数器"></a>Counter：只增不减的计数器</h2><p>Counter类型的指标其工作方式和计数器一样，只增不减（除非系统发生重置）。常见的监控指标，如http_requests_total，node_cpu都是Counter类型的监控指标。 一般在定义Counter类型指标的名称时推荐使用_total作为后缀。</p>
<p>Counter是一个简单但有强大的工具，例如我们可以在应用程序中记录某些事件发生的次数，通过以时序的形式存储这些数据，我们可以轻松的了解该事件产生速率的变化。 PromQL内置的聚合操作和函数可以让用户对这些数据进行进一步的分析：</p>
<p>例如，通过rate()函数获取HTTP请求量的增长率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>
<p>查询当前系统中，访问量前10的HTTP地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">topk(10,</span> <span class="string">http_requests_total)</span></span><br></pre></td></tr></table></figure>
<h2 id="Gauge：可增可减的仪表盘"><a href="#Gauge：可增可减的仪表盘" class="headerlink" title="Gauge：可增可减的仪表盘"></a>Gauge：可增可减的仪表盘</h2><p>与Counter不同，Gauge类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。常见指标如：node_memory_MemFree（主机当前空闲的内容大小）、node_memory_MemAvailable（可用内存大小）都是Gauge类型的监控指标。</p>
<p>通过Gauge指标，用户可以直接查看系统的当前状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_MemFree</span><br></pre></td></tr></table></figure>
<p>对于Gauge类型的监控指标，通过PromQL内置函数delta()可以获取样本在一段时间返回内的变化情况。例如，计算CPU温度在两个小时内的差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host&#x3D;&quot;zeus&quot;&#125;[2h])</span><br></pre></td></tr></table></figure>
<p>还可以使用deriv()计算样本的线性回归模型，甚至是直接使用predict_linear()对数据的变化趋势进行预测。例如，预测系统磁盘空间在4个小时之后的剩余情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job&#x3D;&quot;node&quot;&#125;[1h], 4 * 3600)</span><br></pre></td></tr></table></figure>
<h2 id="使用Histogram和Summary分析数据分布情况"><a href="#使用Histogram和Summary分析数据分布情况" class="headerlink" title="使用Histogram和Summary分析数据分布情况"></a>使用Histogram和Summary分析数据分布情况</h2><p>除了Counter和Gauge类型的监控指标以外，Prometheus还定义了Histogram和Summary的指标类型。Histogram和Summary主用用于统计和分析样本的分布情况。</p>
<p>在大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms的响应时间范围内，而个别请求的响应时间需要5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，而这种现象被称为长尾问题。</p>
<p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在0<del>10ms之间的请求数有多少而10</del>20ms之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram和Summary都是为了能够解决这样问题的存在，通过Histogram和Summary类型的监控指标，我们可以快速了解监控样本的分布情况。</p>
<p>例如，指标prometheus_tsdb_wal_fsync_duration_seconds的指标类型为Summary。 它记录了Prometheus Server中wal_fsync处理的处理时间，通过访问Prometheus Server的/metrics地址，可以获取到以下监控样本数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.# TYPE prometheus_tsdb_wal_fsync_duration_seconds summaryprometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.5&quot;&#125; 0.012352463prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.9&quot;&#125; 0.014458005prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile&#x3D;&quot;0.99&quot;&#125; 0.017316173prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002prometheus_tsdb_wal_fsync_duration_seconds_count 216</span><br></pre></td></tr></table></figure>
<p>从上面的样本中可以得知当前Prometheus Server进行wal_fsync操作的总次数为216次，耗时2.888716127000002s。其中中位数（quantile=0.5）的耗时为0.012352463，9分位数（quantile=0.9）的耗时为0.014458005s。</p>
<p>在Prometheus Server自身返回的样本数据中，我们还能找到类型为Histogram的监控指标prometheus_tsdb_compaction_chunk_range_bucket。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction# TYPE prometheus_tsdb_compaction_chunk_range histogramprometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;100&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;1600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;6400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;25600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;102400&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;409600&quot;&#125; 0prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;1.6384e+06&quot;&#125; 260prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;6.5536e+06&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;2.62144e+07&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_bucket&#123;le&#x3D;&quot;+Inf&quot;&#125; 780prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09prometheus_tsdb_compaction_chunk_range_count 780</span><br></pre></td></tr></table></figure>
<p>与Summary类型的指标相似之处在于Histogram类型的样本同样会反应当前指标的记录的总数(以_count作为后缀)以及其值的总量（以_sum作为后缀）。不同在于Histogram指标直接反应了在不同区间内样本的个数，区间通过标签len进行定义。</p>
<p>同时对于Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。不同在于Histogram通过histogram_quantile函数是在服务器端计算的分位数。 而Sumamry的分位数则是直接在客户端计算完成。因此对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。反之对于客户端而言Histogram消耗的资源更少。在选择这两种方式时用户应该按照自己的实际场景进行选择。</p>
<h1 id="PromQL使用"><a href="#PromQL使用" class="headerlink" title="PromQL使用"></a>PromQL使用</h1><p>Prometheus通过指标名称（metrics name）以及对应的一组标签（labelset）唯一定义一条时间序列。指标名称反映了监控样本的基本标识，而label则在这个基本特征上为采集到的数据提供了多种特征维度。用户可以基于这些特征维度过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<h2 id="查询时间序列"><a href="#查询时间序列" class="headerlink" title="查询时间序列"></a>查询时间序列</h2><p>当Prometheus通过Exporter采集到相应的监控指标样本数据后，我们就可以通过PromQL对监控样本数据进行查询。</p>
<p>当我们直接使用监控指标名称查询时，可以查询该指标下的所有时间序列。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该表达式会返回指标名称为http_requests_total的所有时间序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;alerts&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;&#x3D;(20889@1518096812.326)http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;graph&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;&#x3D;(21287@1518096812.326)</span><br></pre></td></tr></table></figure>
<p>PromQL还支持用户根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：完全匹配和正则匹配。</p>
<p>PromQL支持使用<code>=</code>和<code>!=</code>两种完全匹配模式：</p>
<ul>
<li>通过使用<code>label=value</code>可以选择那些标签满足表达式定义的时间序列；</li>
<li>反之使用<code>label!=value</code>则可以根据标签匹配排除时间序列；</li>
</ul>
<p>例如，如果我们只需要查询所有http_requests_total时间序列中满足标签instance为localhost:9090的时间序列，则可以使用如下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance&#x3D;&quot;localhost:9090&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>反之使用<code>instance!=&quot;localhost:9090&quot;</code>则可以排除这些时间序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;instance!&#x3D;&quot;localhost:9090&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用完全匹配的方式对时间序列进行过滤以外，PromQL还可以支持使用正则表达式作为匹配条件，多个表达式之间使用<code>|</code>进行分离：</p>
<ul>
<li>使用<code>label=~regx</code>表示选择那些标签符合正则表达式定义的时间序列；</li>
<li>反之使用<code>label!~regx</code>进行排除；</li>
</ul>
<p>例如，如果想查询多个环节下的时间序列序列可以使用如下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;environment&#x3D;~&quot;staging|testing|development&quot;,method!&#x3D;&quot;GET&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>直接通过类似于PromQL表达式<code>http_requests_total</code>查询时间序列时，返回值中只会包含该时间序列中的最新的一个样本值，这样的返回结果我们称之为__瞬时向量__。而相应的这样的表达式称之为__瞬时向量表达式__。</p>
<p>而如果我们想过去一段时间范围内的样本数据时，我们则需要使用__区间向量表达式__。区间向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器<code>[]</code>进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<p>该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;alerts&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;&#x3D;[    1@1518096812.326    1@1518096817.326    1@1518096822.326    1@1518096827.326    1@1518096832.326    1@1518096837.325]http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;graph&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;&#x3D;[    4 @1518096812.326    4@1518096817.326    4@1518096822.326    4@1518096827.326    4@1518096832.326    4@1518096837.325]</span><br></pre></td></tr></table></figure>
<p>通过区间向量表达式查询到的结果我们称为__区间向量__。</p>
<p>除了使用m表示分钟以外，PromQL的时间范围选择器支持其它时间单位：</p>
<ul>
<li>s - 秒</li>
<li>m - 分钟</li>
<li>h - 小时</li>
<li>d - 天</li>
<li>w - 周</li>
<li>y - 年</li>
</ul>
<h2 id="时间位移操作"><a href="#时间位移操作" class="headerlink" title="时间位移操作"></a>时间位移操作</h2><p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; # 瞬时向量表达式，选择当前最新的数据http_request_total&#123;&#125;[5m] # 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span><br></pre></td></tr></table></figure>
<p>而如果我们想查询，5分钟前的瞬时样本数据，或昨天一天的区间内的样本数据呢? 这个时候我们就可以使用位移操作，位移操作的关键字为<strong>offset</strong>。</p>
<p>可以使用offset时间位移操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; offset 5mhttp_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>
<h2 id="使用聚合操作"><a href="#使用聚合操作" class="headerlink" title="使用聚合操作"></a>使用聚合操作</h2><p>一般来说，如果描述样本特征的标签(label)在并非唯一的情况下，通过PromQL查询数据，会返回多条满足这些特征维度的时间序列。而PromQL提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 查询系统所有http请求的总量sum(http_request_total)# 按照mode计算主机CPU的平均使用时间avg(node_cpu) by (mode)# 按照主机查询各个主机的CPU使用率sum(sum(irate(node_cpu&#123;mode!&#x3D;&#39;idle&#39;&#125;[5m]))  &#x2F; sum(irate(node_cpu[5m]))) by (instance)</span><br></pre></td></tr></table></figure>
<h2 id="标量和字符串"><a href="#标量和字符串" class="headerlink" title="标量和字符串"></a>标量和字符串</h2><p>除了使用瞬时向量表达式和区间向量表达式以外，PromQL还直接支持用户使用标量(Scalar)和字符串(String)。</p>
<h3 id="标量（Scalar）：一个浮点型的数字值"><a href="#标量（Scalar）：一个浮点型的数字值" class="headerlink" title="标量（Scalar）：一个浮点型的数字值"></a>标量（Scalar）：一个浮点型的数字值</h3><p>标量只有一个数字，没有时序。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，当使用表达式count(http_requests_total)，返回的数据类型，依然是瞬时向量。用户可以通过内置函数scalar()将单个瞬时向量转换为标量。</p>
</blockquote>
<h3 id="字符串（String）：一个简单的字符串值"><a href="#字符串（String）：一个简单的字符串值" class="headerlink" title="字符串（String）：一个简单的字符串值"></a>字符串（String）：一个简单的字符串值</h3><p>直接使用字符串，作为PromQL表达式，则会直接返回字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;this is a string&quot;&#39;these are unescaped: \n \\ \t&#39;&#96;these are not unescaped: \n &#39; &quot; \t&#96;</span><br></pre></td></tr></table></figure>
<h2 id="合法的PromQL表达式"><a href="#合法的PromQL表达式" class="headerlink" title="合法的PromQL表达式"></a>合法的PromQL表达式</h2><p>所有的PromQL表达式都必须至少包含一个指标名称(例如http_request_total)，或者一个不会匹配到空字符串的标签过滤器(例如{code=”200”})。</p>
<p>因此以下两种方式，均为合法的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_request_total # 合法http_request_total&#123;&#125; # 合法&#123;method&#x3D;&quot;get&quot;&#125; # 合法</span><br></pre></td></tr></table></figure>
<p>而如下表达式，则不合法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;job&#x3D;~&quot;.*&quot;&#125; # 不合法</span><br></pre></td></tr></table></figure>
<p>同时，除了使用<code>&lt;metric name&gt;&#123;label=value&#125;</code>的形式以外，我们还可以使用内置的<code>__name__</code>标签来指定监控指标名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__&#x3D;~&quot;http_request_total&quot;&#125; # 合法&#123;__name__&#x3D;~&quot;node_disk_bytes_read|node_disk_bytes_written&quot;&#125; # 合法</span><br></pre></td></tr></table></figure>
<h1 id="PromQL操作符"><a href="#PromQL操作符" class="headerlink" title="PromQL操作符"></a>PromQL操作符</h1><p>使用PromQL除了能够方便的按照查询和过滤时间序列以外，PromQL还支持丰富的操作符，用户可以使用这些操作符对进一步的对事件序列进行二次加工。这些操作符包括：数学运算符，逻辑运算符，布尔运算符等等。</p>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>例如，我们可以通过指标node_memory_free_bytes_total获取当前主机可用的内存空间大小，其样本单位为Bytes。这是如果客户端要求使用MB作为单位响应数据，那只需要将查询到的时间序列的样本值进行单位换算即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total &#x2F; (1024 * 1024)</span><br></pre></td></tr></table></figure>
<p>node_memory_free_bytes_total表达式会查询出所有满足表达式条件的时间序列，在上一小节中我们称该表达式为瞬时向量表达式，而返回的结果成为瞬时向量。</p>
<p>当瞬时向量与标量之间进行数学运算时，数学运算符会依次作用域瞬时向量中的每一个样本值，从而得到一组新的时间序列。</p>
<p>而如果是瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果我们想根据node_disk_bytes_written和node_disk_bytes_read获取主机磁盘IO的总量，可以使用如下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_disk_bytes_written + node_disk_bytes_read</span><br></pre></td></tr></table></figure>
<p>那这个表达式是如何工作的呢？依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;device&#x3D;&quot;sda&quot;,instance&#x3D;&quot;localhost:9100&quot;,job&#x3D;&quot;node_exporter&quot;&#125;&#x3D;&gt;1634967552@1518146427.807 + 864551424@1518146427.807&#123;device&#x3D;&quot;sdb&quot;,instance&#x3D;&quot;localhost:9100&quot;,job&#x3D;&quot;node_exporter&quot;&#125;&#x3D;&gt;0@1518146427.807 + 1744384@1518146427.807</span><br></pre></td></tr></table></figure>
<p>PromQL支持的所有数学运算符如下所示：</p>
<ul>
<li><code>+</code> (加法)</li>
<li><code>-</code> (减法)</li>
<li><code>*</code> (乘法)</li>
<li><code>/</code> (除法)</li>
<li><code>%</code> (求余)</li>
<li><code>^</code> (幂运算)</li>
</ul>
<h2 id="使用布尔运算过滤时间序列"><a href="#使用布尔运算过滤时间序列" class="headerlink" title="使用布尔运算过滤时间序列"></a>使用布尔运算过滤时间序列</h2><p>在PromQL通过标签匹配模式，用户可以根据时间序列的特征维度对其进行查询。而布尔运算则支持用户根据时间序列中样本的值，对时间序列进行过滤。</p>
<p>例如，通过数学运算符我们可以很方便的计算出，当前所有主机节点的内存使用率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) &#x2F; node_memory_bytes_total</span><br></pre></td></tr></table></figure>
<p>而系统管理员在排查问题的时候可能只想知道当前内存使用率超过95%的主机呢？通过使用布尔运算符可以方便的获取到该结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) &#x2F; node_memory_bytes_total &gt; 0.95</span><br></pre></td></tr></table></figure>
<p>瞬时向量与标量进行布尔运算时，PromQL依次比较向量中的所有时间序列样本的值，如果比较结果为true则保留，反之丢弃。</p>
<p>瞬时向量与瞬时向量直接进行布尔运算时，同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。</p>
<p>目前，Prometheus支持以下布尔运算符如下：</p>
<ul>
<li><code>==</code> (相等)</li>
<li><code>!=</code> (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
</ul>
<h2 id="使用bool修饰符改变布尔运算符的行为"><a href="#使用bool修饰符改变布尔运算符的行为" class="headerlink" title="使用bool修饰符改变布尔运算符的行为"></a>使用bool修饰符改变布尔运算符的行为</h2><p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下我们可能需要的是真正的布尔结果。例如，只需要知道当前模块的HTTP请求量是否&gt;=1000，如果大于等于1000则返回1（true）否则返回0（false）。这时可以使用bool修饰符改变布尔运算的默认行为。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; bool 1000</span><br></pre></td></tr></table></figure>
<p>使用bool修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1。从而形成一条新的时间序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;query&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;  1http_requests_total&#123;code&#x3D;&quot;200&quot;,handler&#x3D;&quot;query_range&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;,method&#x3D;&quot;get&quot;&#125;  0</span><br></pre></td></tr></table></figure>
<p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用bool修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &#x3D;&#x3D; bool 2 # 结果为1</span><br></pre></td></tr></table></figure>
<h2 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h2><p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，我们称为瞬时向量。 通过集合运算，可以在两个瞬时向量与瞬时向量之间进行相应的集合操作。目前，Prometheus支持以下集合运算符：</p>
<ul>
<li><code>and</code> (并且)</li>
<li><code>or</code> (或者)</li>
<li><code>unless</code> (排除)</li>
</ul>
<p><strong><em>vector1 and vector2</em></strong> 会产生一个由vector1的元素组成的新的向量。该向量包含vector1中完全匹配vector2中的元素组成。</p>
<p><strong><em>vector1 or vector2</em></strong> 会产生一个新的向量，该向量包含vector1中所有的样本数据，以及vector2中没有与vector1匹配到的样本数据。</p>
<p><strong><em>vector1 unless vector2</em></strong> 会产生一个新的向量，新向量中的元素由vector1中没有与vector2匹配的元素组成。</p>
<h2 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h2><p>对于复杂类型的表达式，需要了解运算操作的运行优先级</p>
<p>例如，查询主机的CPU使用率，可以使用表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 * (1 - avg (irate(node_cpu&#123;mode&#x3D;&#39;idle&#39;&#125;[5m])) by(job) )</span><br></pre></td></tr></table></figure>
<p>其中irate是PromQL中的内置函数，用于计算区间向量中时间序列每秒的即时增长率。关于内置函数的部分，会在下一节详细介绍。</p>
<p>在PromQL操作符中优先级由高到低依次为：</p>
<ol>
<li><code>^</code></li>
<li><code>*, /, %</code></li>
<li><code>+, -</code></li>
<li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li>
<li><code>and, unless</code></li>
<li><code>or</code></li>
</ol>
<h2 id="匹配模式详解"><a href="#匹配模式详解" class="headerlink" title="匹配模式详解"></a>匹配模式详解</h2><p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。</p>
<p>接下来将介绍在PromQL中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</p>
<h3 id="一对一匹配"><a href="#一对一匹配" class="headerlink" title="一对一匹配"></a>一对一匹配</h3><p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector1 &lt;operator&gt; vector2</span><br></pre></td></tr></table></figure>
<p>在操作符两边表达式标签不一致的情况下，可以使用on(label list)或者ignoring(label list）来修改便签的匹配行为。使用ignoreing可以在匹配时忽略某些便签。而on则用于将匹配行为限定在某些便签之内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p>例如当存在样本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;method&#x3D;&quot;get&quot;, code&#x3D;&quot;500&quot;&#125;  24method_code:http_errors:rate5m&#123;method&#x3D;&quot;get&quot;, code&#x3D;&quot;404&quot;&#125;  30method_code:http_errors:rate5m&#123;method&#x3D;&quot;put&quot;, code&#x3D;&quot;501&quot;&#125;  3method_code:http_errors:rate5m&#123;method&#x3D;&quot;post&quot;, code&#x3D;&quot;500&quot;&#125; 6method_code:http_errors:rate5m&#123;method&#x3D;&quot;post&quot;, code&#x3D;&quot;404&quot;&#125; 21method:http_requests:rate5m&#123;method&#x3D;&quot;get&quot;&#125;  600method:http_requests:rate5m&#123;method&#x3D;&quot;del&quot;&#125;  34method:http_requests:rate5m&#123;method&#x3D;&quot;post&quot;&#125; 120</span><br></pre></td></tr></table></figure>
<p>使用PromQL表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;code&#x3D;&quot;500&quot;&#125; &#x2F; ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用ignoring(code)，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>
<p>因此结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;method&#x3D;&quot;get&quot;&#125;  0.04            &#x2F;&#x2F;  24 &#x2F; 600&#123;method&#x3D;&quot;post&quot;&#125; 0.05            &#x2F;&#x2F;   6 &#x2F; 120</span><br></pre></td></tr></table></figure>
<p>同时由于method为put和del的样本找不到匹配项，因此不会出现在结果当中。</p>
<h3 id="多对一和一对多"><a href="#多对一和一对多" class="headerlink" title="多对一和一对多"></a>多对一和一对多</h3><p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与”多”侧的多个元素匹配的情况。在这种情况下，必须使用group修饰符：group_left或者group_right来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用ignoring和on修饰符来排除或者限定匹配的标签列表。</p>
<p>例如,使用表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m &#x2F; ignoring(code) group_left method:http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式中，左向量<code>method_code:http_errors:rate5m</code>包含两个标签method和code。而右向量<code>method:http_requests:rate5m</code>中只包含一个标签method，因此匹配时需要使用ignoring限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用group修饰符group_left指定左向量具有更好的基数。</p>
<p>最终的运算结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;method&#x3D;&quot;get&quot;, code&#x3D;&quot;500&quot;&#125;  0.04            &#x2F;&#x2F;  24 &#x2F; 600&#123;method&#x3D;&quot;get&quot;, code&#x3D;&quot;404&quot;&#125;  0.05            &#x2F;&#x2F;  30 &#x2F; 600&#123;method&#x3D;&quot;post&quot;, code&#x3D;&quot;500&quot;&#125; 0.05            &#x2F;&#x2F;   6 &#x2F; 120&#123;method&#x3D;&quot;post&quot;, code&#x3D;&quot;404&quot;&#125; 0.175           &#x2F;&#x2F;  21 &#x2F; 120</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提醒：group修饰符只能在比较和数学运算符中使用。在逻辑运算and,unless和or才注意操作中默认与右向量中的所有元素进行匹配。</p>
</blockquote>
<h1 id="PromQL聚合操作"><a href="#PromQL聚合操作" class="headerlink" title="PromQL聚合操作"></a>PromQL聚合操作</h1><p>Prometheus还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。可以将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。</p>
<ul>
<li><code>sum</code> (求和)</li>
<li><code>min</code> (最小值)</li>
<li><code>max</code> (最大值)</li>
<li><code>avg</code> (平均值)</li>
<li><code>stddev</code> (标准差)</li>
<li><code>stdvar</code> (标准方差)</li>
<li><code>count</code> (计数)</li>
<li><code>count_values</code> (对value进行计数)</li>
<li><code>bottomk</code> (后n条时序)</li>
<li><code>topk</code> (前n条时序)</li>
<li><code>quantile</code> (分位数)</li>
</ul>
<p>使用聚合操作的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br></pre></td></tr></table></figure>
<p>其中只有<code>count_values</code>, <code>quantile</code>, <code>topk</code>, <code>bottomk</code>支持参数(parameter)。</p>
<p>without用于从计算结果中移除列举的标签，而保留其它标签。by则正好相反，结果向量中只保留列出的标签，其余标签则移除。通过without和by可以按照样本的问题对数据进行聚合。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) without (instance)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) by (code,handler,job,method)</span><br></pre></td></tr></table></figure>
<p>如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total)</span><br></pre></td></tr></table></figure>
<p>count_values用于时间序列中每一个样本值出现的次数。count_values会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count_values(&quot;count&quot;, http_requests_total)</span><br></pre></td></tr></table></figure>
<p>topk和bottomk则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。</p>
<p>获取HTTP请求数前5位的时序样本数据，可以使用表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(5, http_requests_total)</span><br></pre></td></tr></table></figure>
<p>quantile用于计算当前样本数据值的分布情况quantile(φ, express)其中0 ≤ φ ≤ 1。</p>
<p>例如，当φ为0.5时，即表示找到当前样本数据中的中位数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(0.5, http_requests_total)</span><br></pre></td></tr></table></figure>
<h1 id="PromQL内置函数"><a href="#PromQL内置函数" class="headerlink" title="PromQL内置函数"></a>PromQL内置函数</h1><p>在上一小节中，我们已经看到了类似于irate()这样的函数，可以帮助我们计算监控指标的增长率。除了irate以外，Prometheus还提供了其它大量的内置函数，可以对时序数据进行丰富的处理。本小节将带来读者了解一些常用的内置函数以及相关的使用场景和用法。</p>
<h2 id="计算Counter指标增长率"><a href="#计算Counter指标增长率" class="headerlink" title="计算Counter指标增长率"></a>计算Counter指标增长率</h2><p>我们知道Counter类型的监控指标其特点是只增不减，在没有发生重置（如服务器重启，应用重启）的情况下其样本值应该是不断增大的。为了能够更直观的表示样本数据的变化剧烈情况，需要计算样本的增长速率。</p>
<p>如下图所示，样本增长率反映出了样本变化的剧烈程度：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yunlzheng/prometheus-book/blob/master/promql/static/counter-to-rate.png"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/counter-to-rate.png" alt="通过增长率表示样本的变化情况"></a></p>
<p>increase(v range-vector)函数是PromQL中提供的众多内置函数之一。其中参数v是一个区间向量，increase函数获取区间向量中的第一个后最后一个样本并返回其增长量。因此，可以通过以下表达式Counter类型指标的增长率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(node_cpu[2m]) &#x2F; 120</span><br></pre></td></tr></table></figure>
<p>这里通过node_cpu[2m]获取时间序列最近两分钟的所有样本，increase计算出最近两分钟的增长量，最后除以时间120秒得到node_cpu样本在最近两分钟的平均增长率。并且这个值也近似于主机节点最近两分钟内的平均CPU使用率。</p>
<p>除了使用increase函数以外，PromQL中还直接内置了rate(v range-vector)函数，rate函数可以直接计算区间向量v在时间窗口内平均增长速率。因此，通过以下表达式可以得到与increase函数相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(node_cpu[2m])</span><br></pre></td></tr></table></figure>
<p>需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。  例如，对于主机而言在2分钟的时间窗口内，可能在某一个由于访问量或者其它问题导致CPU占用100%的情况，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。</p>
<p>为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v  range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(node_cpu[2m])</span><br></pre></td></tr></table></figure>
<p>irate函数相比于rate函数提供了更高的灵敏度，不过当需要分析长期趋势或者在告警规则中，irate的这种灵敏度反而容易造成干扰。因此在长期趋势分析或者告警中更推荐使用rate函数。</p>
<h2 id="预测Gauge指标变化趋势"><a href="#预测Gauge指标变化趋势" class="headerlink" title="预测Gauge指标变化趋势"></a>预测Gauge指标变化趋势</h2><p>在一般情况下，系统管理员为了确保业务的持续可用运行，会针对服务器的资源设置相应的告警阈值。例如，当磁盘空间只剩512MB时向相关人员发送告警通知。 这种基于阈值的告警模式对于当资源用量是平滑增长的情况下是能够有效的工作的。 但是如果资源不是平滑变化的呢？  比如有些某些业务增长，存储空间的增长速率提升了高几倍。这时，如果基于原有阈值去触发告警，当系统管理员接收到告警以后可能还没来得及去处理问题，系统就已经不可用了。 因此阈值通常来说不是固定的，需要定期进行调整才能保证该告警阈值能够发挥去作用。 那么还有没有更好的方法吗？</p>
<p>PromQL中内置的predict_linear(v range-vector, t scalar)  函数可以帮助系统管理员更好的处理此类情况，predict_linear函数可以预测时间序列v在t秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。例如，基于2小时的样本数据，来预测主机可用磁盘空间的是否在4个小时候被占满，可以使用如下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job&#x3D;&quot;node&quot;&#125;[2h], 4 * 3600) &lt; 0</span><br></pre></td></tr></table></figure>
<h2 id="统计Histogram指标的分位数"><a href="#统计Histogram指标的分位数" class="headerlink" title="统计Histogram指标的分位数"></a>统计Histogram指标的分位数</h2><p>在本章的第2小节中，我们介绍了Prometheus的四种监控指标类型，其中Histogram和Summary都可以用于统计和分析数据的分布情况。区别在于Summary是直接在客户端计算了数据分布的分位数情况。而Histogram的分位数计算需要通过histogram_quantile(φ float, b  instant-vector)函数进行计算。其中φ（0&lt;φ&lt;1）表示需要计算的分位数，如果需要计算中位数φ取值为0.5，以此类推即可。</p>
<p>以指标http_request_duration_seconds_bucket为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_request_duration_seconds request duration histogram# TYPE http_request_duration_seconds histogramhttp_request_duration_seconds_bucket&#123;le&#x3D;&quot;0.5&quot;&#125; 0http_request_duration_seconds_bucket&#123;le&#x3D;&quot;1&quot;&#125; 1http_request_duration_seconds_bucket&#123;le&#x3D;&quot;2&quot;&#125; 2http_request_duration_seconds_bucket&#123;le&#x3D;&quot;3&quot;&#125; 3http_request_duration_seconds_bucket&#123;le&#x3D;&quot;5&quot;&#125; 3http_request_duration_seconds_bucket&#123;le&#x3D;&quot;+Inf&quot;&#125; 3http_request_duration_seconds_sum 6http_request_duration_seconds_count 3</span><br></pre></td></tr></table></figure>
<p>当计算9分位数时，使用如下表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.5, http_request_duration_seconds_bucket)</span><br></pre></td></tr></table></figure>
<p>通过对Histogram类型的监控指标，用户可以轻松获取样本数据的分布情况。同时分位数的计算，也可以非常方便的用于评判当前监控指标的服务水平。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yunlzheng/prometheus-book/blob/master/promql/static/histogram_quantile.png"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/histogram_quantile.png" alt="获取分布直方图的中位数"></a></p>
<p>需要注意的是通过histogram_quantile计算的分位数，并非为精确值，而是通过http_request_duration_seconds_bucket和http_request_duration_seconds_sum近似计算的结果。</p>
<h2 id="动态标签替换"><a href="#动态标签替换" class="headerlink" title="动态标签替换"></a>动态标签替换</h2><p>一般来说来说，使用PromQL查询到时间序列后，可视化工具会根据时间序列的标签来渲染图表。例如通过up指标可以获取到当前所有运行的Exporter实例以及其状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up&#123;instance&#x3D;&quot;localhost:8080&quot;,job&#x3D;&quot;cadvisor&quot;&#125;	1up&#123;instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;&#125;	1up&#123;instance&#x3D;&quot;localhost:9100&quot;,job&#x3D;&quot;node&quot;&#125;	1</span><br></pre></td></tr></table></figure>
<p>这是可视化工具渲染图标时可能根据，instance和job的值进行渲染，为了能够让客户端的图标更具有可读性，可以通过label_replace标签为时间序列添加额外的标签。label_replace的具体参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span><br></pre></td></tr></table></figure>
<p>该函数会依次对v中的每一条时间序列进行处理，通过regex匹配src_label的值，并将匹配部分relacement写入到dst_label标签中。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;,  &quot;(.*):.*&quot;)</span><br></pre></td></tr></table></figure>
<p>函数处理后，时间序列将包含一个host标签，host标签的值为Exporter实例的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up&#123;host&#x3D;&quot;localhost&quot;,instance&#x3D;&quot;localhost:8080&quot;,job&#x3D;&quot;cadvisor&quot;&#125;	1up&#123;host&#x3D;&quot;localhost&quot;,instance&#x3D;&quot;localhost:9090&quot;,job&#x3D;&quot;prometheus&quot;&#125;	1up&#123;host&#x3D;&quot;localhost&quot;,instance&#x3D;&quot;localhost:9100&quot;,job&#x3D;&quot;node&quot;&#125; 1</span><br></pre></td></tr></table></figure>
<p>除了label_replace以外，Prometheus还提供了label_join函数，该函数可以将时间序列中v多个标签src_label的值，通过separator作为连接符写入到一个新的标签dst_label中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</span><br></pre></td></tr></table></figure>
<p>label_replace和label_join函数提供了对时间序列标签的自定义能力，从而能够更好的于客户端或者可视化工具配合。</p>
<h2 id="其它内置函数"><a href="#其它内置函数" class="headerlink" title="其它内置函数"></a>其它内置函数</h2><p>除了上文介绍的这些内置函数以外，PromQL还提供了大量的其它内置函数。这些内置函数包括一些常用的数学计算、日期等等。这里就不一一细讲，感兴趣的读者可以通过阅读Prometheus的官方文档，了解这些函数的使用方式。</p>
<p><a target="_blank" rel="noopener" href="https://prometheus.io/docs/prometheus/latest/querying/functions/">https://prometheus.io/docs/prometheus/latest/querying/functions/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:kinmfer@foxmail.com">Kinmfer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://kinmfer.github.io/2021/04/29/%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84-Prometheus-PromeQL/">https://kinmfer.github.io/2021/04/29/综合架构-Prometheus-PromeQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Kinmfer.github.io" target="_blank">Kinmfer's Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9B%91%E6%8E%A7/">监控</a><a class="post-meta__tags" href="/tags/Prometheus/">Prometheus</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/kinmfer/BlogImages/raw/master/img/prometheus.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/03/%E6%8A%80%E5%B7%A7-02-%E4%B8%8B%E8%BD%BDgcr%E9%95%9C%E5%83%8F/"><img class="prev-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/gcr.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">技巧-02-下载gcr镜像</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/22/%E4%BA%91-Kubernetes-%E5%8D%87%E7%BA%A7/"><img class="next-cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/k8s-logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">云计算-Kubernetes-升级</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/15/综合架构-Zabbix-01-介绍+部署/" title="Zabbix-01-介绍+部署"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-15</div><div class="title">Zabbix-01-介绍+部署</div></div></a></div><div><a href="/2020/07/17/综合架构-Zabbix-02-监控项+触发+报警/" title="Zabbix-02-监控项+触发+报警"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">Zabbix-02-监控项+触发+报警</div></div></a></div><div><a href="/2020/07/17/综合架构-Zabbix-03-自定义图像+自定义模板/" title="Zabbix-03-自定义图像+自定义模板"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">Zabbix-03-自定义图像+自定义模板</div></div></a></div><div><a href="/2020/07/17/综合架构-Zabbix-04-监控维度+拓展/" title="Zabbix-04-监控维度+拓展"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">Zabbix-04-监控维度+拓展</div></div></a></div><div><a href="/2020/07/17/综合架构-Zabbix-05-自动发现+注册+agent/" title="Zabbix-05-自动发现+注册+agent"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">Zabbix-05-自动发现+注册+agent</div></div></a></div><div><a href="/2020/07/17/综合架构-Zabbix-06-性能优化+api使用+高可用/" title="Zabbix-06-性能优化+api使用+高可用"><img class="cover" src="https://gitee.com/kinmfer/BlogImages/raw/master/img/下载.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-17</div><div class="title">Zabbix-06-性能优化+api使用+高可用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81MTkzMi8yODQxMw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Kinmfer</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Kinmfer"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Kinmfer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:kinmfer@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！本博客用于记录一些学习过程中的文章，包括原创，也包括转录其他大神的博客。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">理解时间序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">样本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%A0%87-Metric"><span class="toc-number">1.2.</span> <span class="toc-text">指标(Metric)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Metrics%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Metrics类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Counter%EF%BC%9A%E5%8F%AA%E5%A2%9E%E4%B8%8D%E5%87%8F%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Counter：只增不减的计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gauge%EF%BC%9A%E5%8F%AF%E5%A2%9E%E5%8F%AF%E5%87%8F%E7%9A%84%E4%BB%AA%E8%A1%A8%E7%9B%98"><span class="toc-number">2.2.</span> <span class="toc-text">Gauge：可增可减的仪表盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Histogram%E5%92%8CSummary%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">2.3.</span> <span class="toc-text">使用Histogram和Summary分析数据分布情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">PromQL使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">查询时间序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.</span> <span class="toc-text">范围查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">时间位移操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.</span> <span class="toc-text">使用聚合操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">标量和字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%EF%BC%88Scalar%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%9A%84%E6%95%B0%E5%AD%97%E5%80%BC"><span class="toc-number">3.5.1.</span> <span class="toc-text">标量（Scalar）：一个浮点型的数字值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC"><span class="toc-number">3.5.2.</span> <span class="toc-text">字符串（String）：一个简单的字符串值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%B3%95%E7%9A%84PromQL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">合法的PromQL表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">PromQL操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.</span> <span class="toc-text">数学运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E8%BF%87%E6%BB%A4%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">使用布尔运算过滤时间序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8bool%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%94%B9%E5%8F%98%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.3.</span> <span class="toc-text">使用bool修饰符改变布尔运算符的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">使用集合运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.5.</span> <span class="toc-text">操作符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">匹配模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%8C%B9%E9%85%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text">一对一匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.6.2.</span> <span class="toc-text">多对一和一对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">PromQL聚合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PromQL%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">PromQL内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97Counter%E6%8C%87%E6%A0%87%E5%A2%9E%E9%95%BF%E7%8E%87"><span class="toc-number">6.1.</span> <span class="toc-text">计算Counter指标增长率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8BGauge%E6%8C%87%E6%A0%87%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF"><span class="toc-number">6.2.</span> <span class="toc-text">预测Gauge指标变化趋势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1Histogram%E6%8C%87%E6%A0%87%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">统计Histogram指标的分位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%87%E7%AD%BE%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.4.</span> <span class="toc-text">动态标签替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">其它内置函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/10/%E5%AD%A6%E4%B9%A0-01-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84shell%E8%84%9A%E6%9C%AC/" title="学习-01-如何编写可靠的shell脚本"><img src="https://gitee.com/Kinmfer/BlogImages/raw/master/img/1soSr8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习-01-如何编写可靠的shell脚本"/></a><div class="content"><a class="title" href="/2021/09/10/%E5%AD%A6%E4%B9%A0-01-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84shell%E8%84%9A%E6%9C%AC/" title="学习-01-如何编写可靠的shell脚本">学习-01-如何编写可靠的shell脚本</a><time datetime="2021-09-10T11:25:37.000Z" title="发表于 2021-09-10 19:25:37">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/22/Vue-2.x%E7%AC%94%E8%AE%B0/" title="Vue 2.x笔记"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue 2.x笔记"/></a><div class="content"><a class="title" href="/2021/05/22/Vue-2.x%E7%AC%94%E8%AE%B0/" title="Vue 2.x笔记">Vue 2.x笔记</a><time datetime="2021-05-22T11:30:24.000Z" title="发表于 2021-05-22 19:30:24">2021-05-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/13/%E5%AE%9E%E7%94%A8Python%E8%84%9A%E6%9C%AC/" title="实用Python脚本"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/python.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实用Python脚本"/></a><div class="content"><a class="title" href="/2021/05/13/%E5%AE%9E%E7%94%A8Python%E8%84%9A%E6%9C%AC/" title="实用Python脚本">实用Python脚本</a><time datetime="2021-05-13T01:25:54.000Z" title="发表于 2021-05-13 09:25:54">2021-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/13/%E5%AE%9E%E7%94%A8Shell%E8%84%9A%E6%9C%AC/" title="实用Shell脚本"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/shell.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实用Shell脚本"/></a><div class="content"><a class="title" href="/2021/05/13/%E5%AE%9E%E7%94%A8Shell%E8%84%9A%E6%9C%AC/" title="实用Shell脚本">实用Shell脚本</a><time datetime="2021-05-13T01:12:20.000Z" title="发表于 2021-05-13 09:12:20">2021-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/05/%E6%8A%80%E5%B7%A7-03-Linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" title="技巧-03-Linux科学上网"><img src="https://gitee.com/kinmfer/BlogImages/raw/master/img/v2ray.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技巧-03-Linux科学上网"/></a><div class="content"><a class="title" href="/2021/05/05/%E6%8A%80%E5%B7%A7-03-Linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" title="技巧-03-Linux科学上网">技巧-03-Linux科学上网</a><time datetime="2021-05-05T04:48:50.000Z" title="发表于 2021-05-05 12:48:50">2021-05-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://gitee.com/kinmfer/BlogImages/raw/master/img/prometheus.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Kinmfer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kinmfer.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'vSKb5nQqvUv44yjbvGjUmk3E-gzGzoHsz',
      appKey: '4TRbJGECRE8pcN777qgBXsKO',
      placeholder: '记得留下你的昵称和邮箱,可以快速收到回复哦~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_����":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_͵Ц":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_�ټ�":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_��Į":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_��ŭ":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_�ɰ�":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_��Ѫ":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_��":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_Ż��":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_��Ц":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_���":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_ί��":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_΢Ц":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_˼��":"90cf159733e558137ed20aa04d09964436f618a1.png"},
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="//code.tidio.co/mzqu2o1lbhle9bvhab8bexgtiyxgkheb.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>